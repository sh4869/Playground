dart_library.library('dart/html', null, /* Imports */[
  'dart/_runtime',
  'dart/math',
  'dart/_interceptors',
  'dart/core',
  'dart/_metadata',
  'dart/_js_helper',
  'dart/async',
  'dart/isolate',
  'dart/typed_data',
  'dart/_foreign_helper',
  'dart/collection'
], /* Lazy imports */[
  'dart/html_common',
  'dart/web_gl',
  'dart/svg',
  'dart/web_sql',
  'dart/indexed_db'
], function(exports, dart, math, _interceptors, core, _metadata, _js_helper, async, isolate, typed_data, _foreign_helper, collection, html_common, web_gl, svg, web_sql, indexed_db) {
  'use strict';
  let dartx = dart.dartx;
  dart.export(exports, math, ['Rectangle', 'Point'], []);
  dart.copyProperties(exports, {
    get window() {
      return dart.as(window, Window);
    },
    get document() {
      return dart.as(document, HtmlDocument);
    }
  });
  const _addEventListener = Symbol('_addEventListener');
  const _removeEventListener = Symbol('_removeEventListener');
  dart.defineExtensionNames([
    'on',
    'addEventListener',
    'removeEventListener',
    'dispatchEvent'
  ]);
  class EventTarget extends _interceptors.Interceptor {
    _created() {
      super.Interceptor();
    }
    get [dartx.on]() {
      return new Events(this);
    }
    [dartx.addEventListener](type, listener, useCapture) {
      if (useCapture === void 0) useCapture = null;
      if (listener != null) {
        this[_addEventListener](type, listener, useCapture);
      }
    }
    [dartx.removeEventListener](type, listener, useCapture) {
      if (useCapture === void 0) useCapture = null;
      if (listener != null) {
        this[_removeEventListener](type, listener, useCapture);
      }
    }
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    [_addEventListener](type, listener, useCapture) {
      return this.addEventListener(type, listener, useCapture);
    }
    [dartx.dispatchEvent](event) {
      return this.dispatchEvent(event);
    }
    [_removeEventListener](type, listener, useCapture) {
      return this.removeEventListener(type, listener, useCapture);
    }
  }
  dart.defineNamedConstructor(EventTarget, '_created');
  dart.setSignature(EventTarget, {
    constructors: () => ({
      _created: [EventTarget, []],
      _: [EventTarget, []]
    }),
    methods: () => ({
      [dartx.addEventListener]: [dart.void, [core.String, EventListener], [core.bool]],
      [dartx.removeEventListener]: [dart.void, [core.String, EventListener], [core.bool]],
      [_addEventListener]: [dart.void, [], [core.String, EventListener, core.bool]],
      [dartx.dispatchEvent]: [core.bool, [Event]],
      [_removeEventListener]: [dart.void, [], [core.String, EventListener, core.bool]]
    })
  });
  EventTarget[dart.metadata] = () => [dart.const(new _metadata.DomName('EventTarget')), dart.const(new _js_helper.Native("EventTarget"))];
  dart.registerExtension(dart.global.EventTarget, EventTarget);
  const _localName = Symbol('_localName');
  const _namespaceUri = Symbol('_namespaceUri');
  const _removeChild = Symbol('_removeChild');
  const _replaceChild = Symbol('_replaceChild');
  const _this = Symbol('_this');
  const _clearChildren = Symbol('_clearChildren');
  dart.defineExtensionNames([
    'nodes',
    'nodes',
    'remove',
    'replaceWith',
    'insertAllBefore',
    'toString',
    'append',
    'clone',
    'contains',
    'hasChildNodes',
    'insertBefore',
    'childNodes',
    'baseUri',
    'firstChild',
    'lastChild',
    'nextNode',
    'nodeName',
    'nodeType',
    'nodeValue',
    'ownerDocument',
    'parent',
    'parentNode',
    'previousNode',
    'text'
  ]);
  class Node extends EventTarget {
    _created() {
      this[dartx.childNodes] = null;
      this[dartx.baseUri] = null;
      this[dartx.firstChild] = null;
      this[dartx.lastChild] = null;
      this[_localName] = null;
      this[_namespaceUri] = null;
      this[dartx.nextNode] = null;
      this[dartx.nodeName] = null;
      this[dartx.nodeType] = null;
      this[dartx.nodeValue] = null;
      this[dartx.ownerDocument] = null;
      this[dartx.parent] = null;
      this[dartx.parentNode] = null;
      this[dartx.previousNode] = null;
      this[dartx.text] = null;
      super._created();
    }
    get [dartx.nodes]() {
      return new _ChildNodeListLazy(this);
    }
    set [dartx.nodes](value) {
      let copy = core.List.from(value);
      this[dartx.text] = '';
      for (let node of dart.as(copy, core.Iterable$(Node))) {
        this[dartx.append](node);
      }
    }
    [dartx.remove]() {
      if (this[dartx.parentNode] != null) {
        let parent = this[dartx.parentNode];
        this[dartx.parentNode][_removeChild](this);
      }
    }
    [dartx.replaceWith](otherNode) {
      try {
        let parent = this[dartx.parentNode];
        parent[_replaceChild](otherNode, this);
      } catch (e) {
      }

      ;
      return this;
    }
    [dartx.insertAllBefore](newNodes, refChild) {
      if (dart.is(newNodes, _ChildNodeListLazy)) {
        let otherList = newNodes;
        if (core.identical(otherList[_this], this)) {
          dart.throw(new core.ArgumentError(newNodes));
        }
        for (let i = 0, len = otherList.length; i < dart.notNull(len); ++i) {
          this[dartx.insertBefore](otherList[_this][dartx.firstChild], refChild);
        }
      } else {
        for (let node of newNodes) {
          this[dartx.insertBefore](node, refChild);
        }
      }
    }
    [_clearChildren]() {
      while (this[dartx.firstChild] != null) {
        this[_removeChild](this[dartx.firstChild]);
      }
    }
    toString() {
      let value = this[dartx.nodeValue];
      return value == null ? super.toString() : value;
    }
    get [dartx.childNodes]() {
      return this.childNodes;
    }
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.baseUri]() {
      return this.baseURI;
    }
    get [dartx.firstChild]() {
      return this.firstChild;
    }
    get [dartx.lastChild]() {
      return this.lastChild;
    }
    get [_localName]() {
      return this.localName;
    }
    get [_namespaceUri]() {
      return this.namespaceURI;
    }
    get [dartx.nextNode]() {
      return this.nextSibling;
    }
    get [dartx.nodeName]() {
      return this.nodeName;
    }
    get [dartx.nodeType]() {
      return this.nodeType;
    }
    get [dartx.nodeValue]() {
      return this.nodeValue;
    }
    get [dartx.ownerDocument]() {
      return this.ownerDocument;
    }
    get [dartx.parent]() {
      return this.parentElement;
    }
    get [dartx.parentNode]() {
      return this.parentNode;
    }
    get [dartx.previousNode]() {
      return this.previousSibling;
    }
    get [dartx.text]() {
      return this.textContent;
    }
    set [dartx.text](value) {
      this.textContent = value;
    }
    [dartx.append](newChild) {
      return this.appendChild(newChild);
    }
    [dartx.clone](deep) {
      return this.cloneNode(deep);
    }
    [dartx.contains](other) {
      return this.contains(other);
    }
    [dartx.hasChildNodes]() {
      return this.hasChildNodes();
    }
    [dartx.insertBefore](newChild, refChild) {
      return this.insertBefore(newChild, refChild);
    }
    [_removeChild](oldChild) {
      return this.removeChild(oldChild);
    }
    [_replaceChild](newChild, oldChild) {
      return this.replaceChild(newChild, oldChild);
    }
  }
  dart.defineNamedConstructor(Node, '_created');
  dart.setSignature(Node, {
    constructors: () => ({
      _created: [Node, []],
      _: [Node, []]
    }),
    methods: () => ({
      [dartx.remove]: [dart.void, []],
      [dartx.replaceWith]: [Node, [Node]],
      [dartx.insertAllBefore]: [Node, [core.Iterable$(Node), Node]],
      [_clearChildren]: [dart.void, []],
      [dartx.append]: [Node, [Node]],
      [dartx.clone]: [Node, [core.bool]],
      [dartx.contains]: [core.bool, [Node]],
      [dartx.hasChildNodes]: [core.bool, []],
      [dartx.insertBefore]: [Node, [Node, Node]],
      [_removeChild]: [Node, [Node]],
      [_replaceChild]: [Node, [Node, Node]]
    })
  });
  Node[dart.metadata] = () => [dart.const(new _metadata.DomName('Node')), dart.const(new _js_helper.Native("Node"))];
  Node.ATTRIBUTE_NODE = 2;
  Node.CDATA_SECTION_NODE = 4;
  Node.COMMENT_NODE = 8;
  Node.DOCUMENT_FRAGMENT_NODE = 11;
  Node.DOCUMENT_NODE = 9;
  Node.DOCUMENT_TYPE_NODE = 10;
  Node.ELEMENT_NODE = 1;
  Node.ENTITY_NODE = 6;
  Node.ENTITY_REFERENCE_NODE = 5;
  Node.NOTATION_NODE = 12;
  Node.PROCESSING_INSTRUCTION_NODE = 7;
  Node.TEXT_NODE = 3;
  dart.registerExtension(dart.global.Node, Node);
  const _xtag = Symbol('_xtag');
  const _attributes = Symbol('_attributes');
  const _clientHeight = Symbol('_clientHeight');
  const _clientLeft = Symbol('_clientLeft');
  const _clientTop = Symbol('_clientTop');
  const _clientWidth = Symbol('_clientWidth');
  const _innerHtml = Symbol('_innerHtml');
  const _offsetHeight = Symbol('_offsetHeight');
  const _offsetLeft = Symbol('_offsetLeft');
  const _offsetTop = Symbol('_offsetTop');
  const _offsetWidth = Symbol('_offsetWidth');
  const _scrollHeight = Symbol('_scrollHeight');
  const _scrollLeft = Symbol('_scrollLeft');
  const _scrollTop = Symbol('_scrollTop');
  const _scrollWidth = Symbol('_scrollWidth');
  const _childElementCount = Symbol('_childElementCount');
  const _children = Symbol('_children');
  const _firstElementChild = Symbol('_firstElementChild');
  const _lastElementChild = Symbol('_lastElementChild');
  const _querySelectorAll = Symbol('_querySelectorAll');
  const _getComputedStyle = Symbol('_getComputedStyle');
  const _animate = Symbol('_animate');
  const _scrollIntoView = Symbol('_scrollIntoView');
  const _scrollIntoViewIfNeeded = Symbol('_scrollIntoViewIfNeeded');
  const _insertAdjacentText = Symbol('_insertAdjacentText');
  const _insertAdjacentNode = Symbol('_insertAdjacentNode');
  const _insertAdjacentHtml = Symbol('_insertAdjacentHtml');
  const _insertAdjacentElement = Symbol('_insertAdjacentElement');
  const _canBeUsedToCreateContextualFragment = Symbol('_canBeUsedToCreateContextualFragment');
  const _cannotBeUsedToCreateContextualFragment = Symbol('_cannotBeUsedToCreateContextualFragment');
  const _getElementsByTagName = Symbol('_getElementsByTagName');
  const _hasAttribute = Symbol('_hasAttribute');
  const _hasAttributeNS = Symbol('_hasAttributeNS');
  const _removeAttribute = Symbol('_removeAttribute');
  const _removeAttributeNS = Symbol('_removeAttributeNS');
  dart.defineExtensionNames([
    'attributes',
    'attributes',
    'children',
    'children',
    'querySelectorAll',
    'query',
    'queryAll',
    'classes',
    'classes',
    'dataset',
    'dataset',
    'getNamespacedAttributes',
    'getComputedStyle',
    'client',
    'offset',
    'appendText',
    'appendHtml',
    'attached',
    'detached',
    'enteredView',
    'leftView',
    'animate',
    'attributeChanged',
    'xtag',
    'xtag',
    'localName',
    'namespaceUri',
    'toString',
    'scrollIntoView',
    'insertAdjacentText',
    'insertAdjacentHtml',
    'insertAdjacentElement',
    'matches',
    'matchesWithAncestors',
    'createShadowRoot',
    'shadowRoot',
    'contentEdge',
    'paddingEdge',
    'borderEdge',
    'marginEdge',
    'documentOffset',
    'offsetTo',
    'createFragment',
    'innerHtml',
    'setInnerHtml',
    'innerHtml',
    'on',
    'offsetHeight',
    'offsetLeft',
    'offsetTop',
    'offsetWidth',
    'clientHeight',
    'clientLeft',
    'clientTop',
    'clientWidth',
    'scrollHeight',
    'scrollLeft',
    'scrollLeft',
    'scrollTop',
    'scrollTop',
    'scrollWidth',
    'click',
    'blur',
    'focus',
    'getAnimationPlayers',
    'getAttribute',
    'getAttributeNS',
    'getBoundingClientRect',
    'getClientRects',
    'getDestinationInsertionPoints',
    'getElementsByClassName',
    'requestFullscreen',
    'requestPointerLock',
    'setAttribute',
    'setAttributeNS',
    'querySelector',
    'onAbort',
    'onBeforeCopy',
    'onBeforeCut',
    'onBeforePaste',
    'onBlur',
    'onCanPlay',
    'onCanPlayThrough',
    'onChange',
    'onClick',
    'onContextMenu',
    'onCopy',
    'onCut',
    'onDoubleClick',
    'onDrag',
    'onDragEnd',
    'onDragEnter',
    'onDragLeave',
    'onDragOver',
    'onDragStart',
    'onDrop',
    'onDurationChange',
    'onEmptied',
    'onEnded',
    'onError',
    'onFocus',
    'onInput',
    'onInvalid',
    'onKeyDown',
    'onKeyPress',
    'onKeyUp',
    'onLoad',
    'onLoadedData',
    'onLoadedMetadata',
    'onMouseDown',
    'onMouseEnter',
    'onMouseLeave',
    'onMouseMove',
    'onMouseOut',
    'onMouseOver',
    'onMouseUp',
    'onMouseWheel',
    'onPaste',
    'onPause',
    'onPlay',
    'onPlaying',
    'onRateChange',
    'onReset',
    'onResize',
    'onScroll',
    'onSearch',
    'onSeeked',
    'onSeeking',
    'onSelect',
    'onSelectStart',
    'onStalled',
    'onSubmit',
    'onSuspend',
    'onTimeUpdate',
    'onTouchCancel',
    'onTouchEnd',
    'onTouchEnter',
    'onTouchLeave',
    'onTouchMove',
    'onTouchStart',
    'onTransitionEnd',
    'onVolumeChange',
    'onWaiting',
    'onFullscreenChange',
    'onFullscreenError',
    'contentEditable',
    'contextMenu',
    'dir',
    'draggable',
    'hidden',
    'isContentEditable',
    'lang',
    'spellcheck',
    'tabIndex',
    'title',
    'translate',
    'dropzone',
    'className',
    'id',
    'offsetParent',
    'outerHtml',
    'style',
    'tagName',
    'nextElementSibling',
    'previousElementSibling'
  ]);
  class Element extends Node {
    static html(html, opts) {
      let validator = opts && 'validator' in opts ? opts.validator : null;
      let treeSanitizer = opts && 'treeSanitizer' in opts ? opts.treeSanitizer : null;
      let fragment = exports.document[dartx.body][dartx.createFragment](html, {validator: validator, treeSanitizer: treeSanitizer});
      return dart.as(fragment[dartx.nodes][dartx.where](dart.fn(e => dart.is(e, Element), core.bool, [Node]))[dartx.single], Element);
    }
    created() {
      this[_xtag] = null;
      this[dartx.contentEditable] = null;
      this[dartx.contextMenu] = null;
      this[dartx.dir] = null;
      this[dartx.draggable] = null;
      this[dartx.hidden] = null;
      this[dartx.isContentEditable] = null;
      this[dartx.lang] = null;
      this[dartx.spellcheck] = null;
      this[dartx.tabIndex] = null;
      this[dartx.title] = null;
      this[dartx.translate] = null;
      this[dartx.dropzone] = null;
      this[_attributes] = null;
      this[dartx.className] = null;
      this[_clientHeight] = null;
      this[_clientLeft] = null;
      this[_clientTop] = null;
      this[_clientWidth] = null;
      this[dartx.id] = null;
      this[_innerHtml] = null;
      this[_offsetHeight] = null;
      this[_offsetLeft] = null;
      this[dartx.offsetParent] = null;
      this[_offsetTop] = null;
      this[_offsetWidth] = null;
      this[dartx.outerHtml] = null;
      this[_scrollHeight] = null;
      this[_scrollLeft] = null;
      this[_scrollTop] = null;
      this[_scrollWidth] = null;
      this[dartx.style] = null;
      this[dartx.tagName] = null;
      this[dartx.nextElementSibling] = null;
      this[dartx.previousElementSibling] = null;
      this[_childElementCount] = null;
      this[_children] = null;
      this[_firstElementChild] = null;
      this[_lastElementChild] = null;
      super._created();
    }
    static tag(tag, typeExtention) {
      if (typeExtention === void 0) typeExtention = null;
      return dart.as(_ElementFactoryProvider.createElement_tag(tag, typeExtention), Element);
    }
    static a() {
      return Element.tag('a');
    }
    static article() {
      return Element.tag('article');
    }
    static aside() {
      return Element.tag('aside');
    }
    static audio() {
      return Element.tag('audio');
    }
    static br() {
      return Element.tag('br');
    }
    static canvas() {
      return Element.tag('canvas');
    }
    static div() {
      return Element.tag('div');
    }
    static footer() {
      return Element.tag('footer');
    }
    static header() {
      return Element.tag('header');
    }
    static hr() {
      return Element.tag('hr');
    }
    static iframe() {
      return Element.tag('iframe');
    }
    static img() {
      return Element.tag('img');
    }
    static li() {
      return Element.tag('li');
    }
    static nav() {
      return Element.tag('nav');
    }
    static ol() {
      return Element.tag('ol');
    }
    static option() {
      return Element.tag('option');
    }
    static p() {
      return Element.tag('p');
    }
    static pre() {
      return Element.tag('pre');
    }
    static section() {
      return Element.tag('section');
    }
    static select() {
      return Element.tag('select');
    }
    static span() {
      return Element.tag('span');
    }
    static svg() {
      return Element.tag('svg');
    }
    static table() {
      return Element.tag('table');
    }
    static td() {
      return Element.tag('td');
    }
    static textarea() {
      return Element.tag('textarea');
    }
    static th() {
      return Element.tag('th');
    }
    static tr() {
      return Element.tag('tr');
    }
    static ul() {
      return Element.tag('ul');
    }
    static video() {
      return Element.tag('video');
    }
    get [dartx.attributes]() {
      return new _ElementAttributeMap(this);
    }
    set [dartx.attributes](value) {
      let attributes = this[dartx.attributes];
      attributes[dartx.clear]();
      for (let key of value[dartx.keys]) {
        attributes[dartx.set](key, value[dartx.get](key));
      }
    }
    get [dartx.children]() {
      return new _ChildrenElementList._wrap(this);
    }
    set [dartx.children](value) {
      let copy = core.List.from(value);
      let children = this[dartx.children];
      children[dartx.clear]();
      children[dartx.addAll](dart.as(copy, core.Iterable$(Element)));
    }
    [dartx.querySelectorAll](selectors) {
      return new _FrozenElementList._wrap(this[_querySelectorAll](selectors));
    }
    [dartx.query](relativeSelectors) {
      return this[dartx.querySelector](relativeSelectors);
    }
    [dartx.queryAll](relativeSelectors) {
      return this[dartx.querySelectorAll](relativeSelectors);
    }
    get [dartx.classes]() {
      return new exports._ElementCssClassSet(this);
    }
    set [dartx.classes](value) {
      let classSet = this[dartx.classes];
      classSet.clear();
      classSet.addAll(value);
    }
    get [dartx.dataset]() {
      return new _DataAttributeMap(this[dartx.attributes]);
    }
    set [dartx.dataset](value) {
      let data = this[dartx.dataset];
      data[dartx.clear]();
      for (let key of value[dartx.keys]) {
        data[dartx.set](key, value[dartx.get](key));
      }
    }
    [dartx.getNamespacedAttributes](namespace) {
      return new _NamespacedAttributeMap(this, namespace);
    }
    [dartx.getComputedStyle](pseudoElement) {
      if (pseudoElement === void 0) pseudoElement = null;
      if (pseudoElement == null) {
        pseudoElement = '';
      }
      return exports.window[_getComputedStyle](this, pseudoElement);
    }
    get [dartx.client]() {
      return new math.Rectangle(this[dartx.clientLeft], this[dartx.clientTop], this[dartx.clientWidth], this[dartx.clientHeight]);
    }
    get [dartx.offset]() {
      return new math.Rectangle(this[dartx.offsetLeft], this[dartx.offsetTop], this[dartx.offsetWidth], this[dartx.offsetHeight]);
    }
    [dartx.appendText](text) {
      this[dartx.append](Text.new(text));
    }
    [dartx.appendHtml](text, opts) {
      let validator = opts && 'validator' in opts ? opts.validator : null;
      let treeSanitizer = opts && 'treeSanitizer' in opts ? opts.treeSanitizer : null;
      this[dartx.insertAdjacentHtml]('beforeend', text, {validator: validator, treeSanitizer: treeSanitizer});
    }
    static isTagSupported(tag) {
      let e = _ElementFactoryProvider.createElement_tag(tag, null);
      return dart.is(e, Element) && !dart.is(e, UnknownElement);
    }
    [dartx.attached]() {
      this[dartx.enteredView]();
    }
    [dartx.detached]() {
      this[dartx.leftView]();
    }
    [dartx.enteredView]() {}
    [dartx.leftView]() {}
    [dartx.animate](frames, timing) {
      if (timing === void 0) timing = null;
      if (!dart.is(frames, core.Iterable) || !dart.notNull(frames[dartx.every](dart.fn(x => dart.is(x, core.Map), core.bool, [core.Map$(core.String, dart.dynamic)])))) {
        dart.throw(new core.ArgumentError("The frames parameter should be a List of Maps " + "with frame information"));
      }
      let convertedFrames = frames;
      if (dart.is(convertedFrames, core.Iterable)) {
        convertedFrames = dart.as(frames[dartx.map](html_common.convertDartToNative_Dictionary)[dartx.toList](), core.Iterable$(core.Map$(core.String, dart.dynamic)));
      }
      let convertedTiming = timing;
      if (dart.is(convertedTiming, core.Map)) {
        convertedTiming = html_common.convertDartToNative_Dictionary(dart.as(convertedTiming, core.Map));
      }
      return convertedTiming == null ? this[_animate](convertedFrames) : this[_animate](convertedFrames, convertedTiming);
    }
    [_animate](effect, timing) {
      return this.animate(effect, timing);
    }
    [dartx.attributeChanged](name, oldValue, newValue) {}
    get [_xtag]() {
      return this._xtag;
    }
    set [_xtag](value) {
      this._xtag = value;
    }
    get [dartx.xtag]() {
      return this[_xtag] != null ? this[_xtag] : this;
    }
    set [dartx.xtag](value) {
      this[_xtag] = value;
    }
    get [dartx.localName]() {
      return this[_localName];
    }
    get [dartx.namespaceUri]() {
      return this[_namespaceUri];
    }
    toString() {
      return this[dartx.localName];
    }
    [dartx.scrollIntoView](alignment) {
      if (alignment === void 0) alignment = null;
      let hasScrollIntoViewIfNeeded = true;
      hasScrollIntoViewIfNeeded = !!this.scrollIntoViewIfNeeded;
      if (dart.equals(alignment, ScrollAlignment.TOP)) {
        this[_scrollIntoView](true);
      } else if (dart.equals(alignment, ScrollAlignment.BOTTOM)) {
        this[_scrollIntoView](false);
      } else if (hasScrollIntoViewIfNeeded) {
        if (dart.equals(alignment, ScrollAlignment.CENTER)) {
          this[_scrollIntoViewIfNeeded](true);
        } else {
          this[_scrollIntoViewIfNeeded]();
        }
      } else {
        this[_scrollIntoView]();
      }
    }
    static _determineMouseWheelEventType(e) {
      return 'wheel';
    }
    static _determineTransitionEventType(e) {
      if (dart.notNull(html_common.Device.isWebKit)) {
        return 'webkitTransitionEnd';
      } else if (dart.notNull(html_common.Device.isOpera)) {
        return 'oTransitionEnd';
      }
      return 'transitionend';
    }
    [dartx.insertAdjacentText](where, text) {
      if (!!this.insertAdjacentText) {
        this[_insertAdjacentText](where, text);
      } else {
        this[_insertAdjacentNode](where, Text.new(text));
      }
    }
    [_insertAdjacentText](where, text) {
      return this.insertAdjacentText(where, text);
    }
    [dartx.insertAdjacentHtml](where, html, opts) {
      let validator = opts && 'validator' in opts ? opts.validator : null;
      let treeSanitizer = opts && 'treeSanitizer' in opts ? opts.treeSanitizer : null;
      if (dart.is(treeSanitizer, _TrustedHtmlTreeSanitizer)) {
        this[_insertAdjacentHtml](where, html);
      } else {
        this[_insertAdjacentNode](where, this[dartx.createFragment](html, {validator: validator, treeSanitizer: treeSanitizer}));
      }
    }
    [_insertAdjacentHtml](where, text) {
      return this.insertAdjacentHTML(where, text);
    }
    [dartx.insertAdjacentElement](where, element) {
      if (!!this.insertAdjacentElement) {
        this[_insertAdjacentElement](where, element);
      } else {
        this[_insertAdjacentNode](where, element);
      }
      return element;
    }
    [_insertAdjacentElement](where, element) {
      return this.insertAdjacentElement(where, element);
    }
    [_insertAdjacentNode](where, node) {
      switch (where[dartx.toLowerCase]()) {
        case 'beforebegin':
        {
          this[dartx.parentNode][dartx.insertBefore](node, this);
          break;
        }
        case 'afterbegin':
        {
          let first = dart.notNull(this[dartx.nodes][dartx.length]) > 0 ? this[dartx.nodes][dartx.get](0) : null;
          this[dartx.insertBefore](node, first);
          break;
        }
        case 'beforeend':
        {
          this[dartx.append](node);
          break;
        }
        case 'afterend':
        {
          this[dartx.parentNode][dartx.insertBefore](node, this[dartx.nextNode]);
          break;
        }
        default:
        {
          dart.throw(new core.ArgumentError(`Invalid position ${where}`));
        }
      }
    }
    [dartx.matches](selectors) {
      if (!!this.matches) {
        return this.matches(selectors);
      } else if (!!this.webkitMatchesSelector) {
        return this.webkitMatchesSelector(selectors);
      } else if (!!this.mozMatchesSelector) {
        return this.mozMatchesSelector(selectors);
      } else if (!!this.msMatchesSelector) {
        return this.msMatchesSelector(selectors);
      } else if (!!this.oMatchesSelector) {
        return this.oMatchesSelector(selectors);
      } else {
        dart.throw(new core.UnsupportedError("Not supported on this platform"));
      }
    }
    [dartx.matchesWithAncestors](selectors) {
      let elem = this;
      do {
        if (dart.notNull(elem[dartx.matches](selectors))) return true;
        elem = elem[dartx.parent];
      } while (elem != null);
      return false;
    }
    [dartx.createShadowRoot]() {
      return dart.as((this.createShadowRoot || this.webkitCreateShadowRoot).call(this), ShadowRoot);
    }
    get [dartx.shadowRoot]() {
      return dart.as(this.shadowRoot || this.webkitShadowRoot, ShadowRoot);
    }
    get [dartx.contentEdge]() {
      return new _ContentCssRect(this);
    }
    get [dartx.paddingEdge]() {
      return new _PaddingCssRect(this);
    }
    get [dartx.borderEdge]() {
      return new _BorderCssRect(this);
    }
    get [dartx.marginEdge]() {
      return new _MarginCssRect(this);
    }
    get [dartx.documentOffset]() {
      return this[dartx.offsetTo](exports.document[dartx.documentElement]);
    }
    [dartx.offsetTo](parent) {
      return Element._offsetToHelper(this, parent);
    }
    static _offsetToHelper(current, parent) {
      let sameAsParent = core.identical(current, parent);
      let foundAsParent = sameAsParent || parent[dartx.tagName] == 'HTML';
      if (current == null || sameAsParent) {
        if (foundAsParent) return new math.Point(0, 0);
        dart.throw(new core.ArgumentError("Specified element is not a transitive offset " + "parent of this element."));
      }
      let parentOffset = current[dartx.offsetParent];
      let p = Element._offsetToHelper(parentOffset, parent);
      return new math.Point(dart.dsend(p.x, '+', current[dartx.offsetLeft]), dart.dsend(p.y, '+', current[dartx.offsetTop]));
    }
    [dartx.createFragment](html, opts) {
      let validator = opts && 'validator' in opts ? opts.validator : null;
      let treeSanitizer = opts && 'treeSanitizer' in opts ? opts.treeSanitizer : null;
      if (treeSanitizer == null) {
        if (validator == null) {
          if (Element._defaultValidator == null) {
            Element._defaultValidator = new NodeValidatorBuilder.common();
          }
          validator = Element._defaultValidator;
        }
        if (Element._defaultSanitizer == null) {
          Element._defaultSanitizer = new _ValidatingTreeSanitizer(validator);
        } else {
          Element._defaultSanitizer.validator = validator;
        }
        treeSanitizer = Element._defaultSanitizer;
      } else if (validator != null) {
        dart.throw(new core.ArgumentError('validator can only be passed if treeSanitizer is null'));
      }
      if (Element._parseDocument == null) {
        Element._parseDocument = exports.document[dartx.implementation][dartx.createHtmlDocument]('');
        Element._parseRange = Element._parseDocument[dartx.createRange]();
        let base = Element._parseDocument[dartx.createElement]('base');
        dart.dput(base, 'href', exports.document[dartx.baseUri]);
        Element._parseDocument[dartx.head][dartx.append](base);
      }
      let contextElement = null;
      if (dart.is(this, BodyElement)) {
        contextElement = Element._parseDocument[dartx.body];
      } else {
        contextElement = Element._parseDocument[dartx.createElement](this[dartx.tagName]);
        Element._parseDocument[dartx.body][dartx.append](dart.as(contextElement, Node));
      }
      let fragment = null;
      if (dart.notNull(Range.supportsCreateContextualFragment) && dart.notNull(this[_canBeUsedToCreateContextualFragment])) {
        Element._parseRange[dartx.selectNodeContents](dart.as(contextElement, Node));
        fragment = Element._parseRange[dartx.createContextualFragment](html);
      } else {
        dart.dput(contextElement, _innerHtml, html);
        fragment = Element._parseDocument[dartx.createDocumentFragment]();
        while (dart.dload(contextElement, 'firstChild') != null) {
          dart.dsend(fragment, 'append', dart.dload(contextElement, 'firstChild'));
        }
      }
      if (!dart.equals(contextElement, Element._parseDocument[dartx.body])) {
        dart.dsend(contextElement, 'remove');
      }
      treeSanitizer.sanitizeTree(dart.as(fragment, Node));
      exports.document[dartx.adoptNode](dart.as(fragment, Node));
      return dart.as(fragment, DocumentFragment);
    }
    get [_canBeUsedToCreateContextualFragment]() {
      return !dart.notNull(this[_cannotBeUsedToCreateContextualFragment]);
    }
    get [_cannotBeUsedToCreateContextualFragment]() {
      return Element._tagsForWhichCreateContextualFragmentIsNotSupported[dartx.contains](this[dartx.tagName]);
    }
    set [dartx.innerHtml](html) {
      this[dartx.setInnerHtml](html);
    }
    [dartx.setInnerHtml](html, opts) {
      let validator = opts && 'validator' in opts ? opts.validator : null;
      let treeSanitizer = opts && 'treeSanitizer' in opts ? opts.treeSanitizer : null;
      this[dartx.text] = null;
      if (dart.is(treeSanitizer, _TrustedHtmlTreeSanitizer)) {
        this[_innerHtml] = html;
      } else {
        this[dartx.append](this[dartx.createFragment](html, {validator: validator, treeSanitizer: treeSanitizer}));
      }
    }
    get [dartx.innerHtml]() {
      return this[_innerHtml];
    }
    get [dartx.on]() {
      return new ElementEvents(this);
    }
    static _hasCorruptedAttributes(element) {
      return (function(element) {
        if (!(element.attributes instanceof NamedNodeMap)) {
          return true;
        }
        var childNodes = element.childNodes;
        if (element.lastChild && element.lastChild !== childNodes[childNodes.length - 1]) {
          return true;
        }
        if (element.children) {
          if (!(element.children instanceof HTMLCollection || element.children instanceof NodeList)) {
            return true;
          }
        }
        var length = 0;
        if (element.children) {
          length = element.children.length;
        }
        for (var i = 0; i < length; i++) {
          var child = element.children[i];
          if (child.id == 'attributes' || child.name == 'attributes' || child.id == 'lastChild' || child.name == 'lastChild' || child.id == 'children' || child.name == 'children') {
            return true;
          }
        }
        return false;
      })(element);
    }
    static _hasCorruptedAttributesAdditionalCheck(element) {
      return !(element.attributes instanceof NamedNodeMap);
    }
    static _safeTagName(element) {
      let result = 'element tag unavailable';
      try {
        if (typeof dart.dload(element, 'tagName') == 'string') {
          result = dart.as(dart.dload(element, 'tagName'), core.String);
        }
      } catch (e) {
      }

      return result;
    }
    get [dartx.offsetHeight]() {
      return this.offsetHeight[dartx.round]();
    }
    get [dartx.offsetLeft]() {
      return this.offsetLeft[dartx.round]();
    }
    get [dartx.offsetTop]() {
      return this.offsetTop[dartx.round]();
    }
    get [dartx.offsetWidth]() {
      return this.offsetWidth[dartx.round]();
    }
    get [dartx.clientHeight]() {
      return this.clientHeight[dartx.round]();
    }
    get [dartx.clientLeft]() {
      return this.clientLeft[dartx.round]();
    }
    get [dartx.clientTop]() {
      return this.clientTop[dartx.round]();
    }
    get [dartx.clientWidth]() {
      return this.clientWidth[dartx.round]();
    }
    get [dartx.scrollHeight]() {
      return this.scrollHeight[dartx.round]();
    }
    get [dartx.scrollLeft]() {
      return this.scrollLeft[dartx.round]();
    }
    set [dartx.scrollLeft](value) {
      this.scrollLeft = value[dartx.round]();
    }
    get [dartx.scrollTop]() {
      return this.scrollTop[dartx.round]();
    }
    set [dartx.scrollTop](value) {
      this.scrollTop = value[dartx.round]();
    }
    get [dartx.scrollWidth]() {
      return this.scrollWidth[dartx.round]();
    }
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.contentEditable]() {
      return this.contentEditable;
    }
    set [dartx.contentEditable](value) {
      this.contentEditable = value;
    }
    get [dartx.contextMenu]() {
      return this.contextMenu;
    }
    set [dartx.contextMenu](value) {
      this.contextMenu = value;
    }
    get [dartx.dir]() {
      return this.dir;
    }
    set [dartx.dir](value) {
      this.dir = value;
    }
    get [dartx.draggable]() {
      return this.draggable;
    }
    set [dartx.draggable](value) {
      this.draggable = value;
    }
    get [dartx.hidden]() {
      return this.hidden;
    }
    set [dartx.hidden](value) {
      this.hidden = value;
    }
    get [dartx.isContentEditable]() {
      return this.isContentEditable;
    }
    get [dartx.lang]() {
      return this.lang;
    }
    set [dartx.lang](value) {
      this.lang = value;
    }
    get [dartx.spellcheck]() {
      return this.spellcheck;
    }
    set [dartx.spellcheck](value) {
      this.spellcheck = value;
    }
    get [dartx.tabIndex]() {
      return this.tabIndex;
    }
    set [dartx.tabIndex](value) {
      this.tabIndex = value;
    }
    get [dartx.title]() {
      return this.title;
    }
    set [dartx.title](value) {
      this.title = value;
    }
    get [dartx.translate]() {
      return this.translate;
    }
    set [dartx.translate](value) {
      this.translate = value;
    }
    get [dartx.dropzone]() {
      return this.webkitdropzone;
    }
    set [dartx.dropzone](value) {
      this.webkitdropzone = value;
    }
    [dartx.click]() {
      return this.click();
    }
    get [_attributes]() {
      return this.attributes;
    }
    get [dartx.className]() {
      return this.className;
    }
    set [dartx.className](value) {
      this.className = value;
    }
    get [_clientHeight]() {
      return this.clientHeight;
    }
    get [_clientLeft]() {
      return this.clientLeft;
    }
    get [_clientTop]() {
      return this.clientTop;
    }
    get [_clientWidth]() {
      return this.clientWidth;
    }
    get [dartx.id]() {
      return this.id;
    }
    set [dartx.id](value) {
      this.id = value;
    }
    get [_innerHtml]() {
      return this.innerHTML;
    }
    set [_innerHtml](value) {
      this.innerHTML = value;
    }
    get [_offsetHeight]() {
      return this.offsetHeight;
    }
    get [_offsetLeft]() {
      return this.offsetLeft;
    }
    get [dartx.offsetParent]() {
      return this.offsetParent;
    }
    get [_offsetTop]() {
      return this.offsetTop;
    }
    get [_offsetWidth]() {
      return this.offsetWidth;
    }
    get [dartx.outerHtml]() {
      return this.outerHTML;
    }
    get [_scrollHeight]() {
      return this.scrollHeight;
    }
    get [_scrollLeft]() {
      return this.scrollLeft;
    }
    set [_scrollLeft](value) {
      this.scrollLeft = value;
    }
    get [_scrollTop]() {
      return this.scrollTop;
    }
    set [_scrollTop](value) {
      this.scrollTop = value;
    }
    get [_scrollWidth]() {
      return this.scrollWidth;
    }
    get [dartx.style]() {
      return this.style;
    }
    get [dartx.tagName]() {
      return this.tagName;
    }
    [dartx.blur]() {
      return this.blur();
    }
    [dartx.focus]() {
      return this.focus();
    }
    [dartx.getAnimationPlayers]() {
      return this.getAnimationPlayers();
    }
    [dartx.getAttribute](name) {
      return this.getAttribute(name);
    }
    [dartx.getAttributeNS](namespaceURI, localName) {
      return this.getAttributeNS(namespaceURI, localName);
    }
    [dartx.getBoundingClientRect]() {
      return this.getBoundingClientRect();
    }
    [dartx.getClientRects]() {
      return this.getClientRects();
    }
    [dartx.getDestinationInsertionPoints]() {
      return this.getDestinationInsertionPoints();
    }
    [dartx.getElementsByClassName](classNames) {
      return this.getElementsByClassName(classNames);
    }
    [_getElementsByTagName](name) {
      return this.getElementsByTagName(name);
    }
    [_hasAttribute](name) {
      return this.hasAttribute(name);
    }
    [_hasAttributeNS](namespaceURI, localName) {
      return this.hasAttributeNS(namespaceURI, localName);
    }
    [_removeAttribute](name) {
      return this.removeAttribute(name);
    }
    [_removeAttributeNS](namespaceURI, localName) {
      return this.removeAttributeNS(namespaceURI, localName);
    }
    [dartx.requestFullscreen]() {
      return this.requestFullscreen();
    }
    [dartx.requestPointerLock]() {
      return this.requestPointerLock();
    }
    [_scrollIntoView](alignWithTop) {
      return this.scrollIntoView(alignWithTop);
    }
    [_scrollIntoViewIfNeeded](centerIfNeeded) {
      return this.scrollIntoViewIfNeeded(centerIfNeeded);
    }
    [dartx.setAttribute](name, value) {
      return this.setAttribute(name, value);
    }
    [dartx.setAttributeNS](namespaceURI, qualifiedName, value) {
      return this.setAttributeNS(namespaceURI, qualifiedName, value);
    }
    get [dartx.nextElementSibling]() {
      return this.nextElementSibling;
    }
    get [dartx.previousElementSibling]() {
      return this.previousElementSibling;
    }
    get [_childElementCount]() {
      return this.childElementCount;
    }
    get [_children]() {
      return this.children;
    }
    get [_firstElementChild]() {
      return this.firstElementChild;
    }
    get [_lastElementChild]() {
      return this.lastElementChild;
    }
    [dartx.querySelector](selectors) {
      return this.querySelector(selectors);
    }
    [_querySelectorAll](selectors) {
      return this.querySelectorAll(selectors);
    }
    get [dartx.onAbort]() {
      return Element.abortEvent.forElement(this);
    }
    get [dartx.onBeforeCopy]() {
      return Element.beforeCopyEvent.forElement(this);
    }
    get [dartx.onBeforeCut]() {
      return Element.beforeCutEvent.forElement(this);
    }
    get [dartx.onBeforePaste]() {
      return Element.beforePasteEvent.forElement(this);
    }
    get [dartx.onBlur]() {
      return Element.blurEvent.forElement(this);
    }
    get [dartx.onCanPlay]() {
      return Element.canPlayEvent.forElement(this);
    }
    get [dartx.onCanPlayThrough]() {
      return Element.canPlayThroughEvent.forElement(this);
    }
    get [dartx.onChange]() {
      return Element.changeEvent.forElement(this);
    }
    get [dartx.onClick]() {
      return Element.clickEvent.forElement(this);
    }
    get [dartx.onContextMenu]() {
      return Element.contextMenuEvent.forElement(this);
    }
    get [dartx.onCopy]() {
      return Element.copyEvent.forElement(this);
    }
    get [dartx.onCut]() {
      return Element.cutEvent.forElement(this);
    }
    get [dartx.onDoubleClick]() {
      return Element.doubleClickEvent.forElement(this);
    }
    get [dartx.onDrag]() {
      return Element.dragEvent.forElement(this);
    }
    get [dartx.onDragEnd]() {
      return Element.dragEndEvent.forElement(this);
    }
    get [dartx.onDragEnter]() {
      return Element.dragEnterEvent.forElement(this);
    }
    get [dartx.onDragLeave]() {
      return Element.dragLeaveEvent.forElement(this);
    }
    get [dartx.onDragOver]() {
      return Element.dragOverEvent.forElement(this);
    }
    get [dartx.onDragStart]() {
      return Element.dragStartEvent.forElement(this);
    }
    get [dartx.onDrop]() {
      return Element.dropEvent.forElement(this);
    }
    get [dartx.onDurationChange]() {
      return Element.durationChangeEvent.forElement(this);
    }
    get [dartx.onEmptied]() {
      return Element.emptiedEvent.forElement(this);
    }
    get [dartx.onEnded]() {
      return Element.endedEvent.forElement(this);
    }
    get [dartx.onError]() {
      return Element.errorEvent.forElement(this);
    }
    get [dartx.onFocus]() {
      return Element.focusEvent.forElement(this);
    }
    get [dartx.onInput]() {
      return Element.inputEvent.forElement(this);
    }
    get [dartx.onInvalid]() {
      return Element.invalidEvent.forElement(this);
    }
    get [dartx.onKeyDown]() {
      return Element.keyDownEvent.forElement(this);
    }
    get [dartx.onKeyPress]() {
      return Element.keyPressEvent.forElement(this);
    }
    get [dartx.onKeyUp]() {
      return Element.keyUpEvent.forElement(this);
    }
    get [dartx.onLoad]() {
      return Element.loadEvent.forElement(this);
    }
    get [dartx.onLoadedData]() {
      return Element.loadedDataEvent.forElement(this);
    }
    get [dartx.onLoadedMetadata]() {
      return Element.loadedMetadataEvent.forElement(this);
    }
    get [dartx.onMouseDown]() {
      return Element.mouseDownEvent.forElement(this);
    }
    get [dartx.onMouseEnter]() {
      return Element.mouseEnterEvent.forElement(this);
    }
    get [dartx.onMouseLeave]() {
      return Element.mouseLeaveEvent.forElement(this);
    }
    get [dartx.onMouseMove]() {
      return Element.mouseMoveEvent.forElement(this);
    }
    get [dartx.onMouseOut]() {
      return Element.mouseOutEvent.forElement(this);
    }
    get [dartx.onMouseOver]() {
      return Element.mouseOverEvent.forElement(this);
    }
    get [dartx.onMouseUp]() {
      return Element.mouseUpEvent.forElement(this);
    }
    get [dartx.onMouseWheel]() {
      return Element.mouseWheelEvent.forElement(this);
    }
    get [dartx.onPaste]() {
      return Element.pasteEvent.forElement(this);
    }
    get [dartx.onPause]() {
      return Element.pauseEvent.forElement(this);
    }
    get [dartx.onPlay]() {
      return Element.playEvent.forElement(this);
    }
    get [dartx.onPlaying]() {
      return Element.playingEvent.forElement(this);
    }
    get [dartx.onRateChange]() {
      return Element.rateChangeEvent.forElement(this);
    }
    get [dartx.onReset]() {
      return Element.resetEvent.forElement(this);
    }
    get [dartx.onResize]() {
      return Element.resizeEvent.forElement(this);
    }
    get [dartx.onScroll]() {
      return Element.scrollEvent.forElement(this);
    }
    get [dartx.onSearch]() {
      return Element.searchEvent.forElement(this);
    }
    get [dartx.onSeeked]() {
      return Element.seekedEvent.forElement(this);
    }
    get [dartx.onSeeking]() {
      return Element.seekingEvent.forElement(this);
    }
    get [dartx.onSelect]() {
      return Element.selectEvent.forElement(this);
    }
    get [dartx.onSelectStart]() {
      return Element.selectStartEvent.forElement(this);
    }
    get [dartx.onStalled]() {
      return Element.stalledEvent.forElement(this);
    }
    get [dartx.onSubmit]() {
      return Element.submitEvent.forElement(this);
    }
    get [dartx.onSuspend]() {
      return Element.suspendEvent.forElement(this);
    }
    get [dartx.onTimeUpdate]() {
      return Element.timeUpdateEvent.forElement(this);
    }
    get [dartx.onTouchCancel]() {
      return Element.touchCancelEvent.forElement(this);
    }
    get [dartx.onTouchEnd]() {
      return Element.touchEndEvent.forElement(this);
    }
    get [dartx.onTouchEnter]() {
      return Element.touchEnterEvent.forElement(this);
    }
    get [dartx.onTouchLeave]() {
      return Element.touchLeaveEvent.forElement(this);
    }
    get [dartx.onTouchMove]() {
      return Element.touchMoveEvent.forElement(this);
    }
    get [dartx.onTouchStart]() {
      return Element.touchStartEvent.forElement(this);
    }
    get [dartx.onTransitionEnd]() {
      return Element.transitionEndEvent.forElement(this);
    }
    get [dartx.onVolumeChange]() {
      return Element.volumeChangeEvent.forElement(this);
    }
    get [dartx.onWaiting]() {
      return Element.waitingEvent.forElement(this);
    }
    get [dartx.onFullscreenChange]() {
      return Element.fullscreenChangeEvent.forElement(this);
    }
    get [dartx.onFullscreenError]() {
      return Element.fullscreenErrorEvent.forElement(this);
    }
  }
  Element[dart.implements] = () => [GlobalEventHandlers, ParentNode, ChildNode];
  dart.defineNamedConstructor(Element, 'created');
  dart.setSignature(Element, {
    constructors: () => ({
      html: [Element, [core.String], {validator: NodeValidator, treeSanitizer: NodeTreeSanitizer}],
      created: [Element, []],
      tag: [Element, [core.String], [core.String]],
      a: [Element, []],
      article: [Element, []],
      aside: [Element, []],
      audio: [Element, []],
      br: [Element, []],
      canvas: [Element, []],
      div: [Element, []],
      footer: [Element, []],
      header: [Element, []],
      hr: [Element, []],
      iframe: [Element, []],
      img: [Element, []],
      li: [Element, []],
      nav: [Element, []],
      ol: [Element, []],
      option: [Element, []],
      p: [Element, []],
      pre: [Element, []],
      section: [Element, []],
      select: [Element, []],
      span: [Element, []],
      svg: [Element, []],
      table: [Element, []],
      td: [Element, []],
      textarea: [Element, []],
      th: [Element, []],
      tr: [Element, []],
      ul: [Element, []],
      video: [Element, []],
      _: [Element, []]
    }),
    methods: () => ({
      [dartx.querySelectorAll]: [ElementList$(Element), [core.String]],
      [dartx.query]: [Element, [core.String]],
      [dartx.queryAll]: [ElementList$(Element), [core.String]],
      [dartx.getNamespacedAttributes]: [core.Map$(core.String, core.String), [core.String]],
      [dartx.getComputedStyle]: [CssStyleDeclaration, [], [core.String]],
      [dartx.appendText]: [dart.void, [core.String]],
      [dartx.appendHtml]: [dart.void, [core.String], {validator: NodeValidator, treeSanitizer: NodeTreeSanitizer}],
      [dartx.attached]: [dart.void, []],
      [dartx.detached]: [dart.void, []],
      [dartx.enteredView]: [dart.void, []],
      [dartx.leftView]: [dart.void, []],
      [dartx.animate]: [AnimationPlayer, [core.Iterable$(core.Map$(core.String, dart.dynamic))], [dart.dynamic]],
      [_animate]: [AnimationPlayer, [core.Object], [dart.dynamic]],
      [dartx.attributeChanged]: [dart.void, [core.String, core.String, core.String]],
      [dartx.scrollIntoView]: [dart.void, [], [ScrollAlignment]],
      [dartx.insertAdjacentText]: [dart.void, [core.String, core.String]],
      [_insertAdjacentText]: [dart.void, [core.String, core.String]],
      [dartx.insertAdjacentHtml]: [dart.void, [core.String, core.String], {validator: NodeValidator, treeSanitizer: NodeTreeSanitizer}],
      [_insertAdjacentHtml]: [dart.void, [core.String, core.String]],
      [dartx.insertAdjacentElement]: [Element, [core.String, Element]],
      [_insertAdjacentElement]: [dart.void, [core.String, Element]],
      [_insertAdjacentNode]: [dart.void, [core.String, Node]],
      [dartx.matches]: [core.bool, [core.String]],
      [dartx.matchesWithAncestors]: [core.bool, [core.String]],
      [dartx.createShadowRoot]: [ShadowRoot, []],
      [dartx.offsetTo]: [math.Point, [Element]],
      [dartx.createFragment]: [DocumentFragment, [core.String], {validator: NodeValidator, treeSanitizer: NodeTreeSanitizer}],
      [dartx.setInnerHtml]: [dart.void, [core.String], {validator: NodeValidator, treeSanitizer: NodeTreeSanitizer}],
      [dartx.click]: [dart.void, []],
      [dartx.blur]: [dart.void, []],
      [dartx.focus]: [dart.void, []],
      [dartx.getAnimationPlayers]: [core.List$(AnimationPlayer), []],
      [dartx.getAttribute]: [core.String, [core.String]],
      [dartx.getAttributeNS]: [core.String, [core.String, core.String]],
      [dartx.getBoundingClientRect]: [math.Rectangle, []],
      [dartx.getClientRects]: [core.List$(math.Rectangle), []],
      [dartx.getDestinationInsertionPoints]: [core.List$(Node), []],
      [dartx.getElementsByClassName]: [core.List$(Node), [core.String]],
      [_getElementsByTagName]: [core.List$(Node), [core.String]],
      [_hasAttribute]: [core.bool, [core.String]],
      [_hasAttributeNS]: [core.bool, [core.String, core.String]],
      [_removeAttribute]: [dart.void, [core.String]],
      [_removeAttributeNS]: [dart.void, [core.String, core.String]],
      [dartx.requestFullscreen]: [dart.void, []],
      [dartx.requestPointerLock]: [dart.void, []],
      [_scrollIntoView]: [dart.void, [], [core.bool]],
      [_scrollIntoViewIfNeeded]: [dart.void, [], [core.bool]],
      [dartx.setAttribute]: [dart.void, [core.String, core.String]],
      [dartx.setAttributeNS]: [dart.void, [core.String, core.String, core.String]],
      [dartx.querySelector]: [Element, [core.String]],
      [_querySelectorAll]: [core.List$(Node), [core.String]]
    }),
    statics: () => ({
      isTagSupported: [core.bool, [core.String]],
      _determineMouseWheelEventType: [core.String, [EventTarget]],
      _determineTransitionEventType: [core.String, [EventTarget]],
      _offsetToHelper: [math.Point, [Element, Element]],
      _hasCorruptedAttributes: [core.bool, [Element]],
      _hasCorruptedAttributesAdditionalCheck: [core.bool, [Element]],
      _safeTagName: [core.String, [dart.dynamic]]
    }),
    names: ['isTagSupported', '_determineMouseWheelEventType', '_determineTransitionEventType', '_offsetToHelper', '_hasCorruptedAttributes', '_hasCorruptedAttributesAdditionalCheck', '_safeTagName']
  });
  Element[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('Element')), dart.const(new _js_helper.Native("Element"))];
  Element._parseDocument = null;
  Element._parseRange = null;
  Element._defaultValidator = null;
  Element._defaultSanitizer = null;
  Element._tagsForWhichCreateContextualFragmentIsNotSupported = dart.const(dart.list(['HEAD', 'AREA', 'BASE', 'BASEFONT', 'BR', 'COL', 'COLGROUP', 'EMBED', 'FRAME', 'FRAMESET', 'HR', 'IMAGE', 'IMG', 'INPUT', 'ISINDEX', 'LINK', 'META', 'PARAM', 'SOURCE', 'STYLE', 'TITLE', 'WBR'], core.String));
  dart.defineLazyProperties(Element, {
    get mouseWheelEvent() {
      return dart.const(new (_CustomEventStreamProvider$(WheelEvent))(Element._determineMouseWheelEventType));
    },
    get transitionEndEvent() {
      return dart.const(new (_CustomEventStreamProvider$(TransitionEvent))(Element._determineTransitionEventType));
    },
    get abortEvent() {
      return dart.const(new (EventStreamProvider$(Event))('abort'));
    },
    get beforeCopyEvent() {
      return dart.const(new (EventStreamProvider$(Event))('beforecopy'));
    },
    get beforeCutEvent() {
      return dart.const(new (EventStreamProvider$(Event))('beforecut'));
    },
    get beforePasteEvent() {
      return dart.const(new (EventStreamProvider$(Event))('beforepaste'));
    },
    get blurEvent() {
      return dart.const(new (EventStreamProvider$(Event))('blur'));
    },
    get canPlayEvent() {
      return dart.const(new (EventStreamProvider$(Event))('canplay'));
    },
    get canPlayThroughEvent() {
      return dart.const(new (EventStreamProvider$(Event))('canplaythrough'));
    },
    get changeEvent() {
      return dart.const(new (EventStreamProvider$(Event))('change'));
    },
    get clickEvent() {
      return dart.const(new (EventStreamProvider$(MouseEvent))('click'));
    },
    get contextMenuEvent() {
      return dart.const(new (EventStreamProvider$(MouseEvent))('contextmenu'));
    },
    get copyEvent() {
      return dart.const(new (EventStreamProvider$(Event))('copy'));
    },
    get cutEvent() {
      return dart.const(new (EventStreamProvider$(Event))('cut'));
    },
    get doubleClickEvent() {
      return dart.const(new (EventStreamProvider$(Event))('dblclick'));
    },
    get dragEvent() {
      return dart.const(new (EventStreamProvider$(MouseEvent))('drag'));
    },
    get dragEndEvent() {
      return dart.const(new (EventStreamProvider$(MouseEvent))('dragend'));
    },
    get dragEnterEvent() {
      return dart.const(new (EventStreamProvider$(MouseEvent))('dragenter'));
    },
    get dragLeaveEvent() {
      return dart.const(new (EventStreamProvider$(MouseEvent))('dragleave'));
    },
    get dragOverEvent() {
      return dart.const(new (EventStreamProvider$(MouseEvent))('dragover'));
    },
    get dragStartEvent() {
      return dart.const(new (EventStreamProvider$(MouseEvent))('dragstart'));
    },
    get dropEvent() {
      return dart.const(new (EventStreamProvider$(MouseEvent))('drop'));
    },
    get durationChangeEvent() {
      return dart.const(new (EventStreamProvider$(Event))('durationchange'));
    },
    get emptiedEvent() {
      return dart.const(new (EventStreamProvider$(Event))('emptied'));
    },
    get endedEvent() {
      return dart.const(new (EventStreamProvider$(Event))('ended'));
    },
    get errorEvent() {
      return dart.const(new (EventStreamProvider$(Event))('error'));
    },
    get focusEvent() {
      return dart.const(new (EventStreamProvider$(Event))('focus'));
    },
    get inputEvent() {
      return dart.const(new (EventStreamProvider$(Event))('input'));
    },
    get invalidEvent() {
      return dart.const(new (EventStreamProvider$(Event))('invalid'));
    },
    get keyDownEvent() {
      return dart.const(new (EventStreamProvider$(KeyboardEvent))('keydown'));
    },
    get keyPressEvent() {
      return dart.const(new (EventStreamProvider$(KeyboardEvent))('keypress'));
    },
    get keyUpEvent() {
      return dart.const(new (EventStreamProvider$(KeyboardEvent))('keyup'));
    },
    get loadEvent() {
      return dart.const(new (EventStreamProvider$(Event))('load'));
    },
    get loadedDataEvent() {
      return dart.const(new (EventStreamProvider$(Event))('loadeddata'));
    },
    get loadedMetadataEvent() {
      return dart.const(new (EventStreamProvider$(Event))('loadedmetadata'));
    },
    get mouseDownEvent() {
      return dart.const(new (EventStreamProvider$(MouseEvent))('mousedown'));
    },
    get mouseEnterEvent() {
      return dart.const(new (EventStreamProvider$(MouseEvent))('mouseenter'));
    },
    get mouseLeaveEvent() {
      return dart.const(new (EventStreamProvider$(MouseEvent))('mouseleave'));
    },
    get mouseMoveEvent() {
      return dart.const(new (EventStreamProvider$(MouseEvent))('mousemove'));
    },
    get mouseOutEvent() {
      return dart.const(new (EventStreamProvider$(MouseEvent))('mouseout'));
    },
    get mouseOverEvent() {
      return dart.const(new (EventStreamProvider$(MouseEvent))('mouseover'));
    },
    get mouseUpEvent() {
      return dart.const(new (EventStreamProvider$(MouseEvent))('mouseup'));
    },
    get pasteEvent() {
      return dart.const(new (EventStreamProvider$(Event))('paste'));
    },
    get pauseEvent() {
      return dart.const(new (EventStreamProvider$(Event))('pause'));
    },
    get playEvent() {
      return dart.const(new (EventStreamProvider$(Event))('play'));
    },
    get playingEvent() {
      return dart.const(new (EventStreamProvider$(Event))('playing'));
    },
    get rateChangeEvent() {
      return dart.const(new (EventStreamProvider$(Event))('ratechange'));
    },
    get resetEvent() {
      return dart.const(new (EventStreamProvider$(Event))('reset'));
    },
    get resizeEvent() {
      return dart.const(new (EventStreamProvider$(Event))('resize'));
    },
    get scrollEvent() {
      return dart.const(new (EventStreamProvider$(Event))('scroll'));
    },
    get searchEvent() {
      return dart.const(new (EventStreamProvider$(Event))('search'));
    },
    get seekedEvent() {
      return dart.const(new (EventStreamProvider$(Event))('seeked'));
    },
    get seekingEvent() {
      return dart.const(new (EventStreamProvider$(Event))('seeking'));
    },
    get selectEvent() {
      return dart.const(new (EventStreamProvider$(Event))('select'));
    },
    get selectStartEvent() {
      return dart.const(new (EventStreamProvider$(Event))('selectstart'));
    },
    get stalledEvent() {
      return dart.const(new (EventStreamProvider$(Event))('stalled'));
    },
    get submitEvent() {
      return dart.const(new (EventStreamProvider$(Event))('submit'));
    },
    get suspendEvent() {
      return dart.const(new (EventStreamProvider$(Event))('suspend'));
    },
    get timeUpdateEvent() {
      return dart.const(new (EventStreamProvider$(Event))('timeupdate'));
    },
    get touchCancelEvent() {
      return dart.const(new (EventStreamProvider$(TouchEvent))('touchcancel'));
    },
    get touchEndEvent() {
      return dart.const(new (EventStreamProvider$(TouchEvent))('touchend'));
    },
    get touchEnterEvent() {
      return dart.const(new (EventStreamProvider$(TouchEvent))('touchenter'));
    },
    get touchLeaveEvent() {
      return dart.const(new (EventStreamProvider$(TouchEvent))('touchleave'));
    },
    get touchMoveEvent() {
      return dart.const(new (EventStreamProvider$(TouchEvent))('touchmove'));
    },
    get touchStartEvent() {
      return dart.const(new (EventStreamProvider$(TouchEvent))('touchstart'));
    },
    get volumeChangeEvent() {
      return dart.const(new (EventStreamProvider$(Event))('volumechange'));
    },
    get waitingEvent() {
      return dart.const(new (EventStreamProvider$(Event))('waiting'));
    },
    get fullscreenChangeEvent() {
      return dart.const(new (EventStreamProvider$(Event))('webkitfullscreenchange'));
    },
    get fullscreenErrorEvent() {
      return dart.const(new (EventStreamProvider$(Event))('webkitfullscreenerror'));
    }
  });
  dart.registerExtension(dart.global.Element, Element);
  class HtmlElement extends Element {
    static new() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    created() {
      super.created();
    }
  }
  dart.defineNamedConstructor(HtmlElement, 'created');
  dart.setSignature(HtmlElement, {
    constructors: () => ({
      new: [HtmlElement, []],
      created: [HtmlElement, []]
    })
  });
  HtmlElement[dart.metadata] = () => [dart.const(new _js_helper.Native("HTMLElement"))];
  dart.registerExtension(dart.global.HTMLElement, HtmlElement);
  class _EntryArray extends core.Object {}
  _EntryArray[dart.implements] = () => [core.List$(Entry)];
  _EntryArray[dart.metadata] = () => [dart.const(new _js_helper.Native("EntryArray"))];
  dart.registerExtension(dart.global.EntryArray, _EntryArray);
  function spawnDomUri(uri, args, message) {
    dart.throw(new core.UnimplementedError());
  }
  dart.fn(spawnDomUri, async.Future$(isolate.Isolate), [core.Uri, core.List$(core.String), dart.dynamic]);
  function unwrap_jso(dartClass_instance) {
    return dartClass_instance;
  }
  dart.fn(unwrap_jso);
  function wrap_jso(jsObject) {
    return jsObject;
  }
  dart.fn(wrap_jso);
  function createCustomUpgrader(customElementClass, $this) {
    return $this;
  }
  dart.fn(createCustomUpgrader, dart.dynamic, [core.Type, dart.dynamic]);
  dart.defineExtensionNames([
    'onError'
  ]);
  class AbstractWorker extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.onError]() {
      return AbstractWorker.errorEvent.forTarget(this);
    }
  }
  AbstractWorker[dart.implements] = () => [EventTarget];
  dart.setSignature(AbstractWorker, {
    constructors: () => ({_: [AbstractWorker, []]})
  });
  AbstractWorker[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('AbstractWorker'))];
  dart.defineLazyProperties(AbstractWorker, {
    get errorEvent() {
      return dart.const(new (EventStreamProvider$(ErrorEvent))('error'));
    }
  });
  dart.defineExtensionNames([
    'toString',
    'download',
    'hreflang',
    'integrity',
    'rel',
    'target',
    'type',
    'hash',
    'host',
    'hostname',
    'href',
    'origin',
    'password',
    'pathname',
    'port',
    'protocol',
    'search',
    'username'
  ]);
  class AnchorElement extends HtmlElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new(opts) {
      let href = opts && 'href' in opts ? opts.href : null;
      let e = exports.document[dartx.createElement]("a");
      if (href != null) dart.dput(e, 'href', href);
      return dart.as(e, AnchorElement);
    }
    created() {
      this[dartx.download] = null;
      this[dartx.hreflang] = null;
      this[dartx.integrity] = null;
      this[dartx.rel] = null;
      this[dartx.target] = null;
      this[dartx.type] = null;
      this[dartx.hash] = null;
      this[dartx.host] = null;
      this[dartx.hostname] = null;
      this[dartx.href] = null;
      this[dartx.origin] = null;
      this[dartx.password] = null;
      this[dartx.pathname] = null;
      this[dartx.port] = null;
      this[dartx.protocol] = null;
      this[dartx.search] = null;
      this[dartx.username] = null;
      super.created();
    }
    get [dartx.download]() {
      return this.download;
    }
    set [dartx.download](value) {
      this.download = value;
    }
    get [dartx.hreflang]() {
      return this.hreflang;
    }
    set [dartx.hreflang](value) {
      this.hreflang = value;
    }
    get [dartx.integrity]() {
      return this.integrity;
    }
    set [dartx.integrity](value) {
      this.integrity = value;
    }
    get [dartx.rel]() {
      return this.rel;
    }
    set [dartx.rel](value) {
      this.rel = value;
    }
    get [dartx.target]() {
      return this.target;
    }
    set [dartx.target](value) {
      this.target = value;
    }
    get [dartx.type]() {
      return this.type;
    }
    set [dartx.type](value) {
      this.type = value;
    }
    get [dartx.hash]() {
      return this.hash;
    }
    set [dartx.hash](value) {
      this.hash = value;
    }
    get [dartx.host]() {
      return this.host;
    }
    set [dartx.host](value) {
      this.host = value;
    }
    get [dartx.hostname]() {
      return this.hostname;
    }
    set [dartx.hostname](value) {
      this.hostname = value;
    }
    get [dartx.href]() {
      return this.href;
    }
    set [dartx.href](value) {
      this.href = value;
    }
    get [dartx.origin]() {
      return this.origin;
    }
    get [dartx.password]() {
      return this.password;
    }
    set [dartx.password](value) {
      this.password = value;
    }
    get [dartx.pathname]() {
      return this.pathname;
    }
    set [dartx.pathname](value) {
      this.pathname = value;
    }
    get [dartx.port]() {
      return this.port;
    }
    set [dartx.port](value) {
      this.port = value;
    }
    get [dartx.protocol]() {
      return this.protocol;
    }
    set [dartx.protocol](value) {
      this.protocol = value;
    }
    get [dartx.search]() {
      return this.search;
    }
    set [dartx.search](value) {
      this.search = value;
    }
    get [dartx.username]() {
      return this.username;
    }
    set [dartx.username](value) {
      this.username = value;
    }
    toString() {
      return String(this);
    }
  }
  AnchorElement[dart.implements] = () => [UrlUtils];
  dart.defineNamedConstructor(AnchorElement, 'created');
  dart.setSignature(AnchorElement, {
    constructors: () => ({
      _: [AnchorElement, []],
      new: [AnchorElement, [], {href: core.String}],
      created: [AnchorElement, []]
    })
  });
  AnchorElement[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('HTMLAnchorElement')), dart.const(new _js_helper.Native("HTMLAnchorElement"))];
  dart.registerExtension(dart.global.HTMLAnchorElement, AnchorElement);
  dart.defineExtensionNames([
    'activeDuration',
    'currentIteration',
    'duration',
    'endTime',
    'localTime',
    'player',
    'startTime',
    'timing'
  ]);
  class AnimationNode extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.activeDuration]() {
      return this.activeDuration;
    }
    get [dartx.currentIteration]() {
      return this.currentIteration;
    }
    get [dartx.duration]() {
      return this.duration;
    }
    get [dartx.endTime]() {
      return this.endTime;
    }
    get [dartx.localTime]() {
      return this.localTime;
    }
    get [dartx.player]() {
      return this.player;
    }
    get [dartx.startTime]() {
      return this.startTime;
    }
    get [dartx.timing]() {
      return this.timing;
    }
  }
  dart.setSignature(AnimationNode, {
    constructors: () => ({_: [AnimationNode, []]})
  });
  AnimationNode[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('AnimationNode')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("AnimationNode"))];
  dart.registerExtension(dart.global.AnimationNode, AnimationNode);
  class Animation extends AnimationNode {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new(target, keyframes, timingInput) {
      if (timingInput === void 0) timingInput = null;
      if ((dart.is(keyframes, core.List$(core.Map)) || keyframes == null) && (dart.is(target, Element) || target == null) && timingInput == null) {
        return Animation._create_1(target, keyframes);
      }
      if ((typeof timingInput == 'number' || timingInput == null) && (dart.is(keyframes, core.List$(core.Map)) || keyframes == null) && (dart.is(target, Element) || target == null)) {
        return Animation._create_2(target, keyframes, timingInput);
      }
      if ((dart.is(timingInput, core.Map) || timingInput == null) && (dart.is(keyframes, core.List$(core.Map)) || keyframes == null) && (dart.is(target, Element) || target == null)) {
        let timingInput_1 = html_common.convertDartToNative_Dictionary(dart.as(timingInput, core.Map));
        return Animation._create_3(target, keyframes, timingInput_1);
      }
      dart.throw(new core.ArgumentError("Incorrect number or type of arguments"));
    }
    static _create_1(target, keyframes) {
      return dart.as(new Animation(target, keyframes), Animation);
    }
    static _create_2(target, keyframes, timingInput) {
      return dart.as(new Animation(target, keyframes, timingInput), Animation);
    }
    static _create_3(target, keyframes, timingInput) {
      return dart.as(new Animation(target, keyframes, timingInput), Animation);
    }
  }
  dart.setSignature(Animation, {
    constructors: () => ({
      _: [Animation, []],
      new: [Animation, [Element, core.List$(core.Map)], [dart.dynamic]]
    }),
    statics: () => ({
      _create_1: [Animation, [dart.dynamic, dart.dynamic]],
      _create_2: [Animation, [dart.dynamic, dart.dynamic, dart.dynamic]],
      _create_3: [Animation, [dart.dynamic, dart.dynamic, dart.dynamic]]
    }),
    names: ['_create_1', '_create_2', '_create_3']
  });
  Animation[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('Animation')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("Animation"))];
  dart.registerExtension(dart.global.Animation, Animation);
  class AnimationEffect extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
  }
  dart.setSignature(AnimationEffect, {
    constructors: () => ({_: [AnimationEffect, []]})
  });
  AnimationEffect[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('AnimationEffect')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("AnimationEffect"))];
  dart.registerExtension(dart.global.AnimationEffect, AnimationEffect);
  const _createEvent = Symbol('_createEvent');
  const _initEvent = Symbol('_initEvent');
  const _selector = Symbol('_selector');
  const _get_currentTarget = Symbol('_get_currentTarget');
  const _get_target = Symbol('_get_target');
  dart.defineExtensionNames([
    'matchingTarget',
    'currentTarget',
    'target',
    'preventDefault',
    'stopImmediatePropagation',
    'stopPropagation',
    'bubbles',
    'cancelable',
    'clipboardData',
    'defaultPrevented',
    'eventPhase',
    'path',
    'timeStamp',
    'type'
  ]);
  class Event extends _interceptors.Interceptor {
    static new(type, opts) {
      let canBubble = opts && 'canBubble' in opts ? opts.canBubble : true;
      let cancelable = opts && 'cancelable' in opts ? opts.cancelable : true;
      return Event.eventType('Event', type, {canBubble: canBubble, cancelable: cancelable});
    }
    static eventType(type, name, opts) {
      let canBubble = opts && 'canBubble' in opts ? opts.canBubble : true;
      let cancelable = opts && 'cancelable' in opts ? opts.cancelable : true;
      let e = exports.document[_createEvent](type);
      e[_initEvent](name, canBubble, cancelable);
      return e;
    }
    get [_selector]() {
      return this._selector;
    }
    set [_selector](value) {
      this._selector = value;
    }
    get [dartx.matchingTarget]() {
      if (this[_selector] == null) {
        dart.throw(new core.UnsupportedError('Cannot call matchingTarget if this Event did' + ' not arise as a result of event delegation.'));
      }
      let currentTarget = this[dartx.currentTarget];
      let target = this[dartx.target];
      let matchedTarget = null;
      do {
        if (dart.notNull(dart.as(dart.dcall(target[dartx.matches], this[_selector]), core.bool))) return dart.as(target, Element);
        target = dart.as(dart.dload(target, dartx.parent), EventTarget);
      } while (target != null && !dart.equals(target, dart.dload(currentTarget, dartx.parent)));
      dart.throw(new core.StateError('No selector matched for populating matchedTarget.'));
    }
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.bubbles]() {
      return this.bubbles;
    }
    get [dartx.cancelable]() {
      return this.cancelable;
    }
    get [dartx.clipboardData]() {
      return this.clipboardData;
    }
    get [dartx.currentTarget]() {
      return _convertNativeToDart_EventTarget(this[_get_currentTarget]);
    }
    get [_get_currentTarget]() {
      return this.currentTarget;
    }
    get [dartx.defaultPrevented]() {
      return this.defaultPrevented;
    }
    get [dartx.eventPhase]() {
      return this.eventPhase;
    }
    get [dartx.path]() {
      return this.path;
    }
    get [dartx.target]() {
      return _convertNativeToDart_EventTarget(this[_get_target]);
    }
    get [_get_target]() {
      return this.target;
    }
    get [dartx.timeStamp]() {
      return this.timeStamp;
    }
    get [dartx.type]() {
      return this.type;
    }
    [_initEvent](eventTypeArg, canBubbleArg, cancelableArg) {
      return this.initEvent(eventTypeArg, canBubbleArg, cancelableArg);
    }
    [dartx.preventDefault]() {
      return this.preventDefault();
    }
    [dartx.stopImmediatePropagation]() {
      return this.stopImmediatePropagation();
    }
    [dartx.stopPropagation]() {
      return this.stopPropagation();
    }
  }
  dart.setSignature(Event, {
    constructors: () => ({
      new: [Event, [core.String], {canBubble: core.bool, cancelable: core.bool}],
      eventType: [Event, [core.String, core.String], {canBubble: core.bool, cancelable: core.bool}],
      _: [Event, []]
    }),
    methods: () => ({
      [_initEvent]: [dart.void, [core.String, core.bool, core.bool]],
      [dartx.preventDefault]: [dart.void, []],
      [dartx.stopImmediatePropagation]: [dart.void, []],
      [dartx.stopPropagation]: [dart.void, []]
    })
  });
  Event[dart.metadata] = () => [dart.const(new _metadata.DomName('Event')), dart.const(new _js_helper.Native("Event,InputEvent,ClipboardEvent"))];
  Event.AT_TARGET = 2;
  Event.BUBBLING_PHASE = 3;
  Event.CAPTURING_PHASE = 1;
  dart.registerExtension(dart.global.Event, Event);
  dart.defineExtensionNames([
    'animationName',
    'elapsedTime'
  ]);
  class AnimationEvent extends Event {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.animationName]() {
      return this.animationName;
    }
    get [dartx.elapsedTime]() {
      return this.elapsedTime;
    }
  }
  dart.setSignature(AnimationEvent, {
    constructors: () => ({_: [AnimationEvent, []]})
  });
  AnimationEvent[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('WebKitAnimationEvent')), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.CHROME)), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.SAFARI)), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("WebKitAnimationEvent"))];
  dart.registerExtension(dart.global.WebKitAnimationEvent, AnimationEvent);
  dart.defineExtensionNames([
    'cancel',
    'finish',
    'pause',
    'play',
    'reverse',
    'currentTime',
    'playState',
    'playbackRate',
    'source',
    'startTime'
  ]);
  class AnimationPlayer extends EventTarget {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static get supported() {
      return !!document.body.animate;
    }
    get [dartx.currentTime]() {
      return this.currentTime;
    }
    set [dartx.currentTime](value) {
      this.currentTime = value;
    }
    get [dartx.playState]() {
      return this.playState;
    }
    get [dartx.playbackRate]() {
      return this.playbackRate;
    }
    set [dartx.playbackRate](value) {
      this.playbackRate = value;
    }
    get [dartx.source]() {
      return this.source;
    }
    set [dartx.source](value) {
      this.source = value;
    }
    get [dartx.startTime]() {
      return this.startTime;
    }
    set [dartx.startTime](value) {
      this.startTime = value;
    }
    [dartx.cancel]() {
      return this.cancel();
    }
    [dartx.finish]() {
      return this.finish();
    }
    [dartx.pause]() {
      return this.pause();
    }
    [dartx.play]() {
      return this.play();
    }
    [dartx.reverse]() {
      return this.reverse();
    }
  }
  dart.setSignature(AnimationPlayer, {
    constructors: () => ({_: [AnimationPlayer, []]}),
    methods: () => ({
      [dartx.cancel]: [dart.void, []],
      [dartx.finish]: [dart.void, []],
      [dartx.pause]: [dart.void, []],
      [dartx.play]: [dart.void, []],
      [dartx.reverse]: [dart.void, []]
    })
  });
  AnimationPlayer[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('AnimationPlayer')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("AnimationPlayer"))];
  dart.registerExtension(dart.global.AnimationPlayer, AnimationPlayer);
  dart.defineExtensionNames([
    'currentTime',
    'timelineTime'
  ]);
  class AnimationPlayerEvent extends Event {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.currentTime]() {
      return this.currentTime;
    }
    get [dartx.timelineTime]() {
      return this.timelineTime;
    }
  }
  dart.setSignature(AnimationPlayerEvent, {
    constructors: () => ({_: [AnimationPlayerEvent, []]})
  });
  AnimationPlayerEvent[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('AnimationPlayerEvent')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("AnimationPlayerEvent"))];
  dart.registerExtension(dart.global.AnimationPlayerEvent, AnimationPlayerEvent);
  dart.defineExtensionNames([
    'getAnimationPlayers',
    'play',
    'currentTime'
  ]);
  class AnimationTimeline extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.currentTime]() {
      return this.currentTime;
    }
    [dartx.getAnimationPlayers]() {
      return this.getAnimationPlayers();
    }
    [dartx.play](source) {
      return this.play(source);
    }
  }
  dart.setSignature(AnimationTimeline, {
    constructors: () => ({_: [AnimationTimeline, []]}),
    methods: () => ({
      [dartx.getAnimationPlayers]: [core.List$(AnimationPlayer), []],
      [dartx.play]: [AnimationPlayer, [AnimationNode]]
    })
  });
  AnimationTimeline[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('AnimationTimeline')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("AnimationTimeline"))];
  dart.registerExtension(dart.global.AnimationTimeline, AnimationTimeline);
  dart.defineExtensionNames([
    'abort',
    'swapCache',
    'update',
    'onCached',
    'onChecking',
    'onDownloading',
    'onError',
    'onNoUpdate',
    'onObsolete',
    'onProgress',
    'onUpdateReady',
    'status'
  ]);
  class ApplicationCache extends EventTarget {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static get supported() {
      return !!window.applicationCache;
    }
    get [dartx.status]() {
      return this.status;
    }
    [dartx.abort]() {
      return this.abort();
    }
    [dartx.swapCache]() {
      return this.swapCache();
    }
    [dartx.update]() {
      return this.update();
    }
    get [dartx.onCached]() {
      return ApplicationCache.cachedEvent.forTarget(this);
    }
    get [dartx.onChecking]() {
      return ApplicationCache.checkingEvent.forTarget(this);
    }
    get [dartx.onDownloading]() {
      return ApplicationCache.downloadingEvent.forTarget(this);
    }
    get [dartx.onError]() {
      return ApplicationCache.errorEvent.forTarget(this);
    }
    get [dartx.onNoUpdate]() {
      return ApplicationCache.noUpdateEvent.forTarget(this);
    }
    get [dartx.onObsolete]() {
      return ApplicationCache.obsoleteEvent.forTarget(this);
    }
    get [dartx.onProgress]() {
      return ApplicationCache.progressEvent.forTarget(this);
    }
    get [dartx.onUpdateReady]() {
      return ApplicationCache.updateReadyEvent.forTarget(this);
    }
  }
  dart.setSignature(ApplicationCache, {
    constructors: () => ({_: [ApplicationCache, []]}),
    methods: () => ({
      [dartx.abort]: [dart.void, []],
      [dartx.swapCache]: [dart.void, []],
      [dartx.update]: [dart.void, []]
    })
  });
  ApplicationCache[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('ApplicationCache')), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.CHROME)), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.FIREFOX)), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.IE, '10')), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.OPERA)), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.SAFARI)), dart.const(new _metadata.Unstable()), dart.const(new _js_helper.Native("ApplicationCache,DOMApplicationCache,OfflineResourceList"))];
  ApplicationCache.CHECKING = 2;
  ApplicationCache.DOWNLOADING = 3;
  ApplicationCache.IDLE = 1;
  ApplicationCache.OBSOLETE = 5;
  ApplicationCache.UNCACHED = 0;
  ApplicationCache.UPDATEREADY = 4;
  dart.defineLazyProperties(ApplicationCache, {
    get cachedEvent() {
      return dart.const(new (EventStreamProvider$(Event))('cached'));
    },
    get checkingEvent() {
      return dart.const(new (EventStreamProvider$(Event))('checking'));
    },
    get downloadingEvent() {
      return dart.const(new (EventStreamProvider$(Event))('downloading'));
    },
    get errorEvent() {
      return dart.const(new (EventStreamProvider$(Event))('error'));
    },
    get noUpdateEvent() {
      return dart.const(new (EventStreamProvider$(Event))('noupdate'));
    },
    get obsoleteEvent() {
      return dart.const(new (EventStreamProvider$(Event))('obsolete'));
    },
    get progressEvent() {
      return dart.const(new (EventStreamProvider$(ProgressEvent))('progress'));
    },
    get updateReadyEvent() {
      return dart.const(new (EventStreamProvider$(Event))('updateready'));
    }
  });
  dart.registerExtension(dart.global.ApplicationCache, ApplicationCache);
  dart.defineExtensionNames([
    'message',
    'reason',
    'status',
    'url'
  ]);
  class ApplicationCacheErrorEvent extends Event {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.message]() {
      return this.message;
    }
    get [dartx.reason]() {
      return this.reason;
    }
    get [dartx.status]() {
      return this.status;
    }
    get [dartx.url]() {
      return this.url;
    }
  }
  dart.setSignature(ApplicationCacheErrorEvent, {
    constructors: () => ({_: [ApplicationCacheErrorEvent, []]})
  });
  ApplicationCacheErrorEvent[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('ApplicationCacheErrorEvent')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("ApplicationCacheErrorEvent"))];
  dart.registerExtension(dart.global.ApplicationCacheErrorEvent, ApplicationCacheErrorEvent);
  dart.defineExtensionNames([
    'toString',
    'alt',
    'coords',
    'shape',
    'target',
    'hash',
    'host',
    'hostname',
    'href',
    'origin',
    'password',
    'pathname',
    'port',
    'protocol',
    'search',
    'username'
  ]);
  class AreaElement extends HtmlElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return dart.as(exports.document[dartx.createElement]("area"), AreaElement);
    }
    created() {
      this[dartx.alt] = null;
      this[dartx.coords] = null;
      this[dartx.shape] = null;
      this[dartx.target] = null;
      this[dartx.hash] = null;
      this[dartx.host] = null;
      this[dartx.hostname] = null;
      this[dartx.href] = null;
      this[dartx.origin] = null;
      this[dartx.password] = null;
      this[dartx.pathname] = null;
      this[dartx.port] = null;
      this[dartx.protocol] = null;
      this[dartx.search] = null;
      this[dartx.username] = null;
      super.created();
    }
    get [dartx.alt]() {
      return this.alt;
    }
    set [dartx.alt](value) {
      this.alt = value;
    }
    get [dartx.coords]() {
      return this.coords;
    }
    set [dartx.coords](value) {
      this.coords = value;
    }
    get [dartx.shape]() {
      return this.shape;
    }
    set [dartx.shape](value) {
      this.shape = value;
    }
    get [dartx.target]() {
      return this.target;
    }
    set [dartx.target](value) {
      this.target = value;
    }
    get [dartx.hash]() {
      return this.hash;
    }
    set [dartx.hash](value) {
      this.hash = value;
    }
    get [dartx.host]() {
      return this.host;
    }
    set [dartx.host](value) {
      this.host = value;
    }
    get [dartx.hostname]() {
      return this.hostname;
    }
    set [dartx.hostname](value) {
      this.hostname = value;
    }
    get [dartx.href]() {
      return this.href;
    }
    set [dartx.href](value) {
      this.href = value;
    }
    get [dartx.origin]() {
      return this.origin;
    }
    get [dartx.password]() {
      return this.password;
    }
    set [dartx.password](value) {
      this.password = value;
    }
    get [dartx.pathname]() {
      return this.pathname;
    }
    set [dartx.pathname](value) {
      this.pathname = value;
    }
    get [dartx.port]() {
      return this.port;
    }
    set [dartx.port](value) {
      this.port = value;
    }
    get [dartx.protocol]() {
      return this.protocol;
    }
    set [dartx.protocol](value) {
      this.protocol = value;
    }
    get [dartx.search]() {
      return this.search;
    }
    set [dartx.search](value) {
      this.search = value;
    }
    get [dartx.username]() {
      return this.username;
    }
    set [dartx.username](value) {
      this.username = value;
    }
    toString() {
      return String(this);
    }
  }
  AreaElement[dart.implements] = () => [UrlUtils];
  dart.defineNamedConstructor(AreaElement, 'created');
  dart.setSignature(AreaElement, {
    constructors: () => ({
      _: [AreaElement, []],
      new: [AreaElement, []],
      created: [AreaElement, []]
    })
  });
  AreaElement[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('HTMLAreaElement')), dart.const(new _js_helper.Native("HTMLAreaElement"))];
  dart.registerExtension(dart.global.HTMLAreaElement, AreaElement);
  dart.defineExtensionNames([
    'addTextTrack',
    'canPlayType',
    'load',
    'pause',
    'play',
    'setMediaKeys',
    'addKey',
    'cancelKeyRequest',
    'generateKeyRequest',
    'onKeyAdded',
    'onKeyError',
    'onKeyMessage',
    'onNeedKey',
    'audioTracks',
    'autoplay',
    'buffered',
    'controller',
    'controls',
    'crossOrigin',
    'currentSrc',
    'currentTime',
    'defaultMuted',
    'defaultPlaybackRate',
    'duration',
    'ended',
    'error',
    'integrity',
    'loop',
    'mediaGroup',
    'mediaKeys',
    'muted',
    'networkState',
    'paused',
    'playbackRate',
    'played',
    'preload',
    'readyState',
    'seekable',
    'seeking',
    'src',
    'textTracks',
    'videoTracks',
    'volume',
    'audioDecodedByteCount',
    'videoDecodedByteCount'
  ]);
  class MediaElement extends HtmlElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    created() {
      this[dartx.audioTracks] = null;
      this[dartx.autoplay] = null;
      this[dartx.buffered] = null;
      this[dartx.controller] = null;
      this[dartx.controls] = null;
      this[dartx.crossOrigin] = null;
      this[dartx.currentSrc] = null;
      this[dartx.currentTime] = null;
      this[dartx.defaultMuted] = null;
      this[dartx.defaultPlaybackRate] = null;
      this[dartx.duration] = null;
      this[dartx.ended] = null;
      this[dartx.error] = null;
      this[dartx.integrity] = null;
      this[dartx.loop] = null;
      this[dartx.mediaGroup] = null;
      this[dartx.mediaKeys] = null;
      this[dartx.muted] = null;
      this[dartx.networkState] = null;
      this[dartx.paused] = null;
      this[dartx.playbackRate] = null;
      this[dartx.played] = null;
      this[dartx.preload] = null;
      this[dartx.readyState] = null;
      this[dartx.seekable] = null;
      this[dartx.seeking] = null;
      this[dartx.src] = null;
      this[dartx.textTracks] = null;
      this[dartx.videoTracks] = null;
      this[dartx.volume] = null;
      this[dartx.audioDecodedByteCount] = null;
      this[dartx.videoDecodedByteCount] = null;
      super.created();
    }
    get [dartx.audioTracks]() {
      return this.audioTracks;
    }
    get [dartx.autoplay]() {
      return this.autoplay;
    }
    set [dartx.autoplay](value) {
      this.autoplay = value;
    }
    get [dartx.buffered]() {
      return this.buffered;
    }
    get [dartx.controller]() {
      return this.controller;
    }
    set [dartx.controller](value) {
      this.controller = value;
    }
    get [dartx.controls]() {
      return this.controls;
    }
    set [dartx.controls](value) {
      this.controls = value;
    }
    get [dartx.crossOrigin]() {
      return this.crossOrigin;
    }
    set [dartx.crossOrigin](value) {
      this.crossOrigin = value;
    }
    get [dartx.currentSrc]() {
      return this.currentSrc;
    }
    get [dartx.currentTime]() {
      return this.currentTime;
    }
    set [dartx.currentTime](value) {
      this.currentTime = value;
    }
    get [dartx.defaultMuted]() {
      return this.defaultMuted;
    }
    set [dartx.defaultMuted](value) {
      this.defaultMuted = value;
    }
    get [dartx.defaultPlaybackRate]() {
      return this.defaultPlaybackRate;
    }
    set [dartx.defaultPlaybackRate](value) {
      this.defaultPlaybackRate = value;
    }
    get [dartx.duration]() {
      return this.duration;
    }
    get [dartx.ended]() {
      return this.ended;
    }
    get [dartx.error]() {
      return this.error;
    }
    get [dartx.integrity]() {
      return this.integrity;
    }
    set [dartx.integrity](value) {
      this.integrity = value;
    }
    get [dartx.loop]() {
      return this.loop;
    }
    set [dartx.loop](value) {
      this.loop = value;
    }
    get [dartx.mediaGroup]() {
      return this.mediaGroup;
    }
    set [dartx.mediaGroup](value) {
      this.mediaGroup = value;
    }
    get [dartx.mediaKeys]() {
      return this.mediaKeys;
    }
    get [dartx.muted]() {
      return this.muted;
    }
    set [dartx.muted](value) {
      this.muted = value;
    }
    get [dartx.networkState]() {
      return this.networkState;
    }
    get [dartx.paused]() {
      return this.paused;
    }
    get [dartx.playbackRate]() {
      return this.playbackRate;
    }
    set [dartx.playbackRate](value) {
      this.playbackRate = value;
    }
    get [dartx.played]() {
      return this.played;
    }
    get [dartx.preload]() {
      return this.preload;
    }
    set [dartx.preload](value) {
      this.preload = value;
    }
    get [dartx.readyState]() {
      return this.readyState;
    }
    get [dartx.seekable]() {
      return this.seekable;
    }
    get [dartx.seeking]() {
      return this.seeking;
    }
    get [dartx.src]() {
      return this.src;
    }
    set [dartx.src](value) {
      this.src = value;
    }
    get [dartx.textTracks]() {
      return this.textTracks;
    }
    get [dartx.videoTracks]() {
      return this.videoTracks;
    }
    get [dartx.volume]() {
      return this.volume;
    }
    set [dartx.volume](value) {
      this.volume = value;
    }
    get [dartx.audioDecodedByteCount]() {
      return this.webkitAudioDecodedByteCount;
    }
    get [dartx.videoDecodedByteCount]() {
      return this.webkitVideoDecodedByteCount;
    }
    [dartx.addTextTrack](kind, label, language) {
      return this.addTextTrack(kind, label, language);
    }
    [dartx.canPlayType](type, keySystem) {
      return this.canPlayType(type, keySystem);
    }
    [dartx.load]() {
      return this.load();
    }
    [dartx.pause]() {
      return this.pause();
    }
    [dartx.play]() {
      return this.play();
    }
    [dartx.setMediaKeys](mediaKeys) {
      return this.setMediaKeys(mediaKeys);
    }
    [dartx.addKey](keySystem, key, initData, sessionId) {
      return this.webkitAddKey(keySystem, key, initData, sessionId);
    }
    [dartx.cancelKeyRequest](keySystem, sessionId) {
      return this.webkitCancelKeyRequest(keySystem, sessionId);
    }
    [dartx.generateKeyRequest](keySystem, initData) {
      return this.webkitGenerateKeyRequest(keySystem, initData);
    }
    get [dartx.onKeyAdded]() {
      return MediaElement.keyAddedEvent.forElement(this);
    }
    get [dartx.onKeyError]() {
      return MediaElement.keyErrorEvent.forElement(this);
    }
    get [dartx.onKeyMessage]() {
      return MediaElement.keyMessageEvent.forElement(this);
    }
    get [dartx.onNeedKey]() {
      return MediaElement.needKeyEvent.forElement(this);
    }
  }
  dart.defineNamedConstructor(MediaElement, 'created');
  dart.setSignature(MediaElement, {
    constructors: () => ({
      _: [MediaElement, []],
      created: [MediaElement, []]
    }),
    methods: () => ({
      [dartx.addTextTrack]: [TextTrack, [core.String], [core.String, core.String]],
      [dartx.canPlayType]: [core.String, [core.String], [core.String]],
      [dartx.load]: [dart.void, []],
      [dartx.pause]: [dart.void, []],
      [dartx.play]: [dart.void, []],
      [dartx.setMediaKeys]: [async.Future, [MediaKeys]],
      [dartx.addKey]: [dart.void, [core.String, typed_data.Uint8List], [typed_data.Uint8List, core.String]],
      [dartx.cancelKeyRequest]: [dart.void, [core.String, core.String]],
      [dartx.generateKeyRequest]: [dart.void, [core.String], [typed_data.Uint8List]]
    })
  });
  MediaElement[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('HTMLMediaElement')), dart.const(new _metadata.Unstable()), dart.const(new _js_helper.Native("HTMLMediaElement"))];
  MediaElement.HAVE_CURRENT_DATA = 2;
  MediaElement.HAVE_ENOUGH_DATA = 4;
  MediaElement.HAVE_FUTURE_DATA = 3;
  MediaElement.HAVE_METADATA = 1;
  MediaElement.HAVE_NOTHING = 0;
  MediaElement.NETWORK_EMPTY = 0;
  MediaElement.NETWORK_IDLE = 1;
  MediaElement.NETWORK_LOADING = 2;
  MediaElement.NETWORK_NO_SOURCE = 3;
  dart.defineLazyProperties(MediaElement, {
    get keyAddedEvent() {
      return dart.const(new (EventStreamProvider$(MediaKeyEvent))('webkitkeyadded'));
    },
    get keyErrorEvent() {
      return dart.const(new (EventStreamProvider$(MediaKeyEvent))('webkitkeyerror'));
    },
    get keyMessageEvent() {
      return dart.const(new (EventStreamProvider$(MediaKeyEvent))('webkitkeymessage'));
    },
    get needKeyEvent() {
      return dart.const(new (EventStreamProvider$(MediaKeyEvent))('webkitneedkey'));
    }
  });
  dart.registerExtension(dart.global.HTMLMediaElement, MediaElement);
  class AudioElement extends MediaElement {
    static _(src) {
      if (src === void 0) src = null;
      if (src != null) {
        return AudioElement._create_1(src);
      }
      return AudioElement._create_2();
    }
    static _create_1(src) {
      return dart.as(new Audio(src), AudioElement);
    }
    static _create_2() {
      return dart.as(new Audio(), AudioElement);
    }
    created() {
      super.created();
    }
    static new(src) {
      if (src === void 0) src = null;
      return AudioElement._(src);
    }
  }
  dart.defineNamedConstructor(AudioElement, 'created');
  dart.setSignature(AudioElement, {
    constructors: () => ({
      _: [AudioElement, [], [core.String]],
      created: [AudioElement, []],
      new: [AudioElement, [], [core.String]]
    }),
    statics: () => ({
      _create_1: [AudioElement, [dart.dynamic]],
      _create_2: [AudioElement, []]
    }),
    names: ['_create_1', '_create_2']
  });
  AudioElement[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('HTMLAudioElement')), dart.const(new _js_helper.Native("HTMLAudioElement"))];
  dart.registerExtension(dart.global.HTMLAudioElement, AudioElement);
  dart.defineExtensionNames([
    'enabled',
    'id',
    'kind',
    'label',
    'language'
  ]);
  class AudioTrack extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.enabled]() {
      return this.enabled;
    }
    set [dartx.enabled](value) {
      this.enabled = value;
    }
    get [dartx.id]() {
      return this.id;
    }
    get [dartx.kind]() {
      return this.kind;
    }
    get [dartx.label]() {
      return this.label;
    }
    get [dartx.language]() {
      return this.language;
    }
  }
  dart.setSignature(AudioTrack, {
    constructors: () => ({_: [AudioTrack, []]})
  });
  AudioTrack[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('AudioTrack')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("AudioTrack"))];
  dart.registerExtension(dart.global.AudioTrack, AudioTrack);
  const __getter__ = Symbol('__getter__');
  dart.defineExtensionNames([
    'getTrackById',
    'onChange',
    'length'
  ]);
  class AudioTrackList extends EventTarget {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.length]() {
      return this.length;
    }
    [__getter__](index) {
      return this.__getter__(index);
    }
    [dartx.getTrackById](id) {
      return this.getTrackById(id);
    }
    get [dartx.onChange]() {
      return AudioTrackList.changeEvent.forTarget(this);
    }
  }
  dart.setSignature(AudioTrackList, {
    constructors: () => ({_: [AudioTrackList, []]}),
    methods: () => ({
      [__getter__]: [AudioTrack, [core.int]],
      [dartx.getTrackById]: [AudioTrack, [core.String]]
    })
  });
  AudioTrackList[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('AudioTrackList')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("AudioTrackList"))];
  dart.defineLazyProperties(AudioTrackList, {
    get changeEvent() {
      return dart.const(new (EventStreamProvider$(Event))('change'));
    }
  });
  dart.registerExtension(dart.global.AudioTrackList, AudioTrackList);
  dart.defineExtensionNames([
    'reason'
  ]);
  class AutocompleteErrorEvent extends Event {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.reason]() {
      return this.reason;
    }
  }
  dart.setSignature(AutocompleteErrorEvent, {
    constructors: () => ({_: [AutocompleteErrorEvent, []]})
  });
  AutocompleteErrorEvent[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('AutocompleteErrorEvent')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("AutocompleteErrorEvent"))];
  dart.registerExtension(dart.global.AutocompleteErrorEvent, AutocompleteErrorEvent);
  class BRElement extends HtmlElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return dart.as(exports.document[dartx.createElement]("br"), BRElement);
    }
    created() {
      super.created();
    }
  }
  dart.defineNamedConstructor(BRElement, 'created');
  dart.setSignature(BRElement, {
    constructors: () => ({
      _: [BRElement, []],
      new: [BRElement, []],
      created: [BRElement, []]
    })
  });
  BRElement[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('HTMLBRElement')), dart.const(new _js_helper.Native("HTMLBRElement"))];
  dart.registerExtension(dart.global.HTMLBRElement, BRElement);
  dart.defineExtensionNames([
    'visible'
  ]);
  class BarProp extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.visible]() {
      return this.visible;
    }
  }
  dart.setSignature(BarProp, {
    constructors: () => ({_: [BarProp, []]})
  });
  BarProp[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('BarProp')), core.deprecated, dart.const(new _js_helper.Native("BarProp"))];
  dart.registerExtension(dart.global.BarProp, BarProp);
  dart.defineExtensionNames([
    'href',
    'target'
  ]);
  class BaseElement extends HtmlElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return dart.as(exports.document[dartx.createElement]("base"), BaseElement);
    }
    created() {
      this[dartx.href] = null;
      this[dartx.target] = null;
      super.created();
    }
    get [dartx.href]() {
      return this.href;
    }
    set [dartx.href](value) {
      this.href = value;
    }
    get [dartx.target]() {
      return this.target;
    }
    set [dartx.target](value) {
      this.target = value;
    }
  }
  dart.defineNamedConstructor(BaseElement, 'created');
  dart.setSignature(BaseElement, {
    constructors: () => ({
      _: [BaseElement, []],
      new: [BaseElement, []],
      created: [BaseElement, []]
    })
  });
  BaseElement[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('HTMLBaseElement')), dart.const(new _js_helper.Native("HTMLBaseElement"))];
  dart.registerExtension(dart.global.HTMLBaseElement, BaseElement);
  dart.defineExtensionNames([
    'charging',
    'chargingTime',
    'dischargingTime',
    'level'
  ]);
  class BatteryManager extends EventTarget {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.charging]() {
      return this.charging;
    }
    get [dartx.chargingTime]() {
      return this.chargingTime;
    }
    get [dartx.dischargingTime]() {
      return this.dischargingTime;
    }
    get [dartx.level]() {
      return this.level;
    }
  }
  dart.setSignature(BatteryManager, {
    constructors: () => ({_: [BatteryManager, []]})
  });
  BatteryManager[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('BatteryManager')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("BatteryManager"))];
  dart.registerExtension(dart.global.BatteryManager, BatteryManager);
  dart.defineExtensionNames([
    'returnValue',
    'returnValue'
  ]);
  class BeforeUnloadEvent extends Event {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.returnValue]() {
      return this.returnValue;
    }
    set [dartx.returnValue](value) {
      this.returnValue = value;
    }
  }
  dart.setSignature(BeforeUnloadEvent, {
    constructors: () => ({_: [BeforeUnloadEvent, []]})
  });
  BeforeUnloadEvent[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('BeforeUnloadEvent')), dart.const(new _js_helper.Native("BeforeUnloadEvent"))];
  dart.registerExtension(dart.global.BeforeUnloadEvent, BeforeUnloadEvent);
  dart.defineExtensionNames([
    'close',
    'slice',
    'size',
    'type'
  ]);
  class Blob extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.size]() {
      return this.size;
    }
    get [dartx.type]() {
      return this.type;
    }
    [dartx.close]() {
      return this.close();
    }
    [dartx.slice](start, end, contentType) {
      return this.slice(start, end, contentType);
    }
    static new(blobParts, type, endings) {
      if (type === void 0) type = null;
      if (endings === void 0) endings = null;
      if (type == null && endings == null) {
        return dart.as(Blob._create_1(blobParts), Blob);
      }
      let bag = Blob._create_bag();
      if (type != null) Blob._bag_set(bag, 'type', type);
      if (endings != null) Blob._bag_set(bag, 'endings', endings);
      return dart.as(Blob._create_2(blobParts, bag), Blob);
    }
    static _create_1(parts) {
      return new Blob(parts);
    }
    static _create_2(parts, bag) {
      return new Blob(parts, bag);
    }
    static _create_bag() {
      return {};
    }
    static _bag_set(bag, key, value) {
      bag[key] = value;
    }
  }
  dart.setSignature(Blob, {
    constructors: () => ({
      _: [Blob, []],
      new: [Blob, [core.List], [core.String, core.String]]
    }),
    methods: () => ({
      [dartx.close]: [dart.void, []],
      [dartx.slice]: [Blob, [], [core.int, core.int, core.String]]
    }),
    statics: () => ({
      _create_1: [dart.dynamic, [dart.dynamic]],
      _create_2: [dart.dynamic, [dart.dynamic, dart.dynamic]],
      _create_bag: [dart.dynamic, []],
      _bag_set: [dart.dynamic, [dart.dynamic, dart.dynamic, dart.dynamic]]
    }),
    names: ['_create_1', '_create_2', '_create_bag', '_bag_set']
  });
  Blob[dart.metadata] = () => [dart.const(new _metadata.DomName('Blob')), dart.const(new _js_helper.Native("Blob"))];
  dart.registerExtension(dart.global.Blob, Blob);
  dart.defineExtensionNames([
    'arrayBuffer',
    'blob',
    'json',
    'text',
    'bodyUsed'
  ]);
  class Body extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.bodyUsed]() {
      return this.bodyUsed;
    }
    [dartx.arrayBuffer]() {
      return this.arrayBuffer();
    }
    [dartx.blob]() {
      return this.blob();
    }
    [dartx.json]() {
      return this.json();
    }
    [dartx.text]() {
      return this.text();
    }
  }
  dart.setSignature(Body, {
    constructors: () => ({_: [Body, []]}),
    methods: () => ({
      [dartx.arrayBuffer]: [async.Future, []],
      [dartx.blob]: [async.Future, []],
      [dartx.json]: [async.Future, []],
      [dartx.text]: [async.Future, []]
    })
  });
  Body[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('Body')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("Body"))];
  dart.registerExtension(dart.global.Body, Body);
  dart.defineExtensionNames([
    'onBlur',
    'onError',
    'onFocus',
    'onHashChange',
    'onLoad',
    'onMessage',
    'onOffline',
    'onOnline',
    'onPopState',
    'onResize',
    'onScroll',
    'onStorage',
    'onUnload'
  ]);
  class BodyElement extends HtmlElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return dart.as(exports.document[dartx.createElement]("body"), BodyElement);
    }
    created() {
      super.created();
    }
    get [dartx.onBlur]() {
      return BodyElement.blurEvent.forElement(this);
    }
    get [dartx.onError]() {
      return BodyElement.errorEvent.forElement(this);
    }
    get [dartx.onFocus]() {
      return BodyElement.focusEvent.forElement(this);
    }
    get [dartx.onHashChange]() {
      return BodyElement.hashChangeEvent.forElement(this);
    }
    get [dartx.onLoad]() {
      return BodyElement.loadEvent.forElement(this);
    }
    get [dartx.onMessage]() {
      return BodyElement.messageEvent.forElement(this);
    }
    get [dartx.onOffline]() {
      return BodyElement.offlineEvent.forElement(this);
    }
    get [dartx.onOnline]() {
      return BodyElement.onlineEvent.forElement(this);
    }
    get [dartx.onPopState]() {
      return BodyElement.popStateEvent.forElement(this);
    }
    get [dartx.onResize]() {
      return BodyElement.resizeEvent.forElement(this);
    }
    get [dartx.onScroll]() {
      return BodyElement.scrollEvent.forElement(this);
    }
    get [dartx.onStorage]() {
      return BodyElement.storageEvent.forElement(this);
    }
    get [dartx.onUnload]() {
      return BodyElement.unloadEvent.forElement(this);
    }
  }
  BodyElement[dart.implements] = () => [WindowEventHandlers];
  dart.defineNamedConstructor(BodyElement, 'created');
  dart.setSignature(BodyElement, {
    constructors: () => ({
      _: [BodyElement, []],
      new: [BodyElement, []],
      created: [BodyElement, []]
    })
  });
  BodyElement[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('HTMLBodyElement')), dart.const(new _js_helper.Native("HTMLBodyElement"))];
  dart.defineLazyProperties(BodyElement, {
    get blurEvent() {
      return dart.const(new (EventStreamProvider$(Event))('blur'));
    },
    get errorEvent() {
      return dart.const(new (EventStreamProvider$(Event))('error'));
    },
    get focusEvent() {
      return dart.const(new (EventStreamProvider$(Event))('focus'));
    },
    get hashChangeEvent() {
      return dart.const(new (EventStreamProvider$(Event))('hashchange'));
    },
    get loadEvent() {
      return dart.const(new (EventStreamProvider$(Event))('load'));
    },
    get messageEvent() {
      return dart.const(new (EventStreamProvider$(MessageEvent))('message'));
    },
    get offlineEvent() {
      return dart.const(new (EventStreamProvider$(Event))('offline'));
    },
    get onlineEvent() {
      return dart.const(new (EventStreamProvider$(Event))('online'));
    },
    get popStateEvent() {
      return dart.const(new (EventStreamProvider$(PopStateEvent))('popstate'));
    },
    get resizeEvent() {
      return dart.const(new (EventStreamProvider$(Event))('resize'));
    },
    get scrollEvent() {
      return dart.const(new (EventStreamProvider$(Event))('scroll'));
    },
    get storageEvent() {
      return dart.const(new (EventStreamProvider$(StorageEvent))('storage'));
    },
    get unloadEvent() {
      return dart.const(new (EventStreamProvider$(Event))('unload'));
    }
  });
  dart.registerExtension(dart.global.HTMLBodyElement, BodyElement);
  dart.defineExtensionNames([
    'checkValidity',
    'setCustomValidity',
    'autofocus',
    'disabled',
    'form',
    'formAction',
    'formEnctype',
    'formMethod',
    'formNoValidate',
    'formTarget',
    'labels',
    'name',
    'type',
    'validationMessage',
    'validity',
    'value',
    'willValidate'
  ]);
  class ButtonElement extends HtmlElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return dart.as(exports.document[dartx.createElement]("button"), ButtonElement);
    }
    created() {
      this[dartx.autofocus] = null;
      this[dartx.disabled] = null;
      this[dartx.form] = null;
      this[dartx.formAction] = null;
      this[dartx.formEnctype] = null;
      this[dartx.formMethod] = null;
      this[dartx.formNoValidate] = null;
      this[dartx.formTarget] = null;
      this[dartx.labels] = null;
      this[dartx.name] = null;
      this[dartx.type] = null;
      this[dartx.validationMessage] = null;
      this[dartx.validity] = null;
      this[dartx.value] = null;
      this[dartx.willValidate] = null;
      super.created();
    }
    get [dartx.autofocus]() {
      return this.autofocus;
    }
    set [dartx.autofocus](value) {
      this.autofocus = value;
    }
    get [dartx.disabled]() {
      return this.disabled;
    }
    set [dartx.disabled](value) {
      this.disabled = value;
    }
    get [dartx.form]() {
      return this.form;
    }
    get [dartx.formAction]() {
      return this.formAction;
    }
    set [dartx.formAction](value) {
      this.formAction = value;
    }
    get [dartx.formEnctype]() {
      return this.formEnctype;
    }
    set [dartx.formEnctype](value) {
      this.formEnctype = value;
    }
    get [dartx.formMethod]() {
      return this.formMethod;
    }
    set [dartx.formMethod](value) {
      this.formMethod = value;
    }
    get [dartx.formNoValidate]() {
      return this.formNoValidate;
    }
    set [dartx.formNoValidate](value) {
      this.formNoValidate = value;
    }
    get [dartx.formTarget]() {
      return this.formTarget;
    }
    set [dartx.formTarget](value) {
      this.formTarget = value;
    }
    get [dartx.labels]() {
      return this.labels;
    }
    get [dartx.name]() {
      return this.name;
    }
    set [dartx.name](value) {
      this.name = value;
    }
    get [dartx.type]() {
      return this.type;
    }
    set [dartx.type](value) {
      this.type = value;
    }
    get [dartx.validationMessage]() {
      return this.validationMessage;
    }
    get [dartx.validity]() {
      return this.validity;
    }
    get [dartx.value]() {
      return this.value;
    }
    set [dartx.value](value) {
      this.value = value;
    }
    get [dartx.willValidate]() {
      return this.willValidate;
    }
    [dartx.checkValidity]() {
      return this.checkValidity();
    }
    [dartx.setCustomValidity](error) {
      return this.setCustomValidity(error);
    }
  }
  dart.defineNamedConstructor(ButtonElement, 'created');
  dart.setSignature(ButtonElement, {
    constructors: () => ({
      _: [ButtonElement, []],
      new: [ButtonElement, []],
      created: [ButtonElement, []]
    }),
    methods: () => ({
      [dartx.checkValidity]: [core.bool, []],
      [dartx.setCustomValidity]: [dart.void, [core.String]]
    })
  });
  ButtonElement[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('HTMLButtonElement')), dart.const(new _js_helper.Native("HTMLButtonElement"))];
  dart.registerExtension(dart.global.HTMLButtonElement, ButtonElement);
  dart.defineExtensionNames([
    'appendData',
    'deleteData',
    'insertData',
    'replaceData',
    'substringData',
    'data',
    'length',
    'nextElementSibling',
    'previousElementSibling'
  ]);
  class CharacterData extends Node {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.data]() {
      return this.data;
    }
    set [dartx.data](value) {
      this.data = value;
    }
    get [dartx.length]() {
      return this.length;
    }
    [dartx.appendData](data) {
      return this.appendData(data);
    }
    [dartx.deleteData](offset, length) {
      return this.deleteData(offset, length);
    }
    [dartx.insertData](offset, data) {
      return this.insertData(offset, data);
    }
    [dartx.replaceData](offset, length, data) {
      return this.replaceData(offset, length, data);
    }
    [dartx.substringData](offset, length) {
      return this.substringData(offset, length);
    }
    get [dartx.nextElementSibling]() {
      return this.nextElementSibling;
    }
    get [dartx.previousElementSibling]() {
      return this.previousElementSibling;
    }
  }
  CharacterData[dart.implements] = () => [ChildNode];
  dart.setSignature(CharacterData, {
    constructors: () => ({_: [CharacterData, []]}),
    methods: () => ({
      [dartx.appendData]: [dart.void, [core.String]],
      [dartx.deleteData]: [dart.void, [core.int, core.int]],
      [dartx.insertData]: [dart.void, [core.int, core.String]],
      [dartx.replaceData]: [dart.void, [core.int, core.int, core.String]],
      [dartx.substringData]: [core.String, [core.int, core.int]]
    })
  });
  CharacterData[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('CharacterData')), dart.const(new _js_helper.Native("CharacterData"))];
  dart.registerExtension(dart.global.CharacterData, CharacterData);
  const _createTextNode = Symbol('_createTextNode');
  dart.defineExtensionNames([
    'getDestinationInsertionPoints',
    'splitText',
    'wholeText'
  ]);
  class Text extends CharacterData {
    static new(data) {
      return exports.document[_createTextNode](data);
    }
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.wholeText]() {
      return this.wholeText;
    }
    [dartx.getDestinationInsertionPoints]() {
      return this.getDestinationInsertionPoints();
    }
    [dartx.splitText](offset) {
      return this.splitText(offset);
    }
  }
  dart.setSignature(Text, {
    constructors: () => ({
      new: [Text, [core.String]],
      _: [Text, []]
    }),
    methods: () => ({
      [dartx.getDestinationInsertionPoints]: [core.List$(Node), []],
      [dartx.splitText]: [Text, [core.int]]
    })
  });
  Text[dart.metadata] = () => [dart.const(new _metadata.DomName('Text')), dart.const(new _js_helper.Native("Text"))];
  dart.registerExtension(dart.global.Text, Text);
  class CDataSection extends Text {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
  }
  dart.setSignature(CDataSection, {
    constructors: () => ({_: [CDataSection, []]})
  });
  CDataSection[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('CDATASection')), core.deprecated, dart.const(new _js_helper.Native("CDATASection"))];
  dart.registerExtension(dart.global.CDATASection, CDataSection);
  dart.defineExtensionNames([
    'create',
    'delete',
    'get',
    'has',
    'keys'
  ]);
  class CacheStorage extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    [dartx.create](cacheName) {
      return this.create(cacheName);
    }
    [dartx.delete](cacheName) {
      return this.delete(cacheName);
    }
    [dartx.get](cacheName) {
      return this.get(cacheName);
    }
    [dartx.has](cacheName) {
      return this.has(cacheName);
    }
    [dartx.keys]() {
      return this.keys();
    }
  }
  dart.setSignature(CacheStorage, {
    constructors: () => ({_: [CacheStorage, []]}),
    methods: () => ({
      [dartx.create]: [async.Future, [core.String]],
      [dartx.delete]: [async.Future, [core.String]],
      [dartx.get]: [async.Future, [core.String]],
      [dartx.has]: [async.Future, [core.String]],
      [dartx.keys]: [async.Future, []]
    })
  });
  CacheStorage[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('CacheStorage')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("CacheStorage"))];
  dart.registerExtension(dart.global.CacheStorage, CacheStorage);
  dart.defineExtensionNames([
    'alpha',
    'storage'
  ]);
  class Canvas2DContextAttributes extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.alpha]() {
      return this.alpha;
    }
    set [dartx.alpha](value) {
      this.alpha = value;
    }
    get [dartx.storage]() {
      return this.storage;
    }
    set [dartx.storage](value) {
      this.storage = value;
    }
  }
  dart.setSignature(Canvas2DContextAttributes, {
    constructors: () => ({_: [Canvas2DContextAttributes, []]})
  });
  Canvas2DContextAttributes[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('Canvas2DContextAttributes')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("Canvas2DContextAttributes"))];
  dart.registerExtension(dart.global.Canvas2DContextAttributes, Canvas2DContextAttributes);
  const _getContext_1 = Symbol('_getContext_1');
  const _getContext_2 = Symbol('_getContext_2');
  const _toDataUrl = Symbol('_toDataUrl');
  dart.defineExtensionNames([
    'getContext',
    'onWebGlContextLost',
    'onWebGlContextRestored',
    'context2D',
    'getContext3d',
    'toDataUrl',
    'height',
    'width'
  ]);
  class CanvasElement extends HtmlElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new(opts) {
      let width = opts && 'width' in opts ? opts.width : null;
      let height = opts && 'height' in opts ? opts.height : null;
      let e = exports.document[dartx.createElement]("canvas");
      if (width != null) dart.dput(e, 'width', width);
      if (height != null) dart.dput(e, 'height', height);
      return dart.as(e, CanvasElement);
    }
    created() {
      this[dartx.height] = null;
      this[dartx.width] = null;
      super.created();
    }
    get [dartx.height]() {
      return this.height;
    }
    set [dartx.height](value) {
      this.height = value;
    }
    get [dartx.width]() {
      return this.width;
    }
    set [dartx.width](value) {
      this.width = value;
    }
    [dartx.getContext](contextId, attrs) {
      if (attrs === void 0) attrs = null;
      if (attrs != null) {
        let attrs_1 = html_common.convertDartToNative_Dictionary(attrs);
        return this[_getContext_1](contextId, attrs_1);
      }
      return this[_getContext_2](contextId);
    }
    [_getContext_1](contextId, attrs) {
      return this.getContext(contextId, attrs);
    }
    [_getContext_2](contextId) {
      return this.getContext(contextId);
    }
    [_toDataUrl](type, quality) {
      return this.toDataURL(type, quality);
    }
    get [dartx.onWebGlContextLost]() {
      return CanvasElement.webGlContextLostEvent.forElement(this);
    }
    get [dartx.onWebGlContextRestored]() {
      return CanvasElement.webGlContextRestoredEvent.forElement(this);
    }
    get [dartx.context2D]() {
      return dart.as(this.getContext('2d'), CanvasRenderingContext2D);
    }
    [dartx.getContext3d](opts) {
      let alpha = opts && 'alpha' in opts ? opts.alpha : true;
      let depth = opts && 'depth' in opts ? opts.depth : true;
      let stencil = opts && 'stencil' in opts ? opts.stencil : false;
      let antialias = opts && 'antialias' in opts ? opts.antialias : true;
      let premultipliedAlpha = opts && 'premultipliedAlpha' in opts ? opts.premultipliedAlpha : true;
      let preserveDrawingBuffer = opts && 'preserveDrawingBuffer' in opts ? opts.preserveDrawingBuffer : false;
      let options = dart.map({alpha: alpha, depth: depth, stencil: stencil, antialias: antialias, premultipliedAlpha: premultipliedAlpha, preserveDrawingBuffer: preserveDrawingBuffer});
      let context = this[dartx.getContext]('webgl', options);
      if (context == null) {
        context = this[dartx.getContext]('experimental-webgl', options);
      }
      return dart.as(context, web_gl.RenderingContext);
    }
    [dartx.toDataUrl](type, quality) {
      if (type === void 0) type = 'image/png';
      if (quality === void 0) quality = null;
      return this[_toDataUrl](type, quality);
    }
  }
  CanvasElement[dart.implements] = () => [CanvasImageSource];
  dart.defineNamedConstructor(CanvasElement, 'created');
  dart.setSignature(CanvasElement, {
    constructors: () => ({
      _: [CanvasElement, []],
      new: [CanvasElement, [], {width: core.int, height: core.int}],
      created: [CanvasElement, []]
    }),
    methods: () => ({
      [dartx.getContext]: [core.Object, [core.String], [core.Map]],
      [_getContext_1]: [core.Object, [dart.dynamic, dart.dynamic]],
      [_getContext_2]: [core.Object, [dart.dynamic]],
      [_toDataUrl]: [core.String, [core.String], [core.num]],
      [dartx.getContext3d]: [web_gl.RenderingContext, [], {alpha: dart.dynamic, depth: dart.dynamic, stencil: dart.dynamic, antialias: dart.dynamic, premultipliedAlpha: dart.dynamic, preserveDrawingBuffer: dart.dynamic}],
      [dartx.toDataUrl]: [core.String, [], [core.String, core.num]]
    })
  });
  CanvasElement[dart.metadata] = () => [dart.const(new _metadata.DomName('HTMLCanvasElement')), dart.const(new _js_helper.Native("HTMLCanvasElement"))];
  dart.defineLazyProperties(CanvasElement, {
    get webGlContextLostEvent() {
      return dart.const(new (EventStreamProvider$(web_gl.ContextEvent))('webglcontextlost'));
    },
    get webGlContextRestoredEvent() {
      return dart.const(new (EventStreamProvider$(web_gl.ContextEvent))('webglcontextrestored'));
    }
  });
  dart.registerExtension(dart.global.HTMLCanvasElement, CanvasElement);
  dart.defineExtensionNames([
    'addColorStop'
  ]);
  class CanvasGradient extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    [dartx.addColorStop](offset, color) {
      return this.addColorStop(offset, color);
    }
  }
  dart.setSignature(CanvasGradient, {
    constructors: () => ({_: [CanvasGradient, []]}),
    methods: () => ({[dartx.addColorStop]: [dart.void, [core.num, core.String]]})
  });
  CanvasGradient[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('CanvasGradient')), dart.const(new _js_helper.Native("CanvasGradient"))];
  dart.registerExtension(dart.global.CanvasGradient, CanvasGradient);
  dart.defineExtensionNames([
    'setTransform'
  ]);
  class CanvasPattern extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    [dartx.setTransform](transform) {
      return this.setTransform(transform);
    }
  }
  dart.setSignature(CanvasPattern, {
    constructors: () => ({_: [CanvasPattern, []]}),
    methods: () => ({[dartx.setTransform]: [dart.void, [svg.Matrix]]})
  });
  CanvasPattern[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('CanvasPattern')), dart.const(new _js_helper.Native("CanvasPattern"))];
  dart.registerExtension(dart.global.CanvasPattern, CanvasPattern);
  class CanvasRenderingContext extends core.Object {}
  const _addHitRegion_1 = Symbol('_addHitRegion_1');
  const _addHitRegion_2 = Symbol('_addHitRegion_2');
  const _createImageData_1 = Symbol('_createImageData_1');
  const _createImageDataFromImageData_1 = Symbol('_createImageDataFromImageData_1');
  const _getImageData_1 = Symbol('_getImageData_1');
  const _getLineDash = Symbol('_getLineDash');
  const _putImageData_1 = Symbol('_putImageData_1');
  const _putImageData_2 = Symbol('_putImageData_2');
  const _arc = Symbol('_arc');
  dart.defineExtensionNames([
    'addHitRegion',
    'beginPath',
    'clearHitRegions',
    'clearRect',
    'clip',
    'createImageData',
    'createImageDataFromImageData',
    'createLinearGradient',
    'createPattern',
    'createPatternFromImage',
    'createRadialGradient',
    'drawFocusIfNeeded',
    'fillRect',
    'getContextAttributes',
    'getImageData',
    'isContextLost',
    'isPointInPath',
    'isPointInStroke',
    'measureText',
    'putImageData',
    'removeHitRegion',
    'resetTransform',
    'restore',
    'rotate',
    'save',
    'scale',
    'scrollPathIntoView',
    'setTransform',
    'stroke',
    'strokeRect',
    'strokeText',
    'transform',
    'translate',
    'arcTo',
    'bezierCurveTo',
    'closePath',
    'ellipse',
    'lineTo',
    'moveTo',
    'quadraticCurveTo',
    'rect',
    'setFillColorRgb',
    'setFillColorHsl',
    'setStrokeColorRgb',
    'setStrokeColorHsl',
    'arc',
    'drawImageToRect',
    'drawImage',
    'drawImageScaled',
    'drawImageScaledFromSource',
    'lineDashOffset',
    'lineDashOffset',
    'getLineDash',
    'setLineDash',
    'fillText',
    'fill',
    'backingStorePixelRatio',
    'canvas',
    'currentTransform',
    'direction',
    'fillStyle',
    'font',
    'globalAlpha',
    'globalCompositeOperation',
    'imageSmoothingEnabled',
    'lineCap',
    'lineJoin',
    'lineWidth',
    'miterLimit',
    'shadowBlur',
    'shadowColor',
    'shadowOffsetX',
    'shadowOffsetY',
    'strokeStyle',
    'textAlign',
    'textBaseline'
  ]);
  class CanvasRenderingContext2D extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.canvas]() {
      return this.canvas;
    }
    get [dartx.currentTransform]() {
      return this.currentTransform;
    }
    set [dartx.currentTransform](value) {
      this.currentTransform = value;
    }
    get [dartx.direction]() {
      return this.direction;
    }
    set [dartx.direction](value) {
      this.direction = value;
    }
    get [dartx.fillStyle]() {
      return this.fillStyle;
    }
    set [dartx.fillStyle](value) {
      this.fillStyle = value;
    }
    get [dartx.font]() {
      return this.font;
    }
    set [dartx.font](value) {
      this.font = value;
    }
    get [dartx.globalAlpha]() {
      return this.globalAlpha;
    }
    set [dartx.globalAlpha](value) {
      this.globalAlpha = value;
    }
    get [dartx.globalCompositeOperation]() {
      return this.globalCompositeOperation;
    }
    set [dartx.globalCompositeOperation](value) {
      this.globalCompositeOperation = value;
    }
    get [dartx.imageSmoothingEnabled]() {
      return this.imageSmoothingEnabled;
    }
    set [dartx.imageSmoothingEnabled](value) {
      this.imageSmoothingEnabled = value;
    }
    get [dartx.lineCap]() {
      return this.lineCap;
    }
    set [dartx.lineCap](value) {
      this.lineCap = value;
    }
    get [dartx.lineJoin]() {
      return this.lineJoin;
    }
    set [dartx.lineJoin](value) {
      this.lineJoin = value;
    }
    get [dartx.lineWidth]() {
      return this.lineWidth;
    }
    set [dartx.lineWidth](value) {
      this.lineWidth = value;
    }
    get [dartx.miterLimit]() {
      return this.miterLimit;
    }
    set [dartx.miterLimit](value) {
      this.miterLimit = value;
    }
    get [dartx.shadowBlur]() {
      return this.shadowBlur;
    }
    set [dartx.shadowBlur](value) {
      this.shadowBlur = value;
    }
    get [dartx.shadowColor]() {
      return this.shadowColor;
    }
    set [dartx.shadowColor](value) {
      this.shadowColor = value;
    }
    get [dartx.shadowOffsetX]() {
      return this.shadowOffsetX;
    }
    set [dartx.shadowOffsetX](value) {
      this.shadowOffsetX = value;
    }
    get [dartx.shadowOffsetY]() {
      return this.shadowOffsetY;
    }
    set [dartx.shadowOffsetY](value) {
      this.shadowOffsetY = value;
    }
    get [dartx.strokeStyle]() {
      return this.strokeStyle;
    }
    set [dartx.strokeStyle](value) {
      this.strokeStyle = value;
    }
    get [dartx.textAlign]() {
      return this.textAlign;
    }
    set [dartx.textAlign](value) {
      this.textAlign = value;
    }
    get [dartx.textBaseline]() {
      return this.textBaseline;
    }
    set [dartx.textBaseline](value) {
      this.textBaseline = value;
    }
    [dartx.addHitRegion](options) {
      if (options === void 0) options = null;
      if (options != null) {
        let options_1 = html_common.convertDartToNative_Dictionary(options);
        this[_addHitRegion_1](options_1);
        return;
      }
      this[_addHitRegion_2]();
      return;
    }
    [_addHitRegion_1](options) {
      return this.addHitRegion(options);
    }
    [_addHitRegion_2]() {
      return this.addHitRegion();
    }
    [dartx.beginPath]() {
      return this.beginPath();
    }
    [dartx.clearHitRegions]() {
      return this.clearHitRegions();
    }
    [dartx.clearRect](x, y, width, height) {
      return this.clearRect(x, y, width, height);
    }
    [dartx.clip](path_OR_winding, winding) {
      return this.clip(path_OR_winding, winding);
    }
    [dartx.createImageData](sw, sh) {
      return html_common.convertNativeToDart_ImageData(this[_createImageData_1](sw, sh));
    }
    [_createImageData_1](sw, sh) {
      return this.createImageData(sw, sh);
    }
    [dartx.createImageDataFromImageData](imagedata) {
      let imagedata_1 = html_common.convertDartToNative_ImageData(imagedata);
      return html_common.convertNativeToDart_ImageData(this[_createImageDataFromImageData_1](imagedata_1));
    }
    [_createImageDataFromImageData_1](imagedata) {
      return this.createImageData(imagedata);
    }
    [dartx.createLinearGradient](x0, y0, x1, y1) {
      return this.createLinearGradient(x0, y0, x1, y1);
    }
    [dartx.createPattern](canvas_OR_image, repetitionType) {
      return this.createPattern(canvas_OR_image, repetitionType);
    }
    [dartx.createPatternFromImage](image, repetitionType) {
      return this.createPattern(image, repetitionType);
    }
    [dartx.createRadialGradient](x0, y0, r0, x1, y1, r1) {
      return this.createRadialGradient(x0, y0, r0, x1, y1, r1);
    }
    [dartx.drawFocusIfNeeded](element_OR_path, element) {
      return this.drawFocusIfNeeded(element_OR_path, element);
    }
    [dartx.fillRect](x, y, width, height) {
      return this.fillRect(x, y, width, height);
    }
    [dartx.getContextAttributes]() {
      return this.getContextAttributes();
    }
    [dartx.getImageData](sx, sy, sw, sh) {
      return html_common.convertNativeToDart_ImageData(this[_getImageData_1](sx, sy, sw, sh));
    }
    [_getImageData_1](sx, sy, sw, sh) {
      return this.getImageData(sx, sy, sw, sh);
    }
    [_getLineDash]() {
      return this.getLineDash();
    }
    [dartx.isContextLost]() {
      return this.isContextLost();
    }
    [dartx.isPointInPath](path_OR_x, x_OR_y, winding_OR_y, winding) {
      return this.isPointInPath(path_OR_x, x_OR_y, winding_OR_y, winding);
    }
    [dartx.isPointInStroke](path_OR_x, x_OR_y, y) {
      return this.isPointInStroke(path_OR_x, x_OR_y, y);
    }
    [dartx.measureText](text) {
      return this.measureText(text);
    }
    [dartx.putImageData](imagedata, dx, dy, dirtyX, dirtyY, dirtyWidth, dirtyHeight) {
      if (dirtyX === void 0) dirtyX = null;
      if (dirtyY === void 0) dirtyY = null;
      if (dirtyWidth === void 0) dirtyWidth = null;
      if (dirtyHeight === void 0) dirtyHeight = null;
      if (dirtyX == null && dirtyY == null && dirtyWidth == null && dirtyHeight == null) {
        let imagedata_1 = html_common.convertDartToNative_ImageData(imagedata);
        this[_putImageData_1](imagedata_1, dx, dy);
        return;
      }
      if (dirtyHeight != null && dirtyWidth != null && dirtyY != null && dirtyX != null) {
        let imagedata_1 = html_common.convertDartToNative_ImageData(imagedata);
        this[_putImageData_2](imagedata_1, dx, dy, dirtyX, dirtyY, dirtyWidth, dirtyHeight);
        return;
      }
      dart.throw(new core.ArgumentError("Incorrect number or type of arguments"));
    }
    [_putImageData_1](imagedata, dx, dy) {
      return this.putImageData(imagedata, dx, dy);
    }
    [_putImageData_2](imagedata, dx, dy, dirtyX, dirtyY, dirtyWidth, dirtyHeight) {
      return this.putImageData(imagedata, dx, dy, dirtyX, dirtyY, dirtyWidth, dirtyHeight);
    }
    [dartx.removeHitRegion](id) {
      return this.removeHitRegion(id);
    }
    [dartx.resetTransform]() {
      return this.resetTransform();
    }
    [dartx.restore]() {
      return this.restore();
    }
    [dartx.rotate](angle) {
      return this.rotate(angle);
    }
    [dartx.save]() {
      return this.save();
    }
    [dartx.scale](x, y) {
      return this.scale(x, y);
    }
    [dartx.scrollPathIntoView](path) {
      return this.scrollPathIntoView(path);
    }
    [dartx.setTransform](a, b, c, d, e, f) {
      return this.setTransform(a, b, c, d, e, f);
    }
    [dartx.stroke](path) {
      return this.stroke(path);
    }
    [dartx.strokeRect](x, y, width, height) {
      return this.strokeRect(x, y, width, height);
    }
    [dartx.strokeText](text, x, y, maxWidth) {
      return this.strokeText(text, x, y, maxWidth);
    }
    [dartx.transform](a, b, c, d, e, f) {
      return this.transform(a, b, c, d, e, f);
    }
    [dartx.translate](x, y) {
      return this.translate(x, y);
    }
    [_arc](x, y, radius, startAngle, endAngle, anticlockwise) {
      return this.arc(x, y, radius, startAngle, endAngle, anticlockwise);
    }
    [dartx.arcTo](x1, y1, x2, y2, radius) {
      return this.arcTo(x1, y1, x2, y2, radius);
    }
    [dartx.bezierCurveTo](cp1x, cp1y, cp2x, cp2y, x, y) {
      return this.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);
    }
    [dartx.closePath]() {
      return this.closePath();
    }
    [dartx.ellipse](x, y, radiusX, radiusY, rotation, startAngle, endAngle, anticlockwise) {
      return this.ellipse(x, y, radiusX, radiusY, rotation, startAngle, endAngle, anticlockwise);
    }
    [dartx.lineTo](x, y) {
      return this.lineTo(x, y);
    }
    [dartx.moveTo](x, y) {
      return this.moveTo(x, y);
    }
    [dartx.quadraticCurveTo](cpx, cpy, x, y) {
      return this.quadraticCurveTo(cpx, cpy, x, y);
    }
    [dartx.rect](x, y, width, height) {
      return this.rect(x, y, width, height);
    }
    [dartx.setFillColorRgb](r, g, b, a) {
      if (a === void 0) a = 1;
      this[dartx.fillStyle] = `rgba(${r}, ${g}, ${b}, ${a})`;
    }
    [dartx.setFillColorHsl](h, s, l, a) {
      if (a === void 0) a = 1;
      this[dartx.fillStyle] = `hsla(${h}, ${s}%, ${l}%, ${a})`;
    }
    [dartx.setStrokeColorRgb](r, g, b, a) {
      if (a === void 0) a = 1;
      this[dartx.strokeStyle] = `rgba(${r}, ${g}, ${b}, ${a})`;
    }
    [dartx.setStrokeColorHsl](h, s, l, a) {
      if (a === void 0) a = 1;
      this[dartx.strokeStyle] = `hsla(${h}, ${s}%, ${l}%, ${a})`;
    }
    [dartx.arc](x, y, radius, startAngle, endAngle, anticlockwise) {
      if (anticlockwise === void 0) anticlockwise = false;
      this.arc(x, y, radius, startAngle, endAngle, anticlockwise);
    }
    [dartx.drawImageToRect](source, destRect, opts) {
      let sourceRect = opts && 'sourceRect' in opts ? opts.sourceRect : null;
      if (sourceRect == null) {
        this[dartx.drawImageScaled](source, dart.as(destRect[dartx.left], core.num), dart.as(destRect[dartx.top], core.num), dart.as(destRect[dartx.width], core.num), dart.as(destRect[dartx.height], core.num));
      } else {
        this[dartx.drawImageScaledFromSource](source, dart.as(sourceRect[dartx.left], core.num), dart.as(sourceRect[dartx.top], core.num), dart.as(sourceRect[dartx.width], core.num), dart.as(sourceRect[dartx.height], core.num), dart.as(destRect[dartx.left], core.num), dart.as(destRect[dartx.top], core.num), dart.as(destRect[dartx.width], core.num), dart.as(destRect[dartx.height], core.num));
      }
    }
    [dartx.drawImage](source, destX, destY) {
      return this.drawImage(source, destX, destY);
    }
    [dartx.drawImageScaled](source, destX, destY, destWidth, destHeight) {
      return this.drawImage(source, destX, destY, destWidth, destHeight);
    }
    [dartx.drawImageScaledFromSource](source, sourceX, sourceY, sourceWidth, sourceHeight, destX, destY, destWidth, destHeight) {
      return this.drawImage(source, sourceX, sourceY, sourceWidth, sourceHeight, destX, destY, destWidth, destHeight);
    }
    get [dartx.lineDashOffset]() {
      return this.lineDashOffset || this.webkitLineDashOffset;
    }
    set [dartx.lineDashOffset](value) {
      typeof this.lineDashOffset != "undefined" ? this.lineDashOffset = value : this.webkitLineDashOffset = value;
    }
    [dartx.getLineDash]() {
      if (!!this.getLineDash) {
        return dart.as(this.getLineDash(), core.List$(core.num));
      } else if (!!this.webkitLineDash) {
        return dart.as(this.webkitLineDash, core.List$(core.num));
      }
    }
    [dartx.setLineDash](dash) {
      if (!!this.setLineDash) {
        this.setLineDash(dash);
      } else if (!!this.webkitLineDash) {
        this.webkitLineDash = dash;
      }
    }
    [dartx.fillText](text, x, y, maxWidth) {
      if (maxWidth === void 0) maxWidth = null;
      if (maxWidth != null) {
        this.fillText(text, x, y, maxWidth);
      } else {
        this.fillText(text, x, y);
      }
    }
    [dartx.fill](winding) {
      if (winding === void 0) winding = 'nonzero';
      this.fill(winding);
    }
    get [dartx.backingStorePixelRatio]() {
      return 1.0;
    }
  }
  CanvasRenderingContext2D[dart.implements] = () => [CanvasRenderingContext];
  dart.setSignature(CanvasRenderingContext2D, {
    constructors: () => ({_: [CanvasRenderingContext2D, []]}),
    methods: () => ({
      [dartx.addHitRegion]: [dart.void, [], [core.Map]],
      [_addHitRegion_1]: [dart.void, [dart.dynamic]],
      [_addHitRegion_2]: [dart.void, []],
      [dartx.beginPath]: [dart.void, []],
      [dartx.clearHitRegions]: [dart.void, []],
      [dartx.clearRect]: [dart.void, [core.num, core.num, core.num, core.num]],
      [dartx.clip]: [dart.void, [], [dart.dynamic, core.String]],
      [dartx.createImageData]: [ImageData, [core.num, core.num]],
      [_createImageData_1]: [dart.dynamic, [dart.dynamic, dart.dynamic]],
      [dartx.createImageDataFromImageData]: [ImageData, [ImageData]],
      [_createImageDataFromImageData_1]: [dart.dynamic, [dart.dynamic]],
      [dartx.createLinearGradient]: [CanvasGradient, [core.num, core.num, core.num, core.num]],
      [dartx.createPattern]: [CanvasPattern, [dart.dynamic, core.String]],
      [dartx.createPatternFromImage]: [CanvasPattern, [ImageElement, core.String]],
      [dartx.createRadialGradient]: [CanvasGradient, [core.num, core.num, core.num, core.num, core.num, core.num]],
      [dartx.drawFocusIfNeeded]: [dart.void, [dart.dynamic], [Element]],
      [dartx.fillRect]: [dart.void, [core.num, core.num, core.num, core.num]],
      [dartx.getContextAttributes]: [Canvas2DContextAttributes, []],
      [dartx.getImageData]: [ImageData, [core.num, core.num, core.num, core.num]],
      [_getImageData_1]: [dart.dynamic, [dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic]],
      [_getLineDash]: [core.List$(core.num), []],
      [dartx.isContextLost]: [core.bool, []],
      [dartx.isPointInPath]: [core.bool, [dart.dynamic, core.num], [dart.dynamic, core.String]],
      [dartx.isPointInStroke]: [core.bool, [dart.dynamic, core.num], [core.num]],
      [dartx.measureText]: [TextMetrics, [core.String]],
      [dartx.putImageData]: [dart.void, [ImageData, core.num, core.num], [core.num, core.num, core.num, core.num]],
      [_putImageData_1]: [dart.void, [dart.dynamic, dart.dynamic, dart.dynamic]],
      [_putImageData_2]: [dart.void, [dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic]],
      [dartx.removeHitRegion]: [dart.void, [core.String]],
      [dartx.resetTransform]: [dart.void, []],
      [dartx.restore]: [dart.void, []],
      [dartx.rotate]: [dart.void, [core.num]],
      [dartx.save]: [dart.void, []],
      [dartx.scale]: [dart.void, [core.num, core.num]],
      [dartx.scrollPathIntoView]: [dart.void, [], [Path2D]],
      [dartx.setTransform]: [dart.void, [core.num, core.num, core.num, core.num, core.num, core.num]],
      [dartx.stroke]: [dart.void, [], [Path2D]],
      [dartx.strokeRect]: [dart.void, [core.num, core.num, core.num, core.num]],
      [dartx.strokeText]: [dart.void, [core.String, core.num, core.num], [core.num]],
      [dartx.transform]: [dart.void, [core.num, core.num, core.num, core.num, core.num, core.num]],
      [dartx.translate]: [dart.void, [core.num, core.num]],
      [_arc]: [dart.void, [core.num, core.num, core.num, core.num, core.num, core.bool]],
      [dartx.arcTo]: [dart.void, [core.num, core.num, core.num, core.num, core.num]],
      [dartx.bezierCurveTo]: [dart.void, [core.num, core.num, core.num, core.num, core.num, core.num]],
      [dartx.closePath]: [dart.void, []],
      [dartx.ellipse]: [dart.void, [core.num, core.num, core.num, core.num, core.num, core.num, core.num, core.bool]],
      [dartx.lineTo]: [dart.void, [core.num, core.num]],
      [dartx.moveTo]: [dart.void, [core.num, core.num]],
      [dartx.quadraticCurveTo]: [dart.void, [core.num, core.num, core.num, core.num]],
      [dartx.rect]: [dart.void, [core.num, core.num, core.num, core.num]],
      [dartx.setFillColorRgb]: [dart.void, [core.int, core.int, core.int], [core.num]],
      [dartx.setFillColorHsl]: [dart.void, [core.int, core.num, core.num], [core.num]],
      [dartx.setStrokeColorRgb]: [dart.void, [core.int, core.int, core.int], [core.num]],
      [dartx.setStrokeColorHsl]: [dart.void, [core.int, core.num, core.num], [core.num]],
      [dartx.arc]: [dart.void, [core.num, core.num, core.num, core.num, core.num], [core.bool]],
      [dartx.drawImageToRect]: [dart.void, [CanvasImageSource, math.Rectangle], {sourceRect: math.Rectangle}],
      [dartx.drawImage]: [dart.void, [CanvasImageSource, core.num, core.num]],
      [dartx.drawImageScaled]: [dart.void, [CanvasImageSource, core.num, core.num, core.num, core.num]],
      [dartx.drawImageScaledFromSource]: [dart.void, [CanvasImageSource, core.num, core.num, core.num, core.num, core.num, core.num, core.num, core.num]],
      [dartx.getLineDash]: [core.List$(core.num), []],
      [dartx.setLineDash]: [dart.void, [core.List$(core.num)]],
      [dartx.fillText]: [dart.void, [core.String, core.num, core.num], [core.num]],
      [dartx.fill]: [dart.void, [], [core.String]]
    })
  });
  CanvasRenderingContext2D[dart.metadata] = () => [dart.const(new _metadata.DomName('CanvasRenderingContext2D')), dart.const(new _js_helper.Native("CanvasRenderingContext2D"))];
  dart.registerExtension(dart.global.CanvasRenderingContext2D, CanvasRenderingContext2D);
  dart.defineExtensionNames([
    'nextElementSibling',
    'previousElementSibling'
  ]);
  class ChildNode extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.nextElementSibling]() {
      return this.nextElementSibling;
    }
    get [dartx.previousElementSibling]() {
      return this.previousElementSibling;
    }
  }
  dart.setSignature(ChildNode, {
    constructors: () => ({_: [ChildNode, []]})
  });
  ChildNode[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('ChildNode')), dart.const(new _metadata.Experimental())];
  dart.defineExtensionNames([
    'id'
  ]);
  class GeofencingRegion extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.id]() {
      return this.id;
    }
  }
  dart.setSignature(GeofencingRegion, {
    constructors: () => ({_: [GeofencingRegion, []]})
  });
  GeofencingRegion[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('GeofencingRegion')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("GeofencingRegion"))];
  dart.registerExtension(dart.global.GeofencingRegion, GeofencingRegion);
  dart.defineExtensionNames([
    'latitude',
    'longitude',
    'radius'
  ]);
  class CircularGeofencingRegion extends GeofencingRegion {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new(init) {
      let init_1 = html_common.convertDartToNative_Dictionary(init);
      return CircularGeofencingRegion._create_1(init_1);
    }
    static _create_1(init) {
      return dart.as(new CircularGeofencingRegion(init), CircularGeofencingRegion);
    }
    get [dartx.latitude]() {
      return this.latitude;
    }
    get [dartx.longitude]() {
      return this.longitude;
    }
    get [dartx.radius]() {
      return this.radius;
    }
  }
  dart.setSignature(CircularGeofencingRegion, {
    constructors: () => ({
      _: [CircularGeofencingRegion, []],
      new: [CircularGeofencingRegion, [core.Map]]
    }),
    statics: () => ({_create_1: [CircularGeofencingRegion, [dart.dynamic]]}),
    names: ['_create_1']
  });
  CircularGeofencingRegion[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('CircularGeofencingRegion')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("CircularGeofencingRegion"))];
  CircularGeofencingRegion.MAX_RADIUS = 100.0;
  CircularGeofencingRegion.MIN_RADIUS = 1.0;
  dart.registerExtension(dart.global.CircularGeofencingRegion, CircularGeofencingRegion);
  dart.defineExtensionNames([
    'code',
    'reason',
    'wasClean'
  ]);
  class CloseEvent extends Event {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.code]() {
      return this.code;
    }
    get [dartx.reason]() {
      return this.reason;
    }
    get [dartx.wasClean]() {
      return this.wasClean;
    }
  }
  dart.setSignature(CloseEvent, {
    constructors: () => ({_: [CloseEvent, []]})
  });
  CloseEvent[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('CloseEvent')), dart.const(new _js_helper.Native("CloseEvent"))];
  dart.registerExtension(dart.global.CloseEvent, CloseEvent);
  class Comment extends CharacterData {
    static new(data) {
      if (data === void 0) data = null;
      if (data != null) {
        return dart.as(exports.document.createComment(data), Comment);
      }
      return dart.as(exports.document.createComment(""), Comment);
    }
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
  }
  dart.setSignature(Comment, {
    constructors: () => ({
      new: [Comment, [], [core.String]],
      _: [Comment, []]
    })
  });
  Comment[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('Comment')), dart.const(new _js_helper.Native("Comment"))];
  dart.registerExtension(dart.global.Comment, Comment);
  const _initUIEvent = Symbol('_initUIEvent');
  const _charCode = Symbol('_charCode');
  const _keyCode = Symbol('_keyCode');
  const _layerX = Symbol('_layerX');
  const _layerY = Symbol('_layerY');
  const _pageX = Symbol('_pageX');
  const _pageY = Symbol('_pageY');
  const _get_view = Symbol('_get_view');
  dart.defineExtensionNames([
    'view',
    'layer',
    'page',
    'detail',
    'which'
  ]);
  class UIEvent extends Event {
    static new(type, opts) {
      let view = opts && 'view' in opts ? opts.view : null;
      let detail = opts && 'detail' in opts ? opts.detail : 0;
      let canBubble = opts && 'canBubble' in opts ? opts.canBubble : true;
      let cancelable = opts && 'cancelable' in opts ? opts.cancelable : true;
      if (view == null) {
        view = exports.window;
      }
      let e = exports.document[_createEvent]("UIEvent");
      dart.dcall(e[_initUIEvent], type, canBubble, cancelable, view, detail);
      return dart.as(e, UIEvent);
    }
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [_charCode]() {
      return this.charCode;
    }
    get [dartx.detail]() {
      return this.detail;
    }
    get [_keyCode]() {
      return this.keyCode;
    }
    get [_layerX]() {
      return this.layerX;
    }
    get [_layerY]() {
      return this.layerY;
    }
    get [_pageX]() {
      return this.pageX;
    }
    get [_pageY]() {
      return this.pageY;
    }
    get [dartx.view]() {
      return _convertNativeToDart_Window(this[_get_view]);
    }
    get [_get_view]() {
      return this.view;
    }
    get [dartx.which]() {
      return this.which;
    }
    [_initUIEvent](type, canBubble, cancelable, view, detail) {
      return this.initUIEvent(type, canBubble, cancelable, view, detail);
    }
    get [dartx.layer]() {
      return new math.Point(this[_layerX], this[_layerY]);
    }
    get [dartx.page]() {
      return new math.Point(this[_pageX], this[_pageY]);
    }
  }
  dart.setSignature(UIEvent, {
    constructors: () => ({
      new: [UIEvent, [core.String], {view: Window, detail: core.int, canBubble: core.bool, cancelable: core.bool}],
      _: [UIEvent, []]
    }),
    methods: () => ({[_initUIEvent]: [dart.void, [core.String, core.bool, core.bool, Window, core.int]]})
  });
  UIEvent[dart.metadata] = () => [dart.const(new _metadata.DomName('UIEvent')), dart.const(new _js_helper.Native("UIEvent"))];
  dart.registerExtension(dart.global.UIEvent, UIEvent);
  const _initCompositionEvent = Symbol('_initCompositionEvent');
  dart.defineExtensionNames([
    'getSegments',
    'activeSegmentEnd',
    'activeSegmentStart',
    'data'
  ]);
  class CompositionEvent extends UIEvent {
    static new(type, opts) {
      let canBubble = opts && 'canBubble' in opts ? opts.canBubble : false;
      let cancelable = opts && 'cancelable' in opts ? opts.cancelable : false;
      let view = opts && 'view' in opts ? opts.view : null;
      let data = opts && 'data' in opts ? opts.data : null;
      let locale = opts && 'locale' in opts ? opts.locale : null;
      if (view == null) {
        view = exports.window;
      }
      let e = exports.document[_createEvent]("CompositionEvent");
      if (dart.notNull(html_common.Device.isFirefox)) {
        e.initCompositionEvent(type, canBubble, cancelable, view, data, locale);
      } else {
        dart.dcall(e[_initCompositionEvent], type, canBubble, cancelable, view, data);
      }
      return dart.as(e, CompositionEvent);
    }
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.activeSegmentEnd]() {
      return this.activeSegmentEnd;
    }
    get [dartx.activeSegmentStart]() {
      return this.activeSegmentStart;
    }
    get [dartx.data]() {
      return this.data;
    }
    [dartx.getSegments]() {
      return this.getSegments();
    }
    [_initCompositionEvent](typeArg, canBubbleArg, cancelableArg, viewArg, dataArg) {
      return this.initCompositionEvent(typeArg, canBubbleArg, cancelableArg, viewArg, dataArg);
    }
  }
  dart.setSignature(CompositionEvent, {
    constructors: () => ({
      new: [CompositionEvent, [core.String], {canBubble: core.bool, cancelable: core.bool, view: Window, data: core.String, locale: core.String}],
      _: [CompositionEvent, []]
    }),
    methods: () => ({
      [dartx.getSegments]: [core.List$(core.int), []],
      [_initCompositionEvent]: [dart.void, [core.String, core.bool, core.bool, Window, core.String]]
    })
  });
  CompositionEvent[dart.metadata] = () => [dart.const(new _metadata.DomName('CompositionEvent')), dart.const(new _js_helper.Native("CompositionEvent"))];
  dart.registerExtension(dart.global.CompositionEvent, CompositionEvent);
  const _isConsoleDefined = Symbol('_isConsoleDefined');
  class Console extends core.Object {
    _safe() {
    }
    get [_isConsoleDefined]() {
      return typeof console != "undefined";
    }
    get memory() {
      return dart.as(dart.notNull(this[_isConsoleDefined]) ? console.memory : null, MemoryInfo);
    }
    assertCondition(condition, arg) {
      return dart.notNull(this[_isConsoleDefined]) ? console.assertCondition(condition, arg) : null;
    }
    clear(arg) {
      return dart.notNull(this[_isConsoleDefined]) ? console.clear(arg) : null;
    }
    count(arg) {
      return dart.notNull(this[_isConsoleDefined]) ? console.count(arg) : null;
    }
    debug(arg) {
      return dart.notNull(this[_isConsoleDefined]) ? console.debug(arg) : null;
    }
    dir(arg) {
      return dart.notNull(this[_isConsoleDefined]) ? console.dir(arg) : null;
    }
    dirxml(arg) {
      return dart.notNull(this[_isConsoleDefined]) ? console.dirxml(arg) : null;
    }
    error(arg) {
      return dart.notNull(this[_isConsoleDefined]) ? console.error(arg) : null;
    }
    group(arg) {
      return dart.notNull(this[_isConsoleDefined]) ? console.group(arg) : null;
    }
    groupCollapsed(arg) {
      return dart.notNull(this[_isConsoleDefined]) ? console.groupCollapsed(arg) : null;
    }
    groupEnd() {
      return dart.notNull(this[_isConsoleDefined]) ? console.groupEnd() : null;
    }
    info(arg) {
      return dart.notNull(this[_isConsoleDefined]) ? console.info(arg) : null;
    }
    log(arg) {
      return dart.notNull(this[_isConsoleDefined]) ? console.log(arg) : null;
    }
    markTimeline(arg) {
      return dart.notNull(this[_isConsoleDefined]) ? console.markTimeline(arg) : null;
    }
    profile(title) {
      return dart.notNull(this[_isConsoleDefined]) ? console.profile(title) : null;
    }
    profileEnd(title) {
      return dart.notNull(this[_isConsoleDefined]) ? console.profileEnd(title) : null;
    }
    table(arg) {
      return dart.notNull(this[_isConsoleDefined]) ? console.table(arg) : null;
    }
    time(title) {
      return dart.notNull(this[_isConsoleDefined]) ? console.time(title) : null;
    }
    timeEnd(title) {
      return dart.notNull(this[_isConsoleDefined]) ? console.timeEnd(title) : null;
    }
    timeStamp(arg) {
      return dart.notNull(this[_isConsoleDefined]) ? console.timeStamp(arg) : null;
    }
    trace(arg) {
      return dart.notNull(this[_isConsoleDefined]) ? console.trace(arg) : null;
    }
    warn(arg) {
      return dart.notNull(this[_isConsoleDefined]) ? console.warn(arg) : null;
    }
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
  }
  dart.defineNamedConstructor(Console, '_safe');
  dart.setSignature(Console, {
    constructors: () => ({
      _safe: [Console, []],
      _: [Console, []]
    }),
    methods: () => ({
      assertCondition: [dart.void, [core.bool, core.Object]],
      clear: [dart.void, [core.Object]],
      count: [dart.void, [core.Object]],
      debug: [dart.void, [core.Object]],
      dir: [dart.void, [core.Object]],
      dirxml: [dart.void, [core.Object]],
      error: [dart.void, [core.Object]],
      group: [dart.void, [core.Object]],
      groupCollapsed: [dart.void, [core.Object]],
      groupEnd: [dart.void, []],
      info: [dart.void, [core.Object]],
      log: [dart.void, [core.Object]],
      markTimeline: [dart.void, [core.Object]],
      profile: [dart.void, [core.String]],
      profileEnd: [dart.void, [core.String]],
      table: [dart.void, [core.Object]],
      time: [dart.void, [core.String]],
      timeEnd: [dart.void, [core.String]],
      timeStamp: [dart.void, [core.Object]],
      trace: [dart.void, [core.Object]],
      warn: [dart.void, [core.Object]]
    })
  });
  Console[dart.metadata] = () => [dart.const(new _metadata.DomName('Console'))];
  dart.defineLazyProperties(Console, {
    get _safeConsole() {
      return dart.const(new Console._safe());
    }
  });
  dart.defineExtensionNames([
    'timeline',
    'timelineEnd'
  ]);
  class ConsoleBase extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    [dartx.timeline](title) {
      return this.timeline(title);
    }
    [dartx.timelineEnd](title) {
      return this.timelineEnd(title);
    }
  }
  dart.setSignature(ConsoleBase, {
    constructors: () => ({_: [ConsoleBase, []]}),
    methods: () => ({
      [dartx.timeline]: [dart.void, [core.String]],
      [dartx.timelineEnd]: [dart.void, [core.String]]
    })
  });
  ConsoleBase[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('ConsoleBase')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("ConsoleBase"))];
  dart.registerExtension(dart.global.ConsoleBase, ConsoleBase);
  dart.defineExtensionNames([
    'getDistributedNodes',
    'select'
  ]);
  class ContentElement extends HtmlElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return dart.as(exports.document[dartx.createElement]("content"), ContentElement);
    }
    created() {
      this[dartx.select] = null;
      super.created();
    }
    static get supported() {
      return Element.isTagSupported('content');
    }
    get [dartx.select]() {
      return this.select;
    }
    set [dartx.select](value) {
      this.select = value;
    }
    [dartx.getDistributedNodes]() {
      return this.getDistributedNodes();
    }
  }
  dart.defineNamedConstructor(ContentElement, 'created');
  dart.setSignature(ContentElement, {
    constructors: () => ({
      _: [ContentElement, []],
      new: [ContentElement, []],
      created: [ContentElement, []]
    }),
    methods: () => ({[dartx.getDistributedNodes]: [core.List$(Node), []]})
  });
  ContentElement[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('HTMLContentElement')), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.CHROME, '26')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("HTMLContentElement"))];
  dart.registerExtension(dart.global.HTMLContentElement, ContentElement);
  dart.defineExtensionNames([
    'accuracy',
    'altitude',
    'altitudeAccuracy',
    'heading',
    'latitude',
    'longitude',
    'speed'
  ]);
  class Coordinates extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.accuracy]() {
      return this.accuracy;
    }
    get [dartx.altitude]() {
      return this.altitude;
    }
    get [dartx.altitudeAccuracy]() {
      return this.altitudeAccuracy;
    }
    get [dartx.heading]() {
      return this.heading;
    }
    get [dartx.latitude]() {
      return this.latitude;
    }
    get [dartx.longitude]() {
      return this.longitude;
    }
    get [dartx.speed]() {
      return this.speed;
    }
  }
  dart.setSignature(Coordinates, {
    constructors: () => ({_: [Coordinates, []]})
  });
  Coordinates[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('Coordinates')), dart.const(new _js_helper.Native("Coordinates"))];
  dart.registerExtension(dart.global.Coordinates, Coordinates);
  dart.defineExtensionNames([
    'avatarUrl',
    'id',
    'name'
  ]);
  class Credential extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.avatarUrl]() {
      return this.avatarURL;
    }
    get [dartx.id]() {
      return this.id;
    }
    get [dartx.name]() {
      return this.name;
    }
  }
  dart.setSignature(Credential, {
    constructors: () => ({_: [Credential, []]})
  });
  Credential[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('Credential')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("Credential"))];
  dart.registerExtension(dart.global.Credential, Credential);
  const _request_1 = Symbol('_request_1');
  const _request_2 = Symbol('_request_2');
  dart.defineExtensionNames([
    'notifyFailedSignIn',
    'notifySignedIn',
    'notifySignedOut',
    'request'
  ]);
  class CredentialsContainer extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    [dartx.notifyFailedSignIn](credential) {
      return this.notifyFailedSignIn(credential);
    }
    [dartx.notifySignedIn](credential) {
      return this.notifySignedIn(credential);
    }
    [dartx.notifySignedOut]() {
      return this.notifySignedOut();
    }
    [dartx.request](options) {
      if (options === void 0) options = null;
      if (options != null) {
        let options_1 = html_common.convertDartToNative_Dictionary(options);
        return this[_request_1](options_1);
      }
      return this[_request_2]();
    }
    [_request_1](options) {
      return this.request(options);
    }
    [_request_2]() {
      return this.request();
    }
  }
  dart.setSignature(CredentialsContainer, {
    constructors: () => ({_: [CredentialsContainer, []]}),
    methods: () => ({
      [dartx.notifyFailedSignIn]: [async.Future, [Credential]],
      [dartx.notifySignedIn]: [async.Future, [Credential]],
      [dartx.notifySignedOut]: [async.Future, []],
      [dartx.request]: [async.Future, [], [core.Map]],
      [_request_1]: [async.Future, [dart.dynamic]],
      [_request_2]: [async.Future, []]
    })
  });
  CredentialsContainer[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('CredentialsContainer')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("CredentialsContainer"))];
  dart.registerExtension(dart.global.CredentialsContainer, CredentialsContainer);
  const _getRandomValues = Symbol('_getRandomValues');
  dart.defineExtensionNames([
    'getRandomValues',
    'subtle'
  ]);
  class Crypto extends _interceptors.Interceptor {
    [dartx.getRandomValues](array) {
      return this[_getRandomValues](array);
    }
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static get supported() {
      return !!(window.crypto && window.crypto.getRandomValues);
    }
    get [dartx.subtle]() {
      return this.subtle;
    }
    [_getRandomValues](array) {
      return this.getRandomValues(array);
    }
  }
  dart.setSignature(Crypto, {
    constructors: () => ({_: [Crypto, []]}),
    methods: () => ({
      [dartx.getRandomValues]: [typed_data.TypedData, [typed_data.TypedData]],
      [_getRandomValues]: [typed_data.TypedData, [typed_data.TypedData]]
    })
  });
  Crypto[dart.metadata] = () => [dart.const(new _metadata.DomName('Crypto')), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.CHROME)), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.SAFARI)), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("Crypto"))];
  dart.registerExtension(dart.global.Crypto, Crypto);
  dart.defineExtensionNames([
    'algorithm',
    'extractable',
    'type',
    'usages'
  ]);
  class CryptoKey extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.algorithm]() {
      return this.algorithm;
    }
    get [dartx.extractable]() {
      return this.extractable;
    }
    get [dartx.type]() {
      return this.type;
    }
    get [dartx.usages]() {
      return this.usages;
    }
  }
  dart.setSignature(CryptoKey, {
    constructors: () => ({_: [CryptoKey, []]})
  });
  CryptoKey[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('CryptoKey')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("CryptoKey"))];
  dart.registerExtension(dart.global.CryptoKey, CryptoKey);
  dart.defineExtensionNames([
    'supports',
    'supportsCondition'
  ]);
  class Css extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    [dartx.supports](property, value) {
      return this.supports(property, value);
    }
    [dartx.supportsCondition](conditionText) {
      return this.supports(conditionText);
    }
  }
  dart.setSignature(Css, {
    constructors: () => ({_: [Css, []]}),
    methods: () => ({
      [dartx.supports]: [core.bool, [core.String, core.String]],
      [dartx.supportsCondition]: [core.bool, [core.String]]
    })
  });
  Css[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('CSS')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("CSS"))];
  dart.registerExtension(dart.global.CSS, Css);
  dart.defineExtensionNames([
    'cssText',
    'parentRule',
    'parentStyleSheet',
    'type'
  ]);
  class CssRule extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.cssText]() {
      return this.cssText;
    }
    set [dartx.cssText](value) {
      this.cssText = value;
    }
    get [dartx.parentRule]() {
      return this.parentRule;
    }
    get [dartx.parentStyleSheet]() {
      return this.parentStyleSheet;
    }
    get [dartx.type]() {
      return this.type;
    }
  }
  dart.setSignature(CssRule, {
    constructors: () => ({_: [CssRule, []]})
  });
  CssRule[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('CSSRule')), dart.const(new _js_helper.Native("CSSRule"))];
  CssRule.CHARSET_RULE = 2;
  CssRule.FONT_FACE_RULE = 5;
  CssRule.IMPORT_RULE = 3;
  CssRule.KEYFRAMES_RULE = 7;
  CssRule.KEYFRAME_RULE = 8;
  CssRule.MEDIA_RULE = 4;
  CssRule.PAGE_RULE = 6;
  CssRule.STYLE_RULE = 1;
  CssRule.SUPPORTS_RULE = 12;
  CssRule.VIEWPORT_RULE = 15;
  CssRule.WEBKIT_FILTER_RULE = 17;
  CssRule.WEBKIT_KEYFRAMES_RULE = 7;
  CssRule.WEBKIT_KEYFRAME_RULE = 8;
  dart.registerExtension(dart.global.CSSRule, CssRule);
  dart.defineExtensionNames([
    'encoding'
  ]);
  class CssCharsetRule extends CssRule {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.encoding]() {
      return this.encoding;
    }
    set [dartx.encoding](value) {
      this.encoding = value;
    }
  }
  dart.setSignature(CssCharsetRule, {
    constructors: () => ({_: [CssCharsetRule, []]})
  });
  CssCharsetRule[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('CSSCharsetRule')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("CSSCharsetRule"))];
  dart.registerExtension(dart.global.CSSCharsetRule, CssCharsetRule);
  dart.defineExtensionNames([
    'style'
  ]);
  class CssFilterRule extends CssRule {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.style]() {
      return this.style;
    }
  }
  dart.setSignature(CssFilterRule, {
    constructors: () => ({_: [CssFilterRule, []]})
  });
  CssFilterRule[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('WebKitCSSFilterRule')), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.CHROME)), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.SAFARI)), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("WebKitCSSFilterRule"))];
  dart.registerExtension(dart.global.WebKitCSSFilterRule, CssFilterRule);
  dart.defineExtensionNames([
    'style'
  ]);
  class CssFontFaceRule extends CssRule {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.style]() {
      return this.style;
    }
  }
  dart.setSignature(CssFontFaceRule, {
    constructors: () => ({_: [CssFontFaceRule, []]})
  });
  CssFontFaceRule[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('CSSFontFaceRule')), dart.const(new _js_helper.Native("CSSFontFaceRule"))];
  dart.registerExtension(dart.global.CSSFontFaceRule, CssFontFaceRule);
  dart.defineExtensionNames([
    'href',
    'media',
    'styleSheet'
  ]);
  class CssImportRule extends CssRule {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.href]() {
      return this.href;
    }
    get [dartx.media]() {
      return this.media;
    }
    get [dartx.styleSheet]() {
      return this.styleSheet;
    }
  }
  dart.setSignature(CssImportRule, {
    constructors: () => ({_: [CssImportRule, []]})
  });
  CssImportRule[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('CSSImportRule')), dart.const(new _js_helper.Native("CSSImportRule"))];
  dart.registerExtension(dart.global.CSSImportRule, CssImportRule);
  dart.defineExtensionNames([
    'keyText',
    'style'
  ]);
  class CssKeyframeRule extends CssRule {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.keyText]() {
      return this.keyText;
    }
    set [dartx.keyText](value) {
      this.keyText = value;
    }
    get [dartx.style]() {
      return this.style;
    }
  }
  dart.setSignature(CssKeyframeRule, {
    constructors: () => ({_: [CssKeyframeRule, []]})
  });
  CssKeyframeRule[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('CSSKeyframeRule')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("CSSKeyframeRule,MozCSSKeyframeRule,WebKitCSSKeyframeRule"))];
  dart.registerExtension(dart.global.CSSKeyframeRule, CssKeyframeRule);
  dart.defineExtensionNames([
    'deleteRule',
    'findRule',
    'appendRule',
    'cssRules',
    'name'
  ]);
  class CssKeyframesRule extends CssRule {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.cssRules]() {
      return this.cssRules;
    }
    get [dartx.name]() {
      return this.name;
    }
    set [dartx.name](value) {
      this.name = value;
    }
    [__getter__](index) {
      return this.__getter__(index);
    }
    [dartx.deleteRule](key) {
      return this.deleteRule(key);
    }
    [dartx.findRule](key) {
      return this.findRule(key);
    }
    [dartx.appendRule](rule) {
      return this.insertRule(rule);
    }
  }
  dart.setSignature(CssKeyframesRule, {
    constructors: () => ({_: [CssKeyframesRule, []]}),
    methods: () => ({
      [__getter__]: [CssKeyframeRule, [core.int]],
      [dartx.deleteRule]: [dart.void, [core.String]],
      [dartx.findRule]: [CssKeyframeRule, [core.String]],
      [dartx.appendRule]: [dart.void, [core.String]]
    })
  });
  CssKeyframesRule[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('CSSKeyframesRule')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("CSSKeyframesRule,MozCSSKeyframesRule,WebKitCSSKeyframesRule"))];
  dart.registerExtension(dart.global.CSSKeyframesRule, CssKeyframesRule);
  dart.defineExtensionNames([
    'deleteRule',
    'insertRule',
    'cssRules',
    'media'
  ]);
  class CssMediaRule extends CssRule {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.cssRules]() {
      return this.cssRules;
    }
    get [dartx.media]() {
      return this.media;
    }
    [dartx.deleteRule](index) {
      return this.deleteRule(index);
    }
    [dartx.insertRule](rule, index) {
      return this.insertRule(rule, index);
    }
  }
  dart.setSignature(CssMediaRule, {
    constructors: () => ({_: [CssMediaRule, []]}),
    methods: () => ({
      [dartx.deleteRule]: [dart.void, [core.int]],
      [dartx.insertRule]: [core.int, [core.String, core.int]]
    })
  });
  CssMediaRule[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('CSSMediaRule')), dart.const(new _js_helper.Native("CSSMediaRule"))];
  dart.registerExtension(dart.global.CSSMediaRule, CssMediaRule);
  dart.defineExtensionNames([
    'selectorText',
    'style'
  ]);
  class CssPageRule extends CssRule {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.selectorText]() {
      return this.selectorText;
    }
    set [dartx.selectorText](value) {
      this.selectorText = value;
    }
    get [dartx.style]() {
      return this.style;
    }
  }
  dart.setSignature(CssPageRule, {
    constructors: () => ({_: [CssPageRule, []]})
  });
  CssPageRule[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('CSSPageRule')), dart.const(new _js_helper.Native("CSSPageRule"))];
  dart.registerExtension(dart.global.CSSPageRule, CssPageRule);
  dart.defineExtensionNames([
    'alignContent',
    'alignContent',
    'alignItems',
    'alignItems',
    'alignSelf',
    'alignSelf',
    'animation',
    'animation',
    'animationDelay',
    'animationDelay',
    'animationDirection',
    'animationDirection',
    'animationDuration',
    'animationDuration',
    'animationFillMode',
    'animationFillMode',
    'animationIterationCount',
    'animationIterationCount',
    'animationName',
    'animationName',
    'animationPlayState',
    'animationPlayState',
    'animationTimingFunction',
    'animationTimingFunction',
    'appRegion',
    'appRegion',
    'appearance',
    'appearance',
    'aspectRatio',
    'aspectRatio',
    'backfaceVisibility',
    'backfaceVisibility',
    'background',
    'background',
    'backgroundAttachment',
    'backgroundAttachment',
    'backgroundBlendMode',
    'backgroundBlendMode',
    'backgroundClip',
    'backgroundClip',
    'backgroundColor',
    'backgroundColor',
    'backgroundComposite',
    'backgroundComposite',
    'backgroundImage',
    'backgroundImage',
    'backgroundOrigin',
    'backgroundOrigin',
    'backgroundPosition',
    'backgroundPosition',
    'backgroundPositionX',
    'backgroundPositionX',
    'backgroundPositionY',
    'backgroundPositionY',
    'backgroundRepeat',
    'backgroundRepeat',
    'backgroundRepeatX',
    'backgroundRepeatX',
    'backgroundRepeatY',
    'backgroundRepeatY',
    'backgroundSize',
    'backgroundSize',
    'border',
    'border',
    'borderAfter',
    'borderAfter',
    'borderAfterColor',
    'borderAfterColor',
    'borderAfterStyle',
    'borderAfterStyle',
    'borderAfterWidth',
    'borderAfterWidth',
    'borderBefore',
    'borderBefore',
    'borderBeforeColor',
    'borderBeforeColor',
    'borderBeforeStyle',
    'borderBeforeStyle',
    'borderBeforeWidth',
    'borderBeforeWidth',
    'borderBottom',
    'borderBottom',
    'borderBottomColor',
    'borderBottomColor',
    'borderBottomLeftRadius',
    'borderBottomLeftRadius',
    'borderBottomRightRadius',
    'borderBottomRightRadius',
    'borderBottomStyle',
    'borderBottomStyle',
    'borderBottomWidth',
    'borderBottomWidth',
    'borderCollapse',
    'borderCollapse',
    'borderColor',
    'borderColor',
    'borderEnd',
    'borderEnd',
    'borderEndColor',
    'borderEndColor',
    'borderEndStyle',
    'borderEndStyle',
    'borderEndWidth',
    'borderEndWidth',
    'borderFit',
    'borderFit',
    'borderHorizontalSpacing',
    'borderHorizontalSpacing',
    'borderImage',
    'borderImage',
    'borderImageOutset',
    'borderImageOutset',
    'borderImageRepeat',
    'borderImageRepeat',
    'borderImageSlice',
    'borderImageSlice',
    'borderImageSource',
    'borderImageSource',
    'borderImageWidth',
    'borderImageWidth',
    'borderLeft',
    'borderLeft',
    'borderLeftColor',
    'borderLeftColor',
    'borderLeftStyle',
    'borderLeftStyle',
    'borderLeftWidth',
    'borderLeftWidth',
    'borderRadius',
    'borderRadius',
    'borderRight',
    'borderRight',
    'borderRightColor',
    'borderRightColor',
    'borderRightStyle',
    'borderRightStyle',
    'borderRightWidth',
    'borderRightWidth',
    'borderSpacing',
    'borderSpacing',
    'borderStart',
    'borderStart',
    'borderStartColor',
    'borderStartColor',
    'borderStartStyle',
    'borderStartStyle',
    'borderStartWidth',
    'borderStartWidth',
    'borderStyle',
    'borderStyle',
    'borderTop',
    'borderTop',
    'borderTopColor',
    'borderTopColor',
    'borderTopLeftRadius',
    'borderTopLeftRadius',
    'borderTopRightRadius',
    'borderTopRightRadius',
    'borderTopStyle',
    'borderTopStyle',
    'borderTopWidth',
    'borderTopWidth',
    'borderVerticalSpacing',
    'borderVerticalSpacing',
    'borderWidth',
    'borderWidth',
    'bottom',
    'bottom',
    'boxAlign',
    'boxAlign',
    'boxDecorationBreak',
    'boxDecorationBreak',
    'boxDirection',
    'boxDirection',
    'boxFlex',
    'boxFlex',
    'boxFlexGroup',
    'boxFlexGroup',
    'boxLines',
    'boxLines',
    'boxOrdinalGroup',
    'boxOrdinalGroup',
    'boxOrient',
    'boxOrient',
    'boxPack',
    'boxPack',
    'boxReflect',
    'boxReflect',
    'boxShadow',
    'boxShadow',
    'boxSizing',
    'boxSizing',
    'captionSide',
    'captionSide',
    'clear',
    'clear',
    'clip',
    'clip',
    'clipPath',
    'clipPath',
    'color',
    'color',
    'columnBreakAfter',
    'columnBreakAfter',
    'columnBreakBefore',
    'columnBreakBefore',
    'columnBreakInside',
    'columnBreakInside',
    'columnCount',
    'columnCount',
    'columnFill',
    'columnFill',
    'columnGap',
    'columnGap',
    'columnRule',
    'columnRule',
    'columnRuleColor',
    'columnRuleColor',
    'columnRuleStyle',
    'columnRuleStyle',
    'columnRuleWidth',
    'columnRuleWidth',
    'columnSpan',
    'columnSpan',
    'columnWidth',
    'columnWidth',
    'columns',
    'columns',
    'content',
    'content',
    'counterIncrement',
    'counterIncrement',
    'counterReset',
    'counterReset',
    'cursor',
    'cursor',
    'direction',
    'direction',
    'display',
    'display',
    'emptyCells',
    'emptyCells',
    'filter',
    'filter',
    'flex',
    'flex',
    'flexBasis',
    'flexBasis',
    'flexDirection',
    'flexDirection',
    'flexFlow',
    'flexFlow',
    'flexGrow',
    'flexGrow',
    'flexShrink',
    'flexShrink',
    'flexWrap',
    'flexWrap',
    'float',
    'float',
    'font',
    'font',
    'fontFamily',
    'fontFamily',
    'fontFeatureSettings',
    'fontFeatureSettings',
    'fontKerning',
    'fontKerning',
    'fontSize',
    'fontSize',
    'fontSizeDelta',
    'fontSizeDelta',
    'fontSmoothing',
    'fontSmoothing',
    'fontStretch',
    'fontStretch',
    'fontStyle',
    'fontStyle',
    'fontVariant',
    'fontVariant',
    'fontVariantLigatures',
    'fontVariantLigatures',
    'fontWeight',
    'fontWeight',
    'grid',
    'grid',
    'gridArea',
    'gridArea',
    'gridAutoColumns',
    'gridAutoColumns',
    'gridAutoFlow',
    'gridAutoFlow',
    'gridAutoRows',
    'gridAutoRows',
    'gridColumn',
    'gridColumn',
    'gridColumnEnd',
    'gridColumnEnd',
    'gridColumnStart',
    'gridColumnStart',
    'gridRow',
    'gridRow',
    'gridRowEnd',
    'gridRowEnd',
    'gridRowStart',
    'gridRowStart',
    'gridTemplate',
    'gridTemplate',
    'gridTemplateAreas',
    'gridTemplateAreas',
    'gridTemplateColumns',
    'gridTemplateColumns',
    'gridTemplateRows',
    'gridTemplateRows',
    'height',
    'height',
    'highlight',
    'highlight',
    'hyphenateCharacter',
    'hyphenateCharacter',
    'imageRendering',
    'imageRendering',
    'isolation',
    'isolation',
    'justifyContent',
    'justifyContent',
    'justifySelf',
    'justifySelf',
    'left',
    'left',
    'letterSpacing',
    'letterSpacing',
    'lineBoxContain',
    'lineBoxContain',
    'lineBreak',
    'lineBreak',
    'lineClamp',
    'lineClamp',
    'lineHeight',
    'lineHeight',
    'listStyle',
    'listStyle',
    'listStyleImage',
    'listStyleImage',
    'listStylePosition',
    'listStylePosition',
    'listStyleType',
    'listStyleType',
    'locale',
    'locale',
    'logicalHeight',
    'logicalHeight',
    'logicalWidth',
    'logicalWidth',
    'margin',
    'margin',
    'marginAfter',
    'marginAfter',
    'marginAfterCollapse',
    'marginAfterCollapse',
    'marginBefore',
    'marginBefore',
    'marginBeforeCollapse',
    'marginBeforeCollapse',
    'marginBottom',
    'marginBottom',
    'marginBottomCollapse',
    'marginBottomCollapse',
    'marginCollapse',
    'marginCollapse',
    'marginEnd',
    'marginEnd',
    'marginLeft',
    'marginLeft',
    'marginRight',
    'marginRight',
    'marginStart',
    'marginStart',
    'marginTop',
    'marginTop',
    'marginTopCollapse',
    'marginTopCollapse',
    'mask',
    'mask',
    'maskBoxImage',
    'maskBoxImage',
    'maskBoxImageOutset',
    'maskBoxImageOutset',
    'maskBoxImageRepeat',
    'maskBoxImageRepeat',
    'maskBoxImageSlice',
    'maskBoxImageSlice',
    'maskBoxImageSource',
    'maskBoxImageSource',
    'maskBoxImageWidth',
    'maskBoxImageWidth',
    'maskClip',
    'maskClip',
    'maskComposite',
    'maskComposite',
    'maskImage',
    'maskImage',
    'maskOrigin',
    'maskOrigin',
    'maskPosition',
    'maskPosition',
    'maskPositionX',
    'maskPositionX',
    'maskPositionY',
    'maskPositionY',
    'maskRepeat',
    'maskRepeat',
    'maskRepeatX',
    'maskRepeatX',
    'maskRepeatY',
    'maskRepeatY',
    'maskSize',
    'maskSize',
    'maskSourceType',
    'maskSourceType',
    'maxHeight',
    'maxHeight',
    'maxLogicalHeight',
    'maxLogicalHeight',
    'maxLogicalWidth',
    'maxLogicalWidth',
    'maxWidth',
    'maxWidth',
    'maxZoom',
    'maxZoom',
    'minHeight',
    'minHeight',
    'minLogicalHeight',
    'minLogicalHeight',
    'minLogicalWidth',
    'minLogicalWidth',
    'minWidth',
    'minWidth',
    'minZoom',
    'minZoom',
    'mixBlendMode',
    'mixBlendMode',
    'objectFit',
    'objectFit',
    'objectPosition',
    'objectPosition',
    'opacity',
    'opacity',
    'order',
    'order',
    'orientation',
    'orientation',
    'orphans',
    'orphans',
    'outline',
    'outline',
    'outlineColor',
    'outlineColor',
    'outlineOffset',
    'outlineOffset',
    'outlineStyle',
    'outlineStyle',
    'outlineWidth',
    'outlineWidth',
    'overflow',
    'overflow',
    'overflowWrap',
    'overflowWrap',
    'overflowX',
    'overflowX',
    'overflowY',
    'overflowY',
    'padding',
    'padding',
    'paddingAfter',
    'paddingAfter',
    'paddingBefore',
    'paddingBefore',
    'paddingBottom',
    'paddingBottom',
    'paddingEnd',
    'paddingEnd',
    'paddingLeft',
    'paddingLeft',
    'paddingRight',
    'paddingRight',
    'paddingStart',
    'paddingStart',
    'paddingTop',
    'paddingTop',
    'page',
    'page',
    'pageBreakAfter',
    'pageBreakAfter',
    'pageBreakBefore',
    'pageBreakBefore',
    'pageBreakInside',
    'pageBreakInside',
    'perspective',
    'perspective',
    'perspectiveOrigin',
    'perspectiveOrigin',
    'perspectiveOriginX',
    'perspectiveOriginX',
    'perspectiveOriginY',
    'perspectiveOriginY',
    'pointerEvents',
    'pointerEvents',
    'position',
    'position',
    'printColorAdjust',
    'printColorAdjust',
    'quotes',
    'quotes',
    'resize',
    'resize',
    'right',
    'right',
    'rtlOrdering',
    'rtlOrdering',
    'rubyPosition',
    'rubyPosition',
    'scrollBehavior',
    'scrollBehavior',
    'shapeImageThreshold',
    'shapeImageThreshold',
    'shapeMargin',
    'shapeMargin',
    'shapeOutside',
    'shapeOutside',
    'size',
    'size',
    'speak',
    'speak',
    'src',
    'src',
    'tabSize',
    'tabSize',
    'tableLayout',
    'tableLayout',
    'tapHighlightColor',
    'tapHighlightColor',
    'textAlign',
    'textAlign',
    'textAlignLast',
    'textAlignLast',
    'textCombine',
    'textCombine',
    'textDecoration',
    'textDecoration',
    'textDecorationColor',
    'textDecorationColor',
    'textDecorationLine',
    'textDecorationLine',
    'textDecorationStyle',
    'textDecorationStyle',
    'textDecorationsInEffect',
    'textDecorationsInEffect',
    'textEmphasis',
    'textEmphasis',
    'textEmphasisColor',
    'textEmphasisColor',
    'textEmphasisPosition',
    'textEmphasisPosition',
    'textEmphasisStyle',
    'textEmphasisStyle',
    'textFillColor',
    'textFillColor',
    'textIndent',
    'textIndent',
    'textJustify',
    'textJustify',
    'textLineThroughColor',
    'textLineThroughColor',
    'textLineThroughMode',
    'textLineThroughMode',
    'textLineThroughStyle',
    'textLineThroughStyle',
    'textLineThroughWidth',
    'textLineThroughWidth',
    'textOrientation',
    'textOrientation',
    'textOverflow',
    'textOverflow',
    'textOverlineColor',
    'textOverlineColor',
    'textOverlineMode',
    'textOverlineMode',
    'textOverlineStyle',
    'textOverlineStyle',
    'textOverlineWidth',
    'textOverlineWidth',
    'textRendering',
    'textRendering',
    'textSecurity',
    'textSecurity',
    'textShadow',
    'textShadow',
    'textStroke',
    'textStroke',
    'textStrokeColor',
    'textStrokeColor',
    'textStrokeWidth',
    'textStrokeWidth',
    'textTransform',
    'textTransform',
    'textUnderlineColor',
    'textUnderlineColor',
    'textUnderlineMode',
    'textUnderlineMode',
    'textUnderlinePosition',
    'textUnderlinePosition',
    'textUnderlineStyle',
    'textUnderlineStyle',
    'textUnderlineWidth',
    'textUnderlineWidth',
    'top',
    'top',
    'touchAction',
    'touchAction',
    'touchActionDelay',
    'touchActionDelay',
    'transform',
    'transform',
    'transformOrigin',
    'transformOrigin',
    'transformOriginX',
    'transformOriginX',
    'transformOriginY',
    'transformOriginY',
    'transformOriginZ',
    'transformOriginZ',
    'transformStyle',
    'transformStyle',
    'transition',
    'transition',
    'transitionDelay',
    'transitionDelay',
    'transitionDuration',
    'transitionDuration',
    'transitionProperty',
    'transitionProperty',
    'transitionTimingFunction',
    'transitionTimingFunction',
    'unicodeBidi',
    'unicodeBidi',
    'unicodeRange',
    'unicodeRange',
    'userDrag',
    'userDrag',
    'userModify',
    'userModify',
    'userSelect',
    'userSelect',
    'userZoom',
    'userZoom',
    'verticalAlign',
    'verticalAlign',
    'visibility',
    'visibility',
    'whiteSpace',
    'whiteSpace',
    'widows',
    'widows',
    'width',
    'width',
    'willChange',
    'willChange',
    'wordBreak',
    'wordBreak',
    'wordSpacing',
    'wordSpacing',
    'wordWrap',
    'wordWrap',
    'wrapFlow',
    'wrapFlow',
    'wrapThrough',
    'wrapThrough',
    'writingMode',
    'writingMode',
    'zIndex',
    'zIndex',
    'zoom',
    'zoom'
  ]);
  class CssStyleDeclarationBase extends core.Object {
    get [dartx.alignContent]() {
      return this[dartx.getPropertyValue]('align-content');
    }
    set [dartx.alignContent](value) {
      this[dartx.setProperty]('align-content', value, '');
    }
    get [dartx.alignItems]() {
      return this[dartx.getPropertyValue]('align-items');
    }
    set [dartx.alignItems](value) {
      this[dartx.setProperty]('align-items', value, '');
    }
    get [dartx.alignSelf]() {
      return this[dartx.getPropertyValue]('align-self');
    }
    set [dartx.alignSelf](value) {
      this[dartx.setProperty]('align-self', value, '');
    }
    get [dartx.animation]() {
      return this[dartx.getPropertyValue]('animation');
    }
    set [dartx.animation](value) {
      this[dartx.setProperty]('animation', value, '');
    }
    get [dartx.animationDelay]() {
      return this[dartx.getPropertyValue]('animation-delay');
    }
    set [dartx.animationDelay](value) {
      this[dartx.setProperty]('animation-delay', value, '');
    }
    get [dartx.animationDirection]() {
      return this[dartx.getPropertyValue]('animation-direction');
    }
    set [dartx.animationDirection](value) {
      this[dartx.setProperty]('animation-direction', value, '');
    }
    get [dartx.animationDuration]() {
      return this[dartx.getPropertyValue]('animation-duration');
    }
    set [dartx.animationDuration](value) {
      this[dartx.setProperty]('animation-duration', value, '');
    }
    get [dartx.animationFillMode]() {
      return this[dartx.getPropertyValue]('animation-fill-mode');
    }
    set [dartx.animationFillMode](value) {
      this[dartx.setProperty]('animation-fill-mode', value, '');
    }
    get [dartx.animationIterationCount]() {
      return this[dartx.getPropertyValue]('animation-iteration-count');
    }
    set [dartx.animationIterationCount](value) {
      this[dartx.setProperty]('animation-iteration-count', value, '');
    }
    get [dartx.animationName]() {
      return this[dartx.getPropertyValue]('animation-name');
    }
    set [dartx.animationName](value) {
      this[dartx.setProperty]('animation-name', value, '');
    }
    get [dartx.animationPlayState]() {
      return this[dartx.getPropertyValue]('animation-play-state');
    }
    set [dartx.animationPlayState](value) {
      this[dartx.setProperty]('animation-play-state', value, '');
    }
    get [dartx.animationTimingFunction]() {
      return this[dartx.getPropertyValue]('animation-timing-function');
    }
    set [dartx.animationTimingFunction](value) {
      this[dartx.setProperty]('animation-timing-function', value, '');
    }
    get [dartx.appRegion]() {
      return this[dartx.getPropertyValue]('app-region');
    }
    set [dartx.appRegion](value) {
      this[dartx.setProperty]('app-region', value, '');
    }
    get [dartx.appearance]() {
      return this[dartx.getPropertyValue]('appearance');
    }
    set [dartx.appearance](value) {
      this[dartx.setProperty]('appearance', value, '');
    }
    get [dartx.aspectRatio]() {
      return this[dartx.getPropertyValue]('aspect-ratio');
    }
    set [dartx.aspectRatio](value) {
      this[dartx.setProperty]('aspect-ratio', value, '');
    }
    get [dartx.backfaceVisibility]() {
      return this[dartx.getPropertyValue]('backface-visibility');
    }
    set [dartx.backfaceVisibility](value) {
      this[dartx.setProperty]('backface-visibility', value, '');
    }
    get [dartx.background]() {
      return this[dartx.getPropertyValue]('background');
    }
    set [dartx.background](value) {
      this[dartx.setProperty]('background', value, '');
    }
    get [dartx.backgroundAttachment]() {
      return this[dartx.getPropertyValue]('background-attachment');
    }
    set [dartx.backgroundAttachment](value) {
      this[dartx.setProperty]('background-attachment', value, '');
    }
    get [dartx.backgroundBlendMode]() {
      return this[dartx.getPropertyValue]('background-blend-mode');
    }
    set [dartx.backgroundBlendMode](value) {
      this[dartx.setProperty]('background-blend-mode', value, '');
    }
    get [dartx.backgroundClip]() {
      return this[dartx.getPropertyValue]('background-clip');
    }
    set [dartx.backgroundClip](value) {
      this[dartx.setProperty]('background-clip', value, '');
    }
    get [dartx.backgroundColor]() {
      return this[dartx.getPropertyValue]('background-color');
    }
    set [dartx.backgroundColor](value) {
      this[dartx.setProperty]('background-color', value, '');
    }
    get [dartx.backgroundComposite]() {
      return this[dartx.getPropertyValue]('background-composite');
    }
    set [dartx.backgroundComposite](value) {
      this[dartx.setProperty]('background-composite', value, '');
    }
    get [dartx.backgroundImage]() {
      return this[dartx.getPropertyValue]('background-image');
    }
    set [dartx.backgroundImage](value) {
      this[dartx.setProperty]('background-image', value, '');
    }
    get [dartx.backgroundOrigin]() {
      return this[dartx.getPropertyValue]('background-origin');
    }
    set [dartx.backgroundOrigin](value) {
      this[dartx.setProperty]('background-origin', value, '');
    }
    get [dartx.backgroundPosition]() {
      return this[dartx.getPropertyValue]('background-position');
    }
    set [dartx.backgroundPosition](value) {
      this[dartx.setProperty]('background-position', value, '');
    }
    get [dartx.backgroundPositionX]() {
      return this[dartx.getPropertyValue]('background-position-x');
    }
    set [dartx.backgroundPositionX](value) {
      this[dartx.setProperty]('background-position-x', value, '');
    }
    get [dartx.backgroundPositionY]() {
      return this[dartx.getPropertyValue]('background-position-y');
    }
    set [dartx.backgroundPositionY](value) {
      this[dartx.setProperty]('background-position-y', value, '');
    }
    get [dartx.backgroundRepeat]() {
      return this[dartx.getPropertyValue]('background-repeat');
    }
    set [dartx.backgroundRepeat](value) {
      this[dartx.setProperty]('background-repeat', value, '');
    }
    get [dartx.backgroundRepeatX]() {
      return this[dartx.getPropertyValue]('background-repeat-x');
    }
    set [dartx.backgroundRepeatX](value) {
      this[dartx.setProperty]('background-repeat-x', value, '');
    }
    get [dartx.backgroundRepeatY]() {
      return this[dartx.getPropertyValue]('background-repeat-y');
    }
    set [dartx.backgroundRepeatY](value) {
      this[dartx.setProperty]('background-repeat-y', value, '');
    }
    get [dartx.backgroundSize]() {
      return this[dartx.getPropertyValue]('background-size');
    }
    set [dartx.backgroundSize](value) {
      this[dartx.setProperty]('background-size', value, '');
    }
    get [dartx.border]() {
      return this[dartx.getPropertyValue]('border');
    }
    set [dartx.border](value) {
      this[dartx.setProperty]('border', value, '');
    }
    get [dartx.borderAfter]() {
      return this[dartx.getPropertyValue]('border-after');
    }
    set [dartx.borderAfter](value) {
      this[dartx.setProperty]('border-after', value, '');
    }
    get [dartx.borderAfterColor]() {
      return this[dartx.getPropertyValue]('border-after-color');
    }
    set [dartx.borderAfterColor](value) {
      this[dartx.setProperty]('border-after-color', value, '');
    }
    get [dartx.borderAfterStyle]() {
      return this[dartx.getPropertyValue]('border-after-style');
    }
    set [dartx.borderAfterStyle](value) {
      this[dartx.setProperty]('border-after-style', value, '');
    }
    get [dartx.borderAfterWidth]() {
      return this[dartx.getPropertyValue]('border-after-width');
    }
    set [dartx.borderAfterWidth](value) {
      this[dartx.setProperty]('border-after-width', value, '');
    }
    get [dartx.borderBefore]() {
      return this[dartx.getPropertyValue]('border-before');
    }
    set [dartx.borderBefore](value) {
      this[dartx.setProperty]('border-before', value, '');
    }
    get [dartx.borderBeforeColor]() {
      return this[dartx.getPropertyValue]('border-before-color');
    }
    set [dartx.borderBeforeColor](value) {
      this[dartx.setProperty]('border-before-color', value, '');
    }
    get [dartx.borderBeforeStyle]() {
      return this[dartx.getPropertyValue]('border-before-style');
    }
    set [dartx.borderBeforeStyle](value) {
      this[dartx.setProperty]('border-before-style', value, '');
    }
    get [dartx.borderBeforeWidth]() {
      return this[dartx.getPropertyValue]('border-before-width');
    }
    set [dartx.borderBeforeWidth](value) {
      this[dartx.setProperty]('border-before-width', value, '');
    }
    get [dartx.borderBottom]() {
      return this[dartx.getPropertyValue]('border-bottom');
    }
    set [dartx.borderBottom](value) {
      this[dartx.setProperty]('border-bottom', value, '');
    }
    get [dartx.borderBottomColor]() {
      return this[dartx.getPropertyValue]('border-bottom-color');
    }
    set [dartx.borderBottomColor](value) {
      this[dartx.setProperty]('border-bottom-color', value, '');
    }
    get [dartx.borderBottomLeftRadius]() {
      return this[dartx.getPropertyValue]('border-bottom-left-radius');
    }
    set [dartx.borderBottomLeftRadius](value) {
      this[dartx.setProperty]('border-bottom-left-radius', value, '');
    }
    get [dartx.borderBottomRightRadius]() {
      return this[dartx.getPropertyValue]('border-bottom-right-radius');
    }
    set [dartx.borderBottomRightRadius](value) {
      this[dartx.setProperty]('border-bottom-right-radius', value, '');
    }
    get [dartx.borderBottomStyle]() {
      return this[dartx.getPropertyValue]('border-bottom-style');
    }
    set [dartx.borderBottomStyle](value) {
      this[dartx.setProperty]('border-bottom-style', value, '');
    }
    get [dartx.borderBottomWidth]() {
      return this[dartx.getPropertyValue]('border-bottom-width');
    }
    set [dartx.borderBottomWidth](value) {
      this[dartx.setProperty]('border-bottom-width', value, '');
    }
    get [dartx.borderCollapse]() {
      return this[dartx.getPropertyValue]('border-collapse');
    }
    set [dartx.borderCollapse](value) {
      this[dartx.setProperty]('border-collapse', value, '');
    }
    get [dartx.borderColor]() {
      return this[dartx.getPropertyValue]('border-color');
    }
    set [dartx.borderColor](value) {
      this[dartx.setProperty]('border-color', value, '');
    }
    get [dartx.borderEnd]() {
      return this[dartx.getPropertyValue]('border-end');
    }
    set [dartx.borderEnd](value) {
      this[dartx.setProperty]('border-end', value, '');
    }
    get [dartx.borderEndColor]() {
      return this[dartx.getPropertyValue]('border-end-color');
    }
    set [dartx.borderEndColor](value) {
      this[dartx.setProperty]('border-end-color', value, '');
    }
    get [dartx.borderEndStyle]() {
      return this[dartx.getPropertyValue]('border-end-style');
    }
    set [dartx.borderEndStyle](value) {
      this[dartx.setProperty]('border-end-style', value, '');
    }
    get [dartx.borderEndWidth]() {
      return this[dartx.getPropertyValue]('border-end-width');
    }
    set [dartx.borderEndWidth](value) {
      this[dartx.setProperty]('border-end-width', value, '');
    }
    get [dartx.borderFit]() {
      return this[dartx.getPropertyValue]('border-fit');
    }
    set [dartx.borderFit](value) {
      this[dartx.setProperty]('border-fit', value, '');
    }
    get [dartx.borderHorizontalSpacing]() {
      return this[dartx.getPropertyValue]('border-horizontal-spacing');
    }
    set [dartx.borderHorizontalSpacing](value) {
      this[dartx.setProperty]('border-horizontal-spacing', value, '');
    }
    get [dartx.borderImage]() {
      return this[dartx.getPropertyValue]('border-image');
    }
    set [dartx.borderImage](value) {
      this[dartx.setProperty]('border-image', value, '');
    }
    get [dartx.borderImageOutset]() {
      return this[dartx.getPropertyValue]('border-image-outset');
    }
    set [dartx.borderImageOutset](value) {
      this[dartx.setProperty]('border-image-outset', value, '');
    }
    get [dartx.borderImageRepeat]() {
      return this[dartx.getPropertyValue]('border-image-repeat');
    }
    set [dartx.borderImageRepeat](value) {
      this[dartx.setProperty]('border-image-repeat', value, '');
    }
    get [dartx.borderImageSlice]() {
      return this[dartx.getPropertyValue]('border-image-slice');
    }
    set [dartx.borderImageSlice](value) {
      this[dartx.setProperty]('border-image-slice', value, '');
    }
    get [dartx.borderImageSource]() {
      return this[dartx.getPropertyValue]('border-image-source');
    }
    set [dartx.borderImageSource](value) {
      this[dartx.setProperty]('border-image-source', value, '');
    }
    get [dartx.borderImageWidth]() {
      return this[dartx.getPropertyValue]('border-image-width');
    }
    set [dartx.borderImageWidth](value) {
      this[dartx.setProperty]('border-image-width', value, '');
    }
    get [dartx.borderLeft]() {
      return this[dartx.getPropertyValue]('border-left');
    }
    set [dartx.borderLeft](value) {
      this[dartx.setProperty]('border-left', value, '');
    }
    get [dartx.borderLeftColor]() {
      return this[dartx.getPropertyValue]('border-left-color');
    }
    set [dartx.borderLeftColor](value) {
      this[dartx.setProperty]('border-left-color', value, '');
    }
    get [dartx.borderLeftStyle]() {
      return this[dartx.getPropertyValue]('border-left-style');
    }
    set [dartx.borderLeftStyle](value) {
      this[dartx.setProperty]('border-left-style', value, '');
    }
    get [dartx.borderLeftWidth]() {
      return this[dartx.getPropertyValue]('border-left-width');
    }
    set [dartx.borderLeftWidth](value) {
      this[dartx.setProperty]('border-left-width', value, '');
    }
    get [dartx.borderRadius]() {
      return this[dartx.getPropertyValue]('border-radius');
    }
    set [dartx.borderRadius](value) {
      this[dartx.setProperty]('border-radius', value, '');
    }
    get [dartx.borderRight]() {
      return this[dartx.getPropertyValue]('border-right');
    }
    set [dartx.borderRight](value) {
      this[dartx.setProperty]('border-right', value, '');
    }
    get [dartx.borderRightColor]() {
      return this[dartx.getPropertyValue]('border-right-color');
    }
    set [dartx.borderRightColor](value) {
      this[dartx.setProperty]('border-right-color', value, '');
    }
    get [dartx.borderRightStyle]() {
      return this[dartx.getPropertyValue]('border-right-style');
    }
    set [dartx.borderRightStyle](value) {
      this[dartx.setProperty]('border-right-style', value, '');
    }
    get [dartx.borderRightWidth]() {
      return this[dartx.getPropertyValue]('border-right-width');
    }
    set [dartx.borderRightWidth](value) {
      this[dartx.setProperty]('border-right-width', value, '');
    }
    get [dartx.borderSpacing]() {
      return this[dartx.getPropertyValue]('border-spacing');
    }
    set [dartx.borderSpacing](value) {
      this[dartx.setProperty]('border-spacing', value, '');
    }
    get [dartx.borderStart]() {
      return this[dartx.getPropertyValue]('border-start');
    }
    set [dartx.borderStart](value) {
      this[dartx.setProperty]('border-start', value, '');
    }
    get [dartx.borderStartColor]() {
      return this[dartx.getPropertyValue]('border-start-color');
    }
    set [dartx.borderStartColor](value) {
      this[dartx.setProperty]('border-start-color', value, '');
    }
    get [dartx.borderStartStyle]() {
      return this[dartx.getPropertyValue]('border-start-style');
    }
    set [dartx.borderStartStyle](value) {
      this[dartx.setProperty]('border-start-style', value, '');
    }
    get [dartx.borderStartWidth]() {
      return this[dartx.getPropertyValue]('border-start-width');
    }
    set [dartx.borderStartWidth](value) {
      this[dartx.setProperty]('border-start-width', value, '');
    }
    get [dartx.borderStyle]() {
      return this[dartx.getPropertyValue]('border-style');
    }
    set [dartx.borderStyle](value) {
      this[dartx.setProperty]('border-style', value, '');
    }
    get [dartx.borderTop]() {
      return this[dartx.getPropertyValue]('border-top');
    }
    set [dartx.borderTop](value) {
      this[dartx.setProperty]('border-top', value, '');
    }
    get [dartx.borderTopColor]() {
      return this[dartx.getPropertyValue]('border-top-color');
    }
    set [dartx.borderTopColor](value) {
      this[dartx.setProperty]('border-top-color', value, '');
    }
    get [dartx.borderTopLeftRadius]() {
      return this[dartx.getPropertyValue]('border-top-left-radius');
    }
    set [dartx.borderTopLeftRadius](value) {
      this[dartx.setProperty]('border-top-left-radius', value, '');
    }
    get [dartx.borderTopRightRadius]() {
      return this[dartx.getPropertyValue]('border-top-right-radius');
    }
    set [dartx.borderTopRightRadius](value) {
      this[dartx.setProperty]('border-top-right-radius', value, '');
    }
    get [dartx.borderTopStyle]() {
      return this[dartx.getPropertyValue]('border-top-style');
    }
    set [dartx.borderTopStyle](value) {
      this[dartx.setProperty]('border-top-style', value, '');
    }
    get [dartx.borderTopWidth]() {
      return this[dartx.getPropertyValue]('border-top-width');
    }
    set [dartx.borderTopWidth](value) {
      this[dartx.setProperty]('border-top-width', value, '');
    }
    get [dartx.borderVerticalSpacing]() {
      return this[dartx.getPropertyValue]('border-vertical-spacing');
    }
    set [dartx.borderVerticalSpacing](value) {
      this[dartx.setProperty]('border-vertical-spacing', value, '');
    }
    get [dartx.borderWidth]() {
      return this[dartx.getPropertyValue]('border-width');
    }
    set [dartx.borderWidth](value) {
      this[dartx.setProperty]('border-width', value, '');
    }
    get [dartx.bottom]() {
      return this[dartx.getPropertyValue]('bottom');
    }
    set [dartx.bottom](value) {
      this[dartx.setProperty]('bottom', value, '');
    }
    get [dartx.boxAlign]() {
      return this[dartx.getPropertyValue]('box-align');
    }
    set [dartx.boxAlign](value) {
      this[dartx.setProperty]('box-align', value, '');
    }
    get [dartx.boxDecorationBreak]() {
      return this[dartx.getPropertyValue]('box-decoration-break');
    }
    set [dartx.boxDecorationBreak](value) {
      this[dartx.setProperty]('box-decoration-break', value, '');
    }
    get [dartx.boxDirection]() {
      return this[dartx.getPropertyValue]('box-direction');
    }
    set [dartx.boxDirection](value) {
      this[dartx.setProperty]('box-direction', value, '');
    }
    get [dartx.boxFlex]() {
      return this[dartx.getPropertyValue]('box-flex');
    }
    set [dartx.boxFlex](value) {
      this[dartx.setProperty]('box-flex', value, '');
    }
    get [dartx.boxFlexGroup]() {
      return this[dartx.getPropertyValue]('box-flex-group');
    }
    set [dartx.boxFlexGroup](value) {
      this[dartx.setProperty]('box-flex-group', value, '');
    }
    get [dartx.boxLines]() {
      return this[dartx.getPropertyValue]('box-lines');
    }
    set [dartx.boxLines](value) {
      this[dartx.setProperty]('box-lines', value, '');
    }
    get [dartx.boxOrdinalGroup]() {
      return this[dartx.getPropertyValue]('box-ordinal-group');
    }
    set [dartx.boxOrdinalGroup](value) {
      this[dartx.setProperty]('box-ordinal-group', value, '');
    }
    get [dartx.boxOrient]() {
      return this[dartx.getPropertyValue]('box-orient');
    }
    set [dartx.boxOrient](value) {
      this[dartx.setProperty]('box-orient', value, '');
    }
    get [dartx.boxPack]() {
      return this[dartx.getPropertyValue]('box-pack');
    }
    set [dartx.boxPack](value) {
      this[dartx.setProperty]('box-pack', value, '');
    }
    get [dartx.boxReflect]() {
      return this[dartx.getPropertyValue]('box-reflect');
    }
    set [dartx.boxReflect](value) {
      this[dartx.setProperty]('box-reflect', value, '');
    }
    get [dartx.boxShadow]() {
      return this[dartx.getPropertyValue]('box-shadow');
    }
    set [dartx.boxShadow](value) {
      this[dartx.setProperty]('box-shadow', value, '');
    }
    get [dartx.boxSizing]() {
      return this[dartx.getPropertyValue]('box-sizing');
    }
    set [dartx.boxSizing](value) {
      this[dartx.setProperty]('box-sizing', value, '');
    }
    get [dartx.captionSide]() {
      return this[dartx.getPropertyValue]('caption-side');
    }
    set [dartx.captionSide](value) {
      this[dartx.setProperty]('caption-side', value, '');
    }
    get [dartx.clear]() {
      return this[dartx.getPropertyValue]('clear');
    }
    set [dartx.clear](value) {
      this[dartx.setProperty]('clear', value, '');
    }
    get [dartx.clip]() {
      return this[dartx.getPropertyValue]('clip');
    }
    set [dartx.clip](value) {
      this[dartx.setProperty]('clip', value, '');
    }
    get [dartx.clipPath]() {
      return this[dartx.getPropertyValue]('clip-path');
    }
    set [dartx.clipPath](value) {
      this[dartx.setProperty]('clip-path', value, '');
    }
    get [dartx.color]() {
      return this[dartx.getPropertyValue]('color');
    }
    set [dartx.color](value) {
      this[dartx.setProperty]('color', value, '');
    }
    get [dartx.columnBreakAfter]() {
      return this[dartx.getPropertyValue]('column-break-after');
    }
    set [dartx.columnBreakAfter](value) {
      this[dartx.setProperty]('column-break-after', value, '');
    }
    get [dartx.columnBreakBefore]() {
      return this[dartx.getPropertyValue]('column-break-before');
    }
    set [dartx.columnBreakBefore](value) {
      this[dartx.setProperty]('column-break-before', value, '');
    }
    get [dartx.columnBreakInside]() {
      return this[dartx.getPropertyValue]('column-break-inside');
    }
    set [dartx.columnBreakInside](value) {
      this[dartx.setProperty]('column-break-inside', value, '');
    }
    get [dartx.columnCount]() {
      return this[dartx.getPropertyValue]('column-count');
    }
    set [dartx.columnCount](value) {
      this[dartx.setProperty]('column-count', value, '');
    }
    get [dartx.columnFill]() {
      return this[dartx.getPropertyValue]('column-fill');
    }
    set [dartx.columnFill](value) {
      this[dartx.setProperty]('column-fill', value, '');
    }
    get [dartx.columnGap]() {
      return this[dartx.getPropertyValue]('column-gap');
    }
    set [dartx.columnGap](value) {
      this[dartx.setProperty]('column-gap', value, '');
    }
    get [dartx.columnRule]() {
      return this[dartx.getPropertyValue]('column-rule');
    }
    set [dartx.columnRule](value) {
      this[dartx.setProperty]('column-rule', value, '');
    }
    get [dartx.columnRuleColor]() {
      return this[dartx.getPropertyValue]('column-rule-color');
    }
    set [dartx.columnRuleColor](value) {
      this[dartx.setProperty]('column-rule-color', value, '');
    }
    get [dartx.columnRuleStyle]() {
      return this[dartx.getPropertyValue]('column-rule-style');
    }
    set [dartx.columnRuleStyle](value) {
      this[dartx.setProperty]('column-rule-style', value, '');
    }
    get [dartx.columnRuleWidth]() {
      return this[dartx.getPropertyValue]('column-rule-width');
    }
    set [dartx.columnRuleWidth](value) {
      this[dartx.setProperty]('column-rule-width', value, '');
    }
    get [dartx.columnSpan]() {
      return this[dartx.getPropertyValue]('column-span');
    }
    set [dartx.columnSpan](value) {
      this[dartx.setProperty]('column-span', value, '');
    }
    get [dartx.columnWidth]() {
      return this[dartx.getPropertyValue]('column-width');
    }
    set [dartx.columnWidth](value) {
      this[dartx.setProperty]('column-width', value, '');
    }
    get [dartx.columns]() {
      return this[dartx.getPropertyValue]('columns');
    }
    set [dartx.columns](value) {
      this[dartx.setProperty]('columns', value, '');
    }
    get [dartx.content]() {
      return this[dartx.getPropertyValue]('content');
    }
    set [dartx.content](value) {
      this[dartx.setProperty]('content', value, '');
    }
    get [dartx.counterIncrement]() {
      return this[dartx.getPropertyValue]('counter-increment');
    }
    set [dartx.counterIncrement](value) {
      this[dartx.setProperty]('counter-increment', value, '');
    }
    get [dartx.counterReset]() {
      return this[dartx.getPropertyValue]('counter-reset');
    }
    set [dartx.counterReset](value) {
      this[dartx.setProperty]('counter-reset', value, '');
    }
    get [dartx.cursor]() {
      return this[dartx.getPropertyValue]('cursor');
    }
    set [dartx.cursor](value) {
      this[dartx.setProperty]('cursor', value, '');
    }
    get [dartx.direction]() {
      return this[dartx.getPropertyValue]('direction');
    }
    set [dartx.direction](value) {
      this[dartx.setProperty]('direction', value, '');
    }
    get [dartx.display]() {
      return this[dartx.getPropertyValue]('display');
    }
    set [dartx.display](value) {
      this[dartx.setProperty]('display', value, '');
    }
    get [dartx.emptyCells]() {
      return this[dartx.getPropertyValue]('empty-cells');
    }
    set [dartx.emptyCells](value) {
      this[dartx.setProperty]('empty-cells', value, '');
    }
    get [dartx.filter]() {
      return this[dartx.getPropertyValue]('filter');
    }
    set [dartx.filter](value) {
      this[dartx.setProperty]('filter', value, '');
    }
    get [dartx.flex]() {
      return this[dartx.getPropertyValue]('flex');
    }
    set [dartx.flex](value) {
      this[dartx.setProperty]('flex', value, '');
    }
    get [dartx.flexBasis]() {
      return this[dartx.getPropertyValue]('flex-basis');
    }
    set [dartx.flexBasis](value) {
      this[dartx.setProperty]('flex-basis', value, '');
    }
    get [dartx.flexDirection]() {
      return this[dartx.getPropertyValue]('flex-direction');
    }
    set [dartx.flexDirection](value) {
      this[dartx.setProperty]('flex-direction', value, '');
    }
    get [dartx.flexFlow]() {
      return this[dartx.getPropertyValue]('flex-flow');
    }
    set [dartx.flexFlow](value) {
      this[dartx.setProperty]('flex-flow', value, '');
    }
    get [dartx.flexGrow]() {
      return this[dartx.getPropertyValue]('flex-grow');
    }
    set [dartx.flexGrow](value) {
      this[dartx.setProperty]('flex-grow', value, '');
    }
    get [dartx.flexShrink]() {
      return this[dartx.getPropertyValue]('flex-shrink');
    }
    set [dartx.flexShrink](value) {
      this[dartx.setProperty]('flex-shrink', value, '');
    }
    get [dartx.flexWrap]() {
      return this[dartx.getPropertyValue]('flex-wrap');
    }
    set [dartx.flexWrap](value) {
      this[dartx.setProperty]('flex-wrap', value, '');
    }
    get [dartx.float]() {
      return this[dartx.getPropertyValue]('float');
    }
    set [dartx.float](value) {
      this[dartx.setProperty]('float', value, '');
    }
    get [dartx.font]() {
      return this[dartx.getPropertyValue]('font');
    }
    set [dartx.font](value) {
      this[dartx.setProperty]('font', value, '');
    }
    get [dartx.fontFamily]() {
      return this[dartx.getPropertyValue]('font-family');
    }
    set [dartx.fontFamily](value) {
      this[dartx.setProperty]('font-family', value, '');
    }
    get [dartx.fontFeatureSettings]() {
      return this[dartx.getPropertyValue]('font-feature-settings');
    }
    set [dartx.fontFeatureSettings](value) {
      this[dartx.setProperty]('font-feature-settings', value, '');
    }
    get [dartx.fontKerning]() {
      return this[dartx.getPropertyValue]('font-kerning');
    }
    set [dartx.fontKerning](value) {
      this[dartx.setProperty]('font-kerning', value, '');
    }
    get [dartx.fontSize]() {
      return this[dartx.getPropertyValue]('font-size');
    }
    set [dartx.fontSize](value) {
      this[dartx.setProperty]('font-size', value, '');
    }
    get [dartx.fontSizeDelta]() {
      return this[dartx.getPropertyValue]('font-size-delta');
    }
    set [dartx.fontSizeDelta](value) {
      this[dartx.setProperty]('font-size-delta', value, '');
    }
    get [dartx.fontSmoothing]() {
      return this[dartx.getPropertyValue]('font-smoothing');
    }
    set [dartx.fontSmoothing](value) {
      this[dartx.setProperty]('font-smoothing', value, '');
    }
    get [dartx.fontStretch]() {
      return this[dartx.getPropertyValue]('font-stretch');
    }
    set [dartx.fontStretch](value) {
      this[dartx.setProperty]('font-stretch', value, '');
    }
    get [dartx.fontStyle]() {
      return this[dartx.getPropertyValue]('font-style');
    }
    set [dartx.fontStyle](value) {
      this[dartx.setProperty]('font-style', value, '');
    }
    get [dartx.fontVariant]() {
      return this[dartx.getPropertyValue]('font-variant');
    }
    set [dartx.fontVariant](value) {
      this[dartx.setProperty]('font-variant', value, '');
    }
    get [dartx.fontVariantLigatures]() {
      return this[dartx.getPropertyValue]('font-variant-ligatures');
    }
    set [dartx.fontVariantLigatures](value) {
      this[dartx.setProperty]('font-variant-ligatures', value, '');
    }
    get [dartx.fontWeight]() {
      return this[dartx.getPropertyValue]('font-weight');
    }
    set [dartx.fontWeight](value) {
      this[dartx.setProperty]('font-weight', value, '');
    }
    get [dartx.grid]() {
      return this[dartx.getPropertyValue]('grid');
    }
    set [dartx.grid](value) {
      this[dartx.setProperty]('grid', value, '');
    }
    get [dartx.gridArea]() {
      return this[dartx.getPropertyValue]('grid-area');
    }
    set [dartx.gridArea](value) {
      this[dartx.setProperty]('grid-area', value, '');
    }
    get [dartx.gridAutoColumns]() {
      return this[dartx.getPropertyValue]('grid-auto-columns');
    }
    set [dartx.gridAutoColumns](value) {
      this[dartx.setProperty]('grid-auto-columns', value, '');
    }
    get [dartx.gridAutoFlow]() {
      return this[dartx.getPropertyValue]('grid-auto-flow');
    }
    set [dartx.gridAutoFlow](value) {
      this[dartx.setProperty]('grid-auto-flow', value, '');
    }
    get [dartx.gridAutoRows]() {
      return this[dartx.getPropertyValue]('grid-auto-rows');
    }
    set [dartx.gridAutoRows](value) {
      this[dartx.setProperty]('grid-auto-rows', value, '');
    }
    get [dartx.gridColumn]() {
      return this[dartx.getPropertyValue]('grid-column');
    }
    set [dartx.gridColumn](value) {
      this[dartx.setProperty]('grid-column', value, '');
    }
    get [dartx.gridColumnEnd]() {
      return this[dartx.getPropertyValue]('grid-column-end');
    }
    set [dartx.gridColumnEnd](value) {
      this[dartx.setProperty]('grid-column-end', value, '');
    }
    get [dartx.gridColumnStart]() {
      return this[dartx.getPropertyValue]('grid-column-start');
    }
    set [dartx.gridColumnStart](value) {
      this[dartx.setProperty]('grid-column-start', value, '');
    }
    get [dartx.gridRow]() {
      return this[dartx.getPropertyValue]('grid-row');
    }
    set [dartx.gridRow](value) {
      this[dartx.setProperty]('grid-row', value, '');
    }
    get [dartx.gridRowEnd]() {
      return this[dartx.getPropertyValue]('grid-row-end');
    }
    set [dartx.gridRowEnd](value) {
      this[dartx.setProperty]('grid-row-end', value, '');
    }
    get [dartx.gridRowStart]() {
      return this[dartx.getPropertyValue]('grid-row-start');
    }
    set [dartx.gridRowStart](value) {
      this[dartx.setProperty]('grid-row-start', value, '');
    }
    get [dartx.gridTemplate]() {
      return this[dartx.getPropertyValue]('grid-template');
    }
    set [dartx.gridTemplate](value) {
      this[dartx.setProperty]('grid-template', value, '');
    }
    get [dartx.gridTemplateAreas]() {
      return this[dartx.getPropertyValue]('grid-template-areas');
    }
    set [dartx.gridTemplateAreas](value) {
      this[dartx.setProperty]('grid-template-areas', value, '');
    }
    get [dartx.gridTemplateColumns]() {
      return this[dartx.getPropertyValue]('grid-template-columns');
    }
    set [dartx.gridTemplateColumns](value) {
      this[dartx.setProperty]('grid-template-columns', value, '');
    }
    get [dartx.gridTemplateRows]() {
      return this[dartx.getPropertyValue]('grid-template-rows');
    }
    set [dartx.gridTemplateRows](value) {
      this[dartx.setProperty]('grid-template-rows', value, '');
    }
    get [dartx.height]() {
      return this[dartx.getPropertyValue]('height');
    }
    set [dartx.height](value) {
      this[dartx.setProperty]('height', value, '');
    }
    get [dartx.highlight]() {
      return this[dartx.getPropertyValue]('highlight');
    }
    set [dartx.highlight](value) {
      this[dartx.setProperty]('highlight', value, '');
    }
    get [dartx.hyphenateCharacter]() {
      return this[dartx.getPropertyValue]('hyphenate-character');
    }
    set [dartx.hyphenateCharacter](value) {
      this[dartx.setProperty]('hyphenate-character', value, '');
    }
    get [dartx.imageRendering]() {
      return this[dartx.getPropertyValue]('image-rendering');
    }
    set [dartx.imageRendering](value) {
      this[dartx.setProperty]('image-rendering', value, '');
    }
    get [dartx.isolation]() {
      return this[dartx.getPropertyValue]('isolation');
    }
    set [dartx.isolation](value) {
      this[dartx.setProperty]('isolation', value, '');
    }
    get [dartx.justifyContent]() {
      return this[dartx.getPropertyValue]('justify-content');
    }
    set [dartx.justifyContent](value) {
      this[dartx.setProperty]('justify-content', value, '');
    }
    get [dartx.justifySelf]() {
      return this[dartx.getPropertyValue]('justify-self');
    }
    set [dartx.justifySelf](value) {
      this[dartx.setProperty]('justify-self', value, '');
    }
    get [dartx.left]() {
      return this[dartx.getPropertyValue]('left');
    }
    set [dartx.left](value) {
      this[dartx.setProperty]('left', value, '');
    }
    get [dartx.letterSpacing]() {
      return this[dartx.getPropertyValue]('letter-spacing');
    }
    set [dartx.letterSpacing](value) {
      this[dartx.setProperty]('letter-spacing', value, '');
    }
    get [dartx.lineBoxContain]() {
      return this[dartx.getPropertyValue]('line-box-contain');
    }
    set [dartx.lineBoxContain](value) {
      this[dartx.setProperty]('line-box-contain', value, '');
    }
    get [dartx.lineBreak]() {
      return this[dartx.getPropertyValue]('line-break');
    }
    set [dartx.lineBreak](value) {
      this[dartx.setProperty]('line-break', value, '');
    }
    get [dartx.lineClamp]() {
      return this[dartx.getPropertyValue]('line-clamp');
    }
    set [dartx.lineClamp](value) {
      this[dartx.setProperty]('line-clamp', value, '');
    }
    get [dartx.lineHeight]() {
      return this[dartx.getPropertyValue]('line-height');
    }
    set [dartx.lineHeight](value) {
      this[dartx.setProperty]('line-height', value, '');
    }
    get [dartx.listStyle]() {
      return this[dartx.getPropertyValue]('list-style');
    }
    set [dartx.listStyle](value) {
      this[dartx.setProperty]('list-style', value, '');
    }
    get [dartx.listStyleImage]() {
      return this[dartx.getPropertyValue]('list-style-image');
    }
    set [dartx.listStyleImage](value) {
      this[dartx.setProperty]('list-style-image', value, '');
    }
    get [dartx.listStylePosition]() {
      return this[dartx.getPropertyValue]('list-style-position');
    }
    set [dartx.listStylePosition](value) {
      this[dartx.setProperty]('list-style-position', value, '');
    }
    get [dartx.listStyleType]() {
      return this[dartx.getPropertyValue]('list-style-type');
    }
    set [dartx.listStyleType](value) {
      this[dartx.setProperty]('list-style-type', value, '');
    }
    get [dartx.locale]() {
      return this[dartx.getPropertyValue]('locale');
    }
    set [dartx.locale](value) {
      this[dartx.setProperty]('locale', value, '');
    }
    get [dartx.logicalHeight]() {
      return this[dartx.getPropertyValue]('logical-height');
    }
    set [dartx.logicalHeight](value) {
      this[dartx.setProperty]('logical-height', value, '');
    }
    get [dartx.logicalWidth]() {
      return this[dartx.getPropertyValue]('logical-width');
    }
    set [dartx.logicalWidth](value) {
      this[dartx.setProperty]('logical-width', value, '');
    }
    get [dartx.margin]() {
      return this[dartx.getPropertyValue]('margin');
    }
    set [dartx.margin](value) {
      this[dartx.setProperty]('margin', value, '');
    }
    get [dartx.marginAfter]() {
      return this[dartx.getPropertyValue]('margin-after');
    }
    set [dartx.marginAfter](value) {
      this[dartx.setProperty]('margin-after', value, '');
    }
    get [dartx.marginAfterCollapse]() {
      return this[dartx.getPropertyValue]('margin-after-collapse');
    }
    set [dartx.marginAfterCollapse](value) {
      this[dartx.setProperty]('margin-after-collapse', value, '');
    }
    get [dartx.marginBefore]() {
      return this[dartx.getPropertyValue]('margin-before');
    }
    set [dartx.marginBefore](value) {
      this[dartx.setProperty]('margin-before', value, '');
    }
    get [dartx.marginBeforeCollapse]() {
      return this[dartx.getPropertyValue]('margin-before-collapse');
    }
    set [dartx.marginBeforeCollapse](value) {
      this[dartx.setProperty]('margin-before-collapse', value, '');
    }
    get [dartx.marginBottom]() {
      return this[dartx.getPropertyValue]('margin-bottom');
    }
    set [dartx.marginBottom](value) {
      this[dartx.setProperty]('margin-bottom', value, '');
    }
    get [dartx.marginBottomCollapse]() {
      return this[dartx.getPropertyValue]('margin-bottom-collapse');
    }
    set [dartx.marginBottomCollapse](value) {
      this[dartx.setProperty]('margin-bottom-collapse', value, '');
    }
    get [dartx.marginCollapse]() {
      return this[dartx.getPropertyValue]('margin-collapse');
    }
    set [dartx.marginCollapse](value) {
      this[dartx.setProperty]('margin-collapse', value, '');
    }
    get [dartx.marginEnd]() {
      return this[dartx.getPropertyValue]('margin-end');
    }
    set [dartx.marginEnd](value) {
      this[dartx.setProperty]('margin-end', value, '');
    }
    get [dartx.marginLeft]() {
      return this[dartx.getPropertyValue]('margin-left');
    }
    set [dartx.marginLeft](value) {
      this[dartx.setProperty]('margin-left', value, '');
    }
    get [dartx.marginRight]() {
      return this[dartx.getPropertyValue]('margin-right');
    }
    set [dartx.marginRight](value) {
      this[dartx.setProperty]('margin-right', value, '');
    }
    get [dartx.marginStart]() {
      return this[dartx.getPropertyValue]('margin-start');
    }
    set [dartx.marginStart](value) {
      this[dartx.setProperty]('margin-start', value, '');
    }
    get [dartx.marginTop]() {
      return this[dartx.getPropertyValue]('margin-top');
    }
    set [dartx.marginTop](value) {
      this[dartx.setProperty]('margin-top', value, '');
    }
    get [dartx.marginTopCollapse]() {
      return this[dartx.getPropertyValue]('margin-top-collapse');
    }
    set [dartx.marginTopCollapse](value) {
      this[dartx.setProperty]('margin-top-collapse', value, '');
    }
    get [dartx.mask]() {
      return this[dartx.getPropertyValue]('mask');
    }
    set [dartx.mask](value) {
      this[dartx.setProperty]('mask', value, '');
    }
    get [dartx.maskBoxImage]() {
      return this[dartx.getPropertyValue]('mask-box-image');
    }
    set [dartx.maskBoxImage](value) {
      this[dartx.setProperty]('mask-box-image', value, '');
    }
    get [dartx.maskBoxImageOutset]() {
      return this[dartx.getPropertyValue]('mask-box-image-outset');
    }
    set [dartx.maskBoxImageOutset](value) {
      this[dartx.setProperty]('mask-box-image-outset', value, '');
    }
    get [dartx.maskBoxImageRepeat]() {
      return this[dartx.getPropertyValue]('mask-box-image-repeat');
    }
    set [dartx.maskBoxImageRepeat](value) {
      this[dartx.setProperty]('mask-box-image-repeat', value, '');
    }
    get [dartx.maskBoxImageSlice]() {
      return this[dartx.getPropertyValue]('mask-box-image-slice');
    }
    set [dartx.maskBoxImageSlice](value) {
      this[dartx.setProperty]('mask-box-image-slice', value, '');
    }
    get [dartx.maskBoxImageSource]() {
      return this[dartx.getPropertyValue]('mask-box-image-source');
    }
    set [dartx.maskBoxImageSource](value) {
      this[dartx.setProperty]('mask-box-image-source', value, '');
    }
    get [dartx.maskBoxImageWidth]() {
      return this[dartx.getPropertyValue]('mask-box-image-width');
    }
    set [dartx.maskBoxImageWidth](value) {
      this[dartx.setProperty]('mask-box-image-width', value, '');
    }
    get [dartx.maskClip]() {
      return this[dartx.getPropertyValue]('mask-clip');
    }
    set [dartx.maskClip](value) {
      this[dartx.setProperty]('mask-clip', value, '');
    }
    get [dartx.maskComposite]() {
      return this[dartx.getPropertyValue]('mask-composite');
    }
    set [dartx.maskComposite](value) {
      this[dartx.setProperty]('mask-composite', value, '');
    }
    get [dartx.maskImage]() {
      return this[dartx.getPropertyValue]('mask-image');
    }
    set [dartx.maskImage](value) {
      this[dartx.setProperty]('mask-image', value, '');
    }
    get [dartx.maskOrigin]() {
      return this[dartx.getPropertyValue]('mask-origin');
    }
    set [dartx.maskOrigin](value) {
      this[dartx.setProperty]('mask-origin', value, '');
    }
    get [dartx.maskPosition]() {
      return this[dartx.getPropertyValue]('mask-position');
    }
    set [dartx.maskPosition](value) {
      this[dartx.setProperty]('mask-position', value, '');
    }
    get [dartx.maskPositionX]() {
      return this[dartx.getPropertyValue]('mask-position-x');
    }
    set [dartx.maskPositionX](value) {
      this[dartx.setProperty]('mask-position-x', value, '');
    }
    get [dartx.maskPositionY]() {
      return this[dartx.getPropertyValue]('mask-position-y');
    }
    set [dartx.maskPositionY](value) {
      this[dartx.setProperty]('mask-position-y', value, '');
    }
    get [dartx.maskRepeat]() {
      return this[dartx.getPropertyValue]('mask-repeat');
    }
    set [dartx.maskRepeat](value) {
      this[dartx.setProperty]('mask-repeat', value, '');
    }
    get [dartx.maskRepeatX]() {
      return this[dartx.getPropertyValue]('mask-repeat-x');
    }
    set [dartx.maskRepeatX](value) {
      this[dartx.setProperty]('mask-repeat-x', value, '');
    }
    get [dartx.maskRepeatY]() {
      return this[dartx.getPropertyValue]('mask-repeat-y');
    }
    set [dartx.maskRepeatY](value) {
      this[dartx.setProperty]('mask-repeat-y', value, '');
    }
    get [dartx.maskSize]() {
      return this[dartx.getPropertyValue]('mask-size');
    }
    set [dartx.maskSize](value) {
      this[dartx.setProperty]('mask-size', value, '');
    }
    get [dartx.maskSourceType]() {
      return this[dartx.getPropertyValue]('mask-source-type');
    }
    set [dartx.maskSourceType](value) {
      this[dartx.setProperty]('mask-source-type', value, '');
    }
    get [dartx.maxHeight]() {
      return this[dartx.getPropertyValue]('max-height');
    }
    set [dartx.maxHeight](value) {
      this[dartx.setProperty]('max-height', value, '');
    }
    get [dartx.maxLogicalHeight]() {
      return this[dartx.getPropertyValue]('max-logical-height');
    }
    set [dartx.maxLogicalHeight](value) {
      this[dartx.setProperty]('max-logical-height', value, '');
    }
    get [dartx.maxLogicalWidth]() {
      return this[dartx.getPropertyValue]('max-logical-width');
    }
    set [dartx.maxLogicalWidth](value) {
      this[dartx.setProperty]('max-logical-width', value, '');
    }
    get [dartx.maxWidth]() {
      return this[dartx.getPropertyValue]('max-width');
    }
    set [dartx.maxWidth](value) {
      this[dartx.setProperty]('max-width', value, '');
    }
    get [dartx.maxZoom]() {
      return this[dartx.getPropertyValue]('max-zoom');
    }
    set [dartx.maxZoom](value) {
      this[dartx.setProperty]('max-zoom', value, '');
    }
    get [dartx.minHeight]() {
      return this[dartx.getPropertyValue]('min-height');
    }
    set [dartx.minHeight](value) {
      this[dartx.setProperty]('min-height', value, '');
    }
    get [dartx.minLogicalHeight]() {
      return this[dartx.getPropertyValue]('min-logical-height');
    }
    set [dartx.minLogicalHeight](value) {
      this[dartx.setProperty]('min-logical-height', value, '');
    }
    get [dartx.minLogicalWidth]() {
      return this[dartx.getPropertyValue]('min-logical-width');
    }
    set [dartx.minLogicalWidth](value) {
      this[dartx.setProperty]('min-logical-width', value, '');
    }
    get [dartx.minWidth]() {
      return this[dartx.getPropertyValue]('min-width');
    }
    set [dartx.minWidth](value) {
      this[dartx.setProperty]('min-width', value, '');
    }
    get [dartx.minZoom]() {
      return this[dartx.getPropertyValue]('min-zoom');
    }
    set [dartx.minZoom](value) {
      this[dartx.setProperty]('min-zoom', value, '');
    }
    get [dartx.mixBlendMode]() {
      return this[dartx.getPropertyValue]('mix-blend-mode');
    }
    set [dartx.mixBlendMode](value) {
      this[dartx.setProperty]('mix-blend-mode', value, '');
    }
    get [dartx.objectFit]() {
      return this[dartx.getPropertyValue]('object-fit');
    }
    set [dartx.objectFit](value) {
      this[dartx.setProperty]('object-fit', value, '');
    }
    get [dartx.objectPosition]() {
      return this[dartx.getPropertyValue]('object-position');
    }
    set [dartx.objectPosition](value) {
      this[dartx.setProperty]('object-position', value, '');
    }
    get [dartx.opacity]() {
      return this[dartx.getPropertyValue]('opacity');
    }
    set [dartx.opacity](value) {
      this[dartx.setProperty]('opacity', value, '');
    }
    get [dartx.order]() {
      return this[dartx.getPropertyValue]('order');
    }
    set [dartx.order](value) {
      this[dartx.setProperty]('order', value, '');
    }
    get [dartx.orientation]() {
      return this[dartx.getPropertyValue]('orientation');
    }
    set [dartx.orientation](value) {
      this[dartx.setProperty]('orientation', value, '');
    }
    get [dartx.orphans]() {
      return this[dartx.getPropertyValue]('orphans');
    }
    set [dartx.orphans](value) {
      this[dartx.setProperty]('orphans', value, '');
    }
    get [dartx.outline]() {
      return this[dartx.getPropertyValue]('outline');
    }
    set [dartx.outline](value) {
      this[dartx.setProperty]('outline', value, '');
    }
    get [dartx.outlineColor]() {
      return this[dartx.getPropertyValue]('outline-color');
    }
    set [dartx.outlineColor](value) {
      this[dartx.setProperty]('outline-color', value, '');
    }
    get [dartx.outlineOffset]() {
      return this[dartx.getPropertyValue]('outline-offset');
    }
    set [dartx.outlineOffset](value) {
      this[dartx.setProperty]('outline-offset', value, '');
    }
    get [dartx.outlineStyle]() {
      return this[dartx.getPropertyValue]('outline-style');
    }
    set [dartx.outlineStyle](value) {
      this[dartx.setProperty]('outline-style', value, '');
    }
    get [dartx.outlineWidth]() {
      return this[dartx.getPropertyValue]('outline-width');
    }
    set [dartx.outlineWidth](value) {
      this[dartx.setProperty]('outline-width', value, '');
    }
    get [dartx.overflow]() {
      return this[dartx.getPropertyValue]('overflow');
    }
    set [dartx.overflow](value) {
      this[dartx.setProperty]('overflow', value, '');
    }
    get [dartx.overflowWrap]() {
      return this[dartx.getPropertyValue]('overflow-wrap');
    }
    set [dartx.overflowWrap](value) {
      this[dartx.setProperty]('overflow-wrap', value, '');
    }
    get [dartx.overflowX]() {
      return this[dartx.getPropertyValue]('overflow-x');
    }
    set [dartx.overflowX](value) {
      this[dartx.setProperty]('overflow-x', value, '');
    }
    get [dartx.overflowY]() {
      return this[dartx.getPropertyValue]('overflow-y');
    }
    set [dartx.overflowY](value) {
      this[dartx.setProperty]('overflow-y', value, '');
    }
    get [dartx.padding]() {
      return this[dartx.getPropertyValue]('padding');
    }
    set [dartx.padding](value) {
      this[dartx.setProperty]('padding', value, '');
    }
    get [dartx.paddingAfter]() {
      return this[dartx.getPropertyValue]('padding-after');
    }
    set [dartx.paddingAfter](value) {
      this[dartx.setProperty]('padding-after', value, '');
    }
    get [dartx.paddingBefore]() {
      return this[dartx.getPropertyValue]('padding-before');
    }
    set [dartx.paddingBefore](value) {
      this[dartx.setProperty]('padding-before', value, '');
    }
    get [dartx.paddingBottom]() {
      return this[dartx.getPropertyValue]('padding-bottom');
    }
    set [dartx.paddingBottom](value) {
      this[dartx.setProperty]('padding-bottom', value, '');
    }
    get [dartx.paddingEnd]() {
      return this[dartx.getPropertyValue]('padding-end');
    }
    set [dartx.paddingEnd](value) {
      this[dartx.setProperty]('padding-end', value, '');
    }
    get [dartx.paddingLeft]() {
      return this[dartx.getPropertyValue]('padding-left');
    }
    set [dartx.paddingLeft](value) {
      this[dartx.setProperty]('padding-left', value, '');
    }
    get [dartx.paddingRight]() {
      return this[dartx.getPropertyValue]('padding-right');
    }
    set [dartx.paddingRight](value) {
      this[dartx.setProperty]('padding-right', value, '');
    }
    get [dartx.paddingStart]() {
      return this[dartx.getPropertyValue]('padding-start');
    }
    set [dartx.paddingStart](value) {
      this[dartx.setProperty]('padding-start', value, '');
    }
    get [dartx.paddingTop]() {
      return this[dartx.getPropertyValue]('padding-top');
    }
    set [dartx.paddingTop](value) {
      this[dartx.setProperty]('padding-top', value, '');
    }
    get [dartx.page]() {
      return this[dartx.getPropertyValue]('page');
    }
    set [dartx.page](value) {
      this[dartx.setProperty]('page', value, '');
    }
    get [dartx.pageBreakAfter]() {
      return this[dartx.getPropertyValue]('page-break-after');
    }
    set [dartx.pageBreakAfter](value) {
      this[dartx.setProperty]('page-break-after', value, '');
    }
    get [dartx.pageBreakBefore]() {
      return this[dartx.getPropertyValue]('page-break-before');
    }
    set [dartx.pageBreakBefore](value) {
      this[dartx.setProperty]('page-break-before', value, '');
    }
    get [dartx.pageBreakInside]() {
      return this[dartx.getPropertyValue]('page-break-inside');
    }
    set [dartx.pageBreakInside](value) {
      this[dartx.setProperty]('page-break-inside', value, '');
    }
    get [dartx.perspective]() {
      return this[dartx.getPropertyValue]('perspective');
    }
    set [dartx.perspective](value) {
      this[dartx.setProperty]('perspective', value, '');
    }
    get [dartx.perspectiveOrigin]() {
      return this[dartx.getPropertyValue]('perspective-origin');
    }
    set [dartx.perspectiveOrigin](value) {
      this[dartx.setProperty]('perspective-origin', value, '');
    }
    get [dartx.perspectiveOriginX]() {
      return this[dartx.getPropertyValue]('perspective-origin-x');
    }
    set [dartx.perspectiveOriginX](value) {
      this[dartx.setProperty]('perspective-origin-x', value, '');
    }
    get [dartx.perspectiveOriginY]() {
      return this[dartx.getPropertyValue]('perspective-origin-y');
    }
    set [dartx.perspectiveOriginY](value) {
      this[dartx.setProperty]('perspective-origin-y', value, '');
    }
    get [dartx.pointerEvents]() {
      return this[dartx.getPropertyValue]('pointer-events');
    }
    set [dartx.pointerEvents](value) {
      this[dartx.setProperty]('pointer-events', value, '');
    }
    get [dartx.position]() {
      return this[dartx.getPropertyValue]('position');
    }
    set [dartx.position](value) {
      this[dartx.setProperty]('position', value, '');
    }
    get [dartx.printColorAdjust]() {
      return this[dartx.getPropertyValue]('print-color-adjust');
    }
    set [dartx.printColorAdjust](value) {
      this[dartx.setProperty]('print-color-adjust', value, '');
    }
    get [dartx.quotes]() {
      return this[dartx.getPropertyValue]('quotes');
    }
    set [dartx.quotes](value) {
      this[dartx.setProperty]('quotes', value, '');
    }
    get [dartx.resize]() {
      return this[dartx.getPropertyValue]('resize');
    }
    set [dartx.resize](value) {
      this[dartx.setProperty]('resize', value, '');
    }
    get [dartx.right]() {
      return this[dartx.getPropertyValue]('right');
    }
    set [dartx.right](value) {
      this[dartx.setProperty]('right', value, '');
    }
    get [dartx.rtlOrdering]() {
      return this[dartx.getPropertyValue]('rtl-ordering');
    }
    set [dartx.rtlOrdering](value) {
      this[dartx.setProperty]('rtl-ordering', value, '');
    }
    get [dartx.rubyPosition]() {
      return this[dartx.getPropertyValue]('ruby-position');
    }
    set [dartx.rubyPosition](value) {
      this[dartx.setProperty]('ruby-position', value, '');
    }
    get [dartx.scrollBehavior]() {
      return this[dartx.getPropertyValue]('scroll-behavior');
    }
    set [dartx.scrollBehavior](value) {
      this[dartx.setProperty]('scroll-behavior', value, '');
    }
    get [dartx.shapeImageThreshold]() {
      return this[dartx.getPropertyValue]('shape-image-threshold');
    }
    set [dartx.shapeImageThreshold](value) {
      this[dartx.setProperty]('shape-image-threshold', value, '');
    }
    get [dartx.shapeMargin]() {
      return this[dartx.getPropertyValue]('shape-margin');
    }
    set [dartx.shapeMargin](value) {
      this[dartx.setProperty]('shape-margin', value, '');
    }
    get [dartx.shapeOutside]() {
      return this[dartx.getPropertyValue]('shape-outside');
    }
    set [dartx.shapeOutside](value) {
      this[dartx.setProperty]('shape-outside', value, '');
    }
    get [dartx.size]() {
      return this[dartx.getPropertyValue]('size');
    }
    set [dartx.size](value) {
      this[dartx.setProperty]('size', value, '');
    }
    get [dartx.speak]() {
      return this[dartx.getPropertyValue]('speak');
    }
    set [dartx.speak](value) {
      this[dartx.setProperty]('speak', value, '');
    }
    get [dartx.src]() {
      return this[dartx.getPropertyValue]('src');
    }
    set [dartx.src](value) {
      this[dartx.setProperty]('src', value, '');
    }
    get [dartx.tabSize]() {
      return this[dartx.getPropertyValue]('tab-size');
    }
    set [dartx.tabSize](value) {
      this[dartx.setProperty]('tab-size', value, '');
    }
    get [dartx.tableLayout]() {
      return this[dartx.getPropertyValue]('table-layout');
    }
    set [dartx.tableLayout](value) {
      this[dartx.setProperty]('table-layout', value, '');
    }
    get [dartx.tapHighlightColor]() {
      return this[dartx.getPropertyValue]('tap-highlight-color');
    }
    set [dartx.tapHighlightColor](value) {
      this[dartx.setProperty]('tap-highlight-color', value, '');
    }
    get [dartx.textAlign]() {
      return this[dartx.getPropertyValue]('text-align');
    }
    set [dartx.textAlign](value) {
      this[dartx.setProperty]('text-align', value, '');
    }
    get [dartx.textAlignLast]() {
      return this[dartx.getPropertyValue]('text-align-last');
    }
    set [dartx.textAlignLast](value) {
      this[dartx.setProperty]('text-align-last', value, '');
    }
    get [dartx.textCombine]() {
      return this[dartx.getPropertyValue]('text-combine');
    }
    set [dartx.textCombine](value) {
      this[dartx.setProperty]('text-combine', value, '');
    }
    get [dartx.textDecoration]() {
      return this[dartx.getPropertyValue]('text-decoration');
    }
    set [dartx.textDecoration](value) {
      this[dartx.setProperty]('text-decoration', value, '');
    }
    get [dartx.textDecorationColor]() {
      return this[dartx.getPropertyValue]('text-decoration-color');
    }
    set [dartx.textDecorationColor](value) {
      this[dartx.setProperty]('text-decoration-color', value, '');
    }
    get [dartx.textDecorationLine]() {
      return this[dartx.getPropertyValue]('text-decoration-line');
    }
    set [dartx.textDecorationLine](value) {
      this[dartx.setProperty]('text-decoration-line', value, '');
    }
    get [dartx.textDecorationStyle]() {
      return this[dartx.getPropertyValue]('text-decoration-style');
    }
    set [dartx.textDecorationStyle](value) {
      this[dartx.setProperty]('text-decoration-style', value, '');
    }
    get [dartx.textDecorationsInEffect]() {
      return this[dartx.getPropertyValue]('text-decorations-in-effect');
    }
    set [dartx.textDecorationsInEffect](value) {
      this[dartx.setProperty]('text-decorations-in-effect', value, '');
    }
    get [dartx.textEmphasis]() {
      return this[dartx.getPropertyValue]('text-emphasis');
    }
    set [dartx.textEmphasis](value) {
      this[dartx.setProperty]('text-emphasis', value, '');
    }
    get [dartx.textEmphasisColor]() {
      return this[dartx.getPropertyValue]('text-emphasis-color');
    }
    set [dartx.textEmphasisColor](value) {
      this[dartx.setProperty]('text-emphasis-color', value, '');
    }
    get [dartx.textEmphasisPosition]() {
      return this[dartx.getPropertyValue]('text-emphasis-position');
    }
    set [dartx.textEmphasisPosition](value) {
      this[dartx.setProperty]('text-emphasis-position', value, '');
    }
    get [dartx.textEmphasisStyle]() {
      return this[dartx.getPropertyValue]('text-emphasis-style');
    }
    set [dartx.textEmphasisStyle](value) {
      this[dartx.setProperty]('text-emphasis-style', value, '');
    }
    get [dartx.textFillColor]() {
      return this[dartx.getPropertyValue]('text-fill-color');
    }
    set [dartx.textFillColor](value) {
      this[dartx.setProperty]('text-fill-color', value, '');
    }
    get [dartx.textIndent]() {
      return this[dartx.getPropertyValue]('text-indent');
    }
    set [dartx.textIndent](value) {
      this[dartx.setProperty]('text-indent', value, '');
    }
    get [dartx.textJustify]() {
      return this[dartx.getPropertyValue]('text-justify');
    }
    set [dartx.textJustify](value) {
      this[dartx.setProperty]('text-justify', value, '');
    }
    get [dartx.textLineThroughColor]() {
      return this[dartx.getPropertyValue]('text-line-through-color');
    }
    set [dartx.textLineThroughColor](value) {
      this[dartx.setProperty]('text-line-through-color', value, '');
    }
    get [dartx.textLineThroughMode]() {
      return this[dartx.getPropertyValue]('text-line-through-mode');
    }
    set [dartx.textLineThroughMode](value) {
      this[dartx.setProperty]('text-line-through-mode', value, '');
    }
    get [dartx.textLineThroughStyle]() {
      return this[dartx.getPropertyValue]('text-line-through-style');
    }
    set [dartx.textLineThroughStyle](value) {
      this[dartx.setProperty]('text-line-through-style', value, '');
    }
    get [dartx.textLineThroughWidth]() {
      return this[dartx.getPropertyValue]('text-line-through-width');
    }
    set [dartx.textLineThroughWidth](value) {
      this[dartx.setProperty]('text-line-through-width', value, '');
    }
    get [dartx.textOrientation]() {
      return this[dartx.getPropertyValue]('text-orientation');
    }
    set [dartx.textOrientation](value) {
      this[dartx.setProperty]('text-orientation', value, '');
    }
    get [dartx.textOverflow]() {
      return this[dartx.getPropertyValue]('text-overflow');
    }
    set [dartx.textOverflow](value) {
      this[dartx.setProperty]('text-overflow', value, '');
    }
    get [dartx.textOverlineColor]() {
      return this[dartx.getPropertyValue]('text-overline-color');
    }
    set [dartx.textOverlineColor](value) {
      this[dartx.setProperty]('text-overline-color', value, '');
    }
    get [dartx.textOverlineMode]() {
      return this[dartx.getPropertyValue]('text-overline-mode');
    }
    set [dartx.textOverlineMode](value) {
      this[dartx.setProperty]('text-overline-mode', value, '');
    }
    get [dartx.textOverlineStyle]() {
      return this[dartx.getPropertyValue]('text-overline-style');
    }
    set [dartx.textOverlineStyle](value) {
      this[dartx.setProperty]('text-overline-style', value, '');
    }
    get [dartx.textOverlineWidth]() {
      return this[dartx.getPropertyValue]('text-overline-width');
    }
    set [dartx.textOverlineWidth](value) {
      this[dartx.setProperty]('text-overline-width', value, '');
    }
    get [dartx.textRendering]() {
      return this[dartx.getPropertyValue]('text-rendering');
    }
    set [dartx.textRendering](value) {
      this[dartx.setProperty]('text-rendering', value, '');
    }
    get [dartx.textSecurity]() {
      return this[dartx.getPropertyValue]('text-security');
    }
    set [dartx.textSecurity](value) {
      this[dartx.setProperty]('text-security', value, '');
    }
    get [dartx.textShadow]() {
      return this[dartx.getPropertyValue]('text-shadow');
    }
    set [dartx.textShadow](value) {
      this[dartx.setProperty]('text-shadow', value, '');
    }
    get [dartx.textStroke]() {
      return this[dartx.getPropertyValue]('text-stroke');
    }
    set [dartx.textStroke](value) {
      this[dartx.setProperty]('text-stroke', value, '');
    }
    get [dartx.textStrokeColor]() {
      return this[dartx.getPropertyValue]('text-stroke-color');
    }
    set [dartx.textStrokeColor](value) {
      this[dartx.setProperty]('text-stroke-color', value, '');
    }
    get [dartx.textStrokeWidth]() {
      return this[dartx.getPropertyValue]('text-stroke-width');
    }
    set [dartx.textStrokeWidth](value) {
      this[dartx.setProperty]('text-stroke-width', value, '');
    }
    get [dartx.textTransform]() {
      return this[dartx.getPropertyValue]('text-transform');
    }
    set [dartx.textTransform](value) {
      this[dartx.setProperty]('text-transform', value, '');
    }
    get [dartx.textUnderlineColor]() {
      return this[dartx.getPropertyValue]('text-underline-color');
    }
    set [dartx.textUnderlineColor](value) {
      this[dartx.setProperty]('text-underline-color', value, '');
    }
    get [dartx.textUnderlineMode]() {
      return this[dartx.getPropertyValue]('text-underline-mode');
    }
    set [dartx.textUnderlineMode](value) {
      this[dartx.setProperty]('text-underline-mode', value, '');
    }
    get [dartx.textUnderlinePosition]() {
      return this[dartx.getPropertyValue]('text-underline-position');
    }
    set [dartx.textUnderlinePosition](value) {
      this[dartx.setProperty]('text-underline-position', value, '');
    }
    get [dartx.textUnderlineStyle]() {
      return this[dartx.getPropertyValue]('text-underline-style');
    }
    set [dartx.textUnderlineStyle](value) {
      this[dartx.setProperty]('text-underline-style', value, '');
    }
    get [dartx.textUnderlineWidth]() {
      return this[dartx.getPropertyValue]('text-underline-width');
    }
    set [dartx.textUnderlineWidth](value) {
      this[dartx.setProperty]('text-underline-width', value, '');
    }
    get [dartx.top]() {
      return this[dartx.getPropertyValue]('top');
    }
    set [dartx.top](value) {
      this[dartx.setProperty]('top', value, '');
    }
    get [dartx.touchAction]() {
      return this[dartx.getPropertyValue]('touch-action');
    }
    set [dartx.touchAction](value) {
      this[dartx.setProperty]('touch-action', value, '');
    }
    get [dartx.touchActionDelay]() {
      return this[dartx.getPropertyValue]('touch-action-delay');
    }
    set [dartx.touchActionDelay](value) {
      this[dartx.setProperty]('touch-action-delay', value, '');
    }
    get [dartx.transform]() {
      return this[dartx.getPropertyValue]('transform');
    }
    set [dartx.transform](value) {
      this[dartx.setProperty]('transform', value, '');
    }
    get [dartx.transformOrigin]() {
      return this[dartx.getPropertyValue]('transform-origin');
    }
    set [dartx.transformOrigin](value) {
      this[dartx.setProperty]('transform-origin', value, '');
    }
    get [dartx.transformOriginX]() {
      return this[dartx.getPropertyValue]('transform-origin-x');
    }
    set [dartx.transformOriginX](value) {
      this[dartx.setProperty]('transform-origin-x', value, '');
    }
    get [dartx.transformOriginY]() {
      return this[dartx.getPropertyValue]('transform-origin-y');
    }
    set [dartx.transformOriginY](value) {
      this[dartx.setProperty]('transform-origin-y', value, '');
    }
    get [dartx.transformOriginZ]() {
      return this[dartx.getPropertyValue]('transform-origin-z');
    }
    set [dartx.transformOriginZ](value) {
      this[dartx.setProperty]('transform-origin-z', value, '');
    }
    get [dartx.transformStyle]() {
      return this[dartx.getPropertyValue]('transform-style');
    }
    set [dartx.transformStyle](value) {
      this[dartx.setProperty]('transform-style', value, '');
    }
    get [dartx.transition]() {
      return this[dartx.getPropertyValue]('transition');
    }
    set [dartx.transition](value) {
      this[dartx.setProperty]('transition', value, '');
    }
    get [dartx.transitionDelay]() {
      return this[dartx.getPropertyValue]('transition-delay');
    }
    set [dartx.transitionDelay](value) {
      this[dartx.setProperty]('transition-delay', value, '');
    }
    get [dartx.transitionDuration]() {
      return this[dartx.getPropertyValue]('transition-duration');
    }
    set [dartx.transitionDuration](value) {
      this[dartx.setProperty]('transition-duration', value, '');
    }
    get [dartx.transitionProperty]() {
      return this[dartx.getPropertyValue]('transition-property');
    }
    set [dartx.transitionProperty](value) {
      this[dartx.setProperty]('transition-property', value, '');
    }
    get [dartx.transitionTimingFunction]() {
      return this[dartx.getPropertyValue]('transition-timing-function');
    }
    set [dartx.transitionTimingFunction](value) {
      this[dartx.setProperty]('transition-timing-function', value, '');
    }
    get [dartx.unicodeBidi]() {
      return this[dartx.getPropertyValue]('unicode-bidi');
    }
    set [dartx.unicodeBidi](value) {
      this[dartx.setProperty]('unicode-bidi', value, '');
    }
    get [dartx.unicodeRange]() {
      return this[dartx.getPropertyValue]('unicode-range');
    }
    set [dartx.unicodeRange](value) {
      this[dartx.setProperty]('unicode-range', value, '');
    }
    get [dartx.userDrag]() {
      return this[dartx.getPropertyValue]('user-drag');
    }
    set [dartx.userDrag](value) {
      this[dartx.setProperty]('user-drag', value, '');
    }
    get [dartx.userModify]() {
      return this[dartx.getPropertyValue]('user-modify');
    }
    set [dartx.userModify](value) {
      this[dartx.setProperty]('user-modify', value, '');
    }
    get [dartx.userSelect]() {
      return this[dartx.getPropertyValue]('user-select');
    }
    set [dartx.userSelect](value) {
      this[dartx.setProperty]('user-select', value, '');
    }
    get [dartx.userZoom]() {
      return this[dartx.getPropertyValue]('user-zoom');
    }
    set [dartx.userZoom](value) {
      this[dartx.setProperty]('user-zoom', value, '');
    }
    get [dartx.verticalAlign]() {
      return this[dartx.getPropertyValue]('vertical-align');
    }
    set [dartx.verticalAlign](value) {
      this[dartx.setProperty]('vertical-align', value, '');
    }
    get [dartx.visibility]() {
      return this[dartx.getPropertyValue]('visibility');
    }
    set [dartx.visibility](value) {
      this[dartx.setProperty]('visibility', value, '');
    }
    get [dartx.whiteSpace]() {
      return this[dartx.getPropertyValue]('white-space');
    }
    set [dartx.whiteSpace](value) {
      this[dartx.setProperty]('white-space', value, '');
    }
    get [dartx.widows]() {
      return this[dartx.getPropertyValue]('widows');
    }
    set [dartx.widows](value) {
      this[dartx.setProperty]('widows', value, '');
    }
    get [dartx.width]() {
      return this[dartx.getPropertyValue]('width');
    }
    set [dartx.width](value) {
      this[dartx.setProperty]('width', value, '');
    }
    get [dartx.willChange]() {
      return this[dartx.getPropertyValue]('will-change');
    }
    set [dartx.willChange](value) {
      this[dartx.setProperty]('will-change', value, '');
    }
    get [dartx.wordBreak]() {
      return this[dartx.getPropertyValue]('word-break');
    }
    set [dartx.wordBreak](value) {
      this[dartx.setProperty]('word-break', value, '');
    }
    get [dartx.wordSpacing]() {
      return this[dartx.getPropertyValue]('word-spacing');
    }
    set [dartx.wordSpacing](value) {
      this[dartx.setProperty]('word-spacing', value, '');
    }
    get [dartx.wordWrap]() {
      return this[dartx.getPropertyValue]('word-wrap');
    }
    set [dartx.wordWrap](value) {
      this[dartx.setProperty]('word-wrap', value, '');
    }
    get [dartx.wrapFlow]() {
      return this[dartx.getPropertyValue]('wrap-flow');
    }
    set [dartx.wrapFlow](value) {
      this[dartx.setProperty]('wrap-flow', value, '');
    }
    get [dartx.wrapThrough]() {
      return this[dartx.getPropertyValue]('wrap-through');
    }
    set [dartx.wrapThrough](value) {
      this[dartx.setProperty]('wrap-through', value, '');
    }
    get [dartx.writingMode]() {
      return this[dartx.getPropertyValue]('writing-mode');
    }
    set [dartx.writingMode](value) {
      this[dartx.setProperty]('writing-mode', value, '');
    }
    get [dartx.zIndex]() {
      return this[dartx.getPropertyValue]('z-index');
    }
    set [dartx.zIndex](value) {
      this[dartx.setProperty]('z-index', value, '');
    }
    get [dartx.zoom]() {
      return this[dartx.getPropertyValue]('zoom');
    }
    set [dartx.zoom](value) {
      this[dartx.setProperty]('zoom', value, '');
    }
  }
  const _getPropertyValueHelper = Symbol('_getPropertyValueHelper');
  const _supportsProperty = Symbol('_supportsProperty');
  const _getPropertyValue = Symbol('_getPropertyValue');
  const _setPropertyHelper = Symbol('_setPropertyHelper');
  const _browserPropertyName = Symbol('_browserPropertyName');
  const __setter__ = Symbol('__setter__');
  const _background = Symbol('_background');
  const _backgroundAttachment = Symbol('_backgroundAttachment');
  const _backgroundColor = Symbol('_backgroundColor');
  const _backgroundImage = Symbol('_backgroundImage');
  const _backgroundPosition = Symbol('_backgroundPosition');
  const _backgroundRepeat = Symbol('_backgroundRepeat');
  const _border = Symbol('_border');
  const _borderBottom = Symbol('_borderBottom');
  const _borderBottomColor = Symbol('_borderBottomColor');
  const _borderBottomStyle = Symbol('_borderBottomStyle');
  const _borderBottomWidth = Symbol('_borderBottomWidth');
  const _borderCollapse = Symbol('_borderCollapse');
  const _borderColor = Symbol('_borderColor');
  const _borderLeft = Symbol('_borderLeft');
  const _borderLeftColor = Symbol('_borderLeftColor');
  const _borderLeftStyle = Symbol('_borderLeftStyle');
  const _borderLeftWidth = Symbol('_borderLeftWidth');
  const _borderRight = Symbol('_borderRight');
  const _borderRightColor = Symbol('_borderRightColor');
  const _borderRightStyle = Symbol('_borderRightStyle');
  const _borderRightWidth = Symbol('_borderRightWidth');
  const _borderSpacing = Symbol('_borderSpacing');
  const _borderStyle = Symbol('_borderStyle');
  const _borderTop = Symbol('_borderTop');
  const _borderTopColor = Symbol('_borderTopColor');
  const _borderTopStyle = Symbol('_borderTopStyle');
  const _borderTopWidth = Symbol('_borderTopWidth');
  const _borderWidth = Symbol('_borderWidth');
  const _bottom = Symbol('_bottom');
  const _captionSide = Symbol('_captionSide');
  const _clear = Symbol('_clear');
  const _clip = Symbol('_clip');
  const _color = Symbol('_color');
  const _content = Symbol('_content');
  const _cursor = Symbol('_cursor');
  const _direction = Symbol('_direction');
  const _display = Symbol('_display');
  const _emptyCells = Symbol('_emptyCells');
  const _font = Symbol('_font');
  const _fontFamily = Symbol('_fontFamily');
  const _fontSize = Symbol('_fontSize');
  const _fontStyle = Symbol('_fontStyle');
  const _fontVariant = Symbol('_fontVariant');
  const _fontWeight = Symbol('_fontWeight');
  const _height = Symbol('_height');
  const _left = Symbol('_left');
  const _letterSpacing = Symbol('_letterSpacing');
  const _lineHeight = Symbol('_lineHeight');
  const _listStyle = Symbol('_listStyle');
  const _listStyleImage = Symbol('_listStyleImage');
  const _listStylePosition = Symbol('_listStylePosition');
  const _listStyleType = Symbol('_listStyleType');
  const _margin = Symbol('_margin');
  const _marginBottom = Symbol('_marginBottom');
  const _marginLeft = Symbol('_marginLeft');
  const _marginRight = Symbol('_marginRight');
  const _marginTop = Symbol('_marginTop');
  const _maxHeight = Symbol('_maxHeight');
  const _maxWidth = Symbol('_maxWidth');
  const _minHeight = Symbol('_minHeight');
  const _minWidth = Symbol('_minWidth');
  const _outline = Symbol('_outline');
  const _outlineColor = Symbol('_outlineColor');
  const _outlineStyle = Symbol('_outlineStyle');
  const _outlineWidth = Symbol('_outlineWidth');
  const _overflow = Symbol('_overflow');
  const _padding = Symbol('_padding');
  const _paddingBottom = Symbol('_paddingBottom');
  const _paddingLeft = Symbol('_paddingLeft');
  const _paddingRight = Symbol('_paddingRight');
  const _paddingTop = Symbol('_paddingTop');
  const _pageBreakAfter = Symbol('_pageBreakAfter');
  const _pageBreakBefore = Symbol('_pageBreakBefore');
  const _pageBreakInside = Symbol('_pageBreakInside');
  const _position = Symbol('_position');
  const _quotes = Symbol('_quotes');
  const _right = Symbol('_right');
  const _tableLayout = Symbol('_tableLayout');
  const _textAlign = Symbol('_textAlign');
  const _textDecoration = Symbol('_textDecoration');
  const _textIndent = Symbol('_textIndent');
  const _textTransform = Symbol('_textTransform');
  const _top = Symbol('_top');
  const _unicodeBidi = Symbol('_unicodeBidi');
  const _verticalAlign = Symbol('_verticalAlign');
  const _visibility = Symbol('_visibility');
  const _whiteSpace = Symbol('_whiteSpace');
  const _width = Symbol('_width');
  const _wordSpacing = Symbol('_wordSpacing');
  const _zIndex = Symbol('_zIndex');
  dart.defineExtensionNames([
    'getPropertyValue',
    'supportsProperty',
    'setProperty',
    'getPropertyPriority',
    'item',
    'removeProperty',
    'background',
    'background',
    'backgroundAttachment',
    'backgroundAttachment',
    'backgroundColor',
    'backgroundColor',
    'backgroundImage',
    'backgroundImage',
    'backgroundPosition',
    'backgroundPosition',
    'backgroundRepeat',
    'backgroundRepeat',
    'border',
    'border',
    'borderBottom',
    'borderBottom',
    'borderBottomColor',
    'borderBottomColor',
    'borderBottomStyle',
    'borderBottomStyle',
    'borderBottomWidth',
    'borderBottomWidth',
    'borderCollapse',
    'borderCollapse',
    'borderColor',
    'borderColor',
    'borderLeft',
    'borderLeft',
    'borderLeftColor',
    'borderLeftColor',
    'borderLeftStyle',
    'borderLeftStyle',
    'borderLeftWidth',
    'borderLeftWidth',
    'borderRight',
    'borderRight',
    'borderRightColor',
    'borderRightColor',
    'borderRightStyle',
    'borderRightStyle',
    'borderRightWidth',
    'borderRightWidth',
    'borderSpacing',
    'borderSpacing',
    'borderStyle',
    'borderStyle',
    'borderTop',
    'borderTop',
    'borderTopColor',
    'borderTopColor',
    'borderTopStyle',
    'borderTopStyle',
    'borderTopWidth',
    'borderTopWidth',
    'borderWidth',
    'borderWidth',
    'bottom',
    'bottom',
    'captionSide',
    'captionSide',
    'clear',
    'clear',
    'clip',
    'clip',
    'color',
    'color',
    'content',
    'content',
    'cursor',
    'cursor',
    'direction',
    'direction',
    'display',
    'display',
    'emptyCells',
    'emptyCells',
    'font',
    'font',
    'fontFamily',
    'fontFamily',
    'fontSize',
    'fontSize',
    'fontStyle',
    'fontStyle',
    'fontVariant',
    'fontVariant',
    'fontWeight',
    'fontWeight',
    'height',
    'height',
    'left',
    'left',
    'letterSpacing',
    'letterSpacing',
    'lineHeight',
    'lineHeight',
    'listStyle',
    'listStyle',
    'listStyleImage',
    'listStyleImage',
    'listStylePosition',
    'listStylePosition',
    'listStyleType',
    'listStyleType',
    'margin',
    'margin',
    'marginBottom',
    'marginBottom',
    'marginLeft',
    'marginLeft',
    'marginRight',
    'marginRight',
    'marginTop',
    'marginTop',
    'maxHeight',
    'maxHeight',
    'maxWidth',
    'maxWidth',
    'minHeight',
    'minHeight',
    'minWidth',
    'minWidth',
    'outline',
    'outline',
    'outlineColor',
    'outlineColor',
    'outlineStyle',
    'outlineStyle',
    'outlineWidth',
    'outlineWidth',
    'overflow',
    'overflow',
    'padding',
    'padding',
    'paddingBottom',
    'paddingBottom',
    'paddingLeft',
    'paddingLeft',
    'paddingRight',
    'paddingRight',
    'paddingTop',
    'paddingTop',
    'pageBreakAfter',
    'pageBreakAfter',
    'pageBreakBefore',
    'pageBreakBefore',
    'pageBreakInside',
    'pageBreakInside',
    'position',
    'position',
    'quotes',
    'quotes',
    'right',
    'right',
    'tableLayout',
    'tableLayout',
    'textAlign',
    'textAlign',
    'textDecoration',
    'textDecoration',
    'textIndent',
    'textIndent',
    'textTransform',
    'textTransform',
    'top',
    'top',
    'unicodeBidi',
    'unicodeBidi',
    'verticalAlign',
    'verticalAlign',
    'visibility',
    'visibility',
    'whiteSpace',
    'whiteSpace',
    'width',
    'width',
    'wordSpacing',
    'wordSpacing',
    'zIndex',
    'zIndex',
    'cssText',
    'length',
    'parentRule'
  ]);
  class CssStyleDeclaration extends dart.mixin(_interceptors.Interceptor, CssStyleDeclarationBase) {
    static new() {
      return CssStyleDeclaration.css('');
    }
    static css(css) {
      let style = Element.tag('div')[dartx.style];
      style[dartx.cssText] = css;
      return style;
    }
    [dartx.getPropertyValue](propertyName) {
      let propValue = this[_getPropertyValueHelper](propertyName);
      return propValue != null ? propValue : '';
    }
    [_getPropertyValueHelper](propertyName) {
      if (dart.notNull(this[_supportsProperty](CssStyleDeclaration._camelCase(propertyName)))) {
        return this[_getPropertyValue](propertyName);
      } else {
        return this[_getPropertyValue](dart.notNull(html_common.Device.cssPrefix) + dart.notNull(propertyName));
      }
    }
    [dartx.supportsProperty](propertyName) {
      return dart.notNull(this[_supportsProperty](propertyName)) || dart.notNull(this[_supportsProperty](CssStyleDeclaration._camelCase(dart.notNull(html_common.Device.cssPrefix) + dart.notNull(propertyName))));
    }
    [_supportsProperty](propertyName) {
      return propertyName in this;
    }
    [dartx.setProperty](propertyName, value, priority) {
      if (priority === void 0) priority = null;
      return this[_setPropertyHelper](this[_browserPropertyName](propertyName), value, priority);
    }
    [_browserPropertyName](propertyName) {
      let name = CssStyleDeclaration._readCache(propertyName);
      if (typeof name == 'string') return name;
      if (dart.notNull(this[_supportsProperty](CssStyleDeclaration._camelCase(propertyName)))) {
        name = propertyName;
      } else {
        name = dart.notNull(html_common.Device.cssPrefix) + dart.notNull(propertyName);
      }
      CssStyleDeclaration._writeCache(propertyName, name);
      return name;
    }
    static _readCache(key) {
      return dart.as(CssStyleDeclaration._propertyCache[key], core.String);
    }
    static _writeCache(key, value) {
      CssStyleDeclaration._propertyCache[key] = value;
    }
    static _camelCase(hyphenated) {
      let replacedMs = hyphenated.replace(/^-ms-/, "ms-");
      let fToUpper = dart.const(new _foreign_helper.JS_CONST('function(_, letter) { return letter.toUpperCase(); }'));
      return replacedMs.replace(/-([\da-z])/ig, fToUpper);
    }
    [_setPropertyHelper](propertyName, value, priority) {
      if (priority === void 0) priority = null;
      if (value == null) value = '';
      if (priority == null) priority = '';
      this.setProperty(propertyName, value, priority);
    }
    static get supportsTransitions() {
      return exports.document[dartx.body][dartx.style][dartx.supportsProperty]('transition');
    }
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.cssText]() {
      return this.cssText;
    }
    set [dartx.cssText](value) {
      this.cssText = value;
    }
    get [dartx.length]() {
      return this.length;
    }
    get [dartx.parentRule]() {
      return this.parentRule;
    }
    [__getter__](name) {
      return this.__getter__(name);
    }
    [__setter__](propertyName, propertyValue) {
      return this.__setter__(propertyName, propertyValue);
    }
    [dartx.getPropertyPriority](propertyName) {
      return this.getPropertyPriority(propertyName);
    }
    [_getPropertyValue](propertyName) {
      return this.getPropertyValue(propertyName);
    }
    [dartx.item](index) {
      return this.item(index);
    }
    [dartx.removeProperty](propertyName) {
      return this.removeProperty(propertyName);
    }
    get [dartx.background]() {
      return this[_background];
    }
    set [dartx.background](value) {
      this[_background] = value == null ? '' : value;
    }
    get [_background]() {
      return this.background;
    }
    set [_background](value) {
      this.background = value;
    }
    get [dartx.backgroundAttachment]() {
      return this[_backgroundAttachment];
    }
    set [dartx.backgroundAttachment](value) {
      this[_backgroundAttachment] = value == null ? '' : value;
    }
    get [_backgroundAttachment]() {
      return this.backgroundAttachment;
    }
    set [_backgroundAttachment](value) {
      this.backgroundAttachment = value;
    }
    get [dartx.backgroundColor]() {
      return this[_backgroundColor];
    }
    set [dartx.backgroundColor](value) {
      this[_backgroundColor] = value == null ? '' : value;
    }
    get [_backgroundColor]() {
      return this.backgroundColor;
    }
    set [_backgroundColor](value) {
      this.backgroundColor = value;
    }
    get [dartx.backgroundImage]() {
      return this[_backgroundImage];
    }
    set [dartx.backgroundImage](value) {
      this[_backgroundImage] = value == null ? '' : value;
    }
    get [_backgroundImage]() {
      return this.backgroundImage;
    }
    set [_backgroundImage](value) {
      this.backgroundImage = value;
    }
    get [dartx.backgroundPosition]() {
      return this[_backgroundPosition];
    }
    set [dartx.backgroundPosition](value) {
      this[_backgroundPosition] = value == null ? '' : value;
    }
    get [_backgroundPosition]() {
      return this.backgroundPosition;
    }
    set [_backgroundPosition](value) {
      this.backgroundPosition = value;
    }
    get [dartx.backgroundRepeat]() {
      return this[_backgroundRepeat];
    }
    set [dartx.backgroundRepeat](value) {
      this[_backgroundRepeat] = value == null ? '' : value;
    }
    get [_backgroundRepeat]() {
      return this.backgroundRepeat;
    }
    set [_backgroundRepeat](value) {
      this.backgroundRepeat = value;
    }
    get [dartx.border]() {
      return this[_border];
    }
    set [dartx.border](value) {
      this[_border] = value == null ? '' : value;
    }
    get [_border]() {
      return this.border;
    }
    set [_border](value) {
      this.border = value;
    }
    get [dartx.borderBottom]() {
      return this[_borderBottom];
    }
    set [dartx.borderBottom](value) {
      this[_borderBottom] = value == null ? '' : value;
    }
    get [_borderBottom]() {
      return this.borderBottom;
    }
    set [_borderBottom](value) {
      this.borderBottom = value;
    }
    get [dartx.borderBottomColor]() {
      return this[_borderBottomColor];
    }
    set [dartx.borderBottomColor](value) {
      this[_borderBottomColor] = value == null ? '' : value;
    }
    get [_borderBottomColor]() {
      return this.borderBottomColor;
    }
    set [_borderBottomColor](value) {
      this.borderBottomColor = value;
    }
    get [dartx.borderBottomStyle]() {
      return this[_borderBottomStyle];
    }
    set [dartx.borderBottomStyle](value) {
      this[_borderBottomStyle] = value == null ? '' : value;
    }
    get [_borderBottomStyle]() {
      return this.borderBottomStyle;
    }
    set [_borderBottomStyle](value) {
      this.borderBottomStyle = value;
    }
    get [dartx.borderBottomWidth]() {
      return this[_borderBottomWidth];
    }
    set [dartx.borderBottomWidth](value) {
      this[_borderBottomWidth] = value == null ? '' : value;
    }
    get [_borderBottomWidth]() {
      return this.borderBottomWidth;
    }
    set [_borderBottomWidth](value) {
      this.borderBottomWidth = value;
    }
    get [dartx.borderCollapse]() {
      return this[_borderCollapse];
    }
    set [dartx.borderCollapse](value) {
      this[_borderCollapse] = value == null ? '' : value;
    }
    get [_borderCollapse]() {
      return this.borderCollapse;
    }
    set [_borderCollapse](value) {
      this.borderCollapse = value;
    }
    get [dartx.borderColor]() {
      return this[_borderColor];
    }
    set [dartx.borderColor](value) {
      this[_borderColor] = value == null ? '' : value;
    }
    get [_borderColor]() {
      return this.borderColor;
    }
    set [_borderColor](value) {
      this.borderColor = value;
    }
    get [dartx.borderLeft]() {
      return this[_borderLeft];
    }
    set [dartx.borderLeft](value) {
      this[_borderLeft] = value == null ? '' : value;
    }
    get [_borderLeft]() {
      return this.borderLeft;
    }
    set [_borderLeft](value) {
      this.borderLeft = value;
    }
    get [dartx.borderLeftColor]() {
      return this[_borderLeftColor];
    }
    set [dartx.borderLeftColor](value) {
      this[_borderLeftColor] = value == null ? '' : value;
    }
    get [_borderLeftColor]() {
      return this.borderLeftColor;
    }
    set [_borderLeftColor](value) {
      this.borderLeftColor = value;
    }
    get [dartx.borderLeftStyle]() {
      return this[_borderLeftStyle];
    }
    set [dartx.borderLeftStyle](value) {
      this[_borderLeftStyle] = value == null ? '' : value;
    }
    get [_borderLeftStyle]() {
      return this.borderLeftStyle;
    }
    set [_borderLeftStyle](value) {
      this.borderLeftStyle = value;
    }
    get [dartx.borderLeftWidth]() {
      return this[_borderLeftWidth];
    }
    set [dartx.borderLeftWidth](value) {
      this[_borderLeftWidth] = value == null ? '' : value;
    }
    get [_borderLeftWidth]() {
      return this.borderLeftWidth;
    }
    set [_borderLeftWidth](value) {
      this.borderLeftWidth = value;
    }
    get [dartx.borderRight]() {
      return this[_borderRight];
    }
    set [dartx.borderRight](value) {
      this[_borderRight] = value == null ? '' : value;
    }
    get [_borderRight]() {
      return this.borderRight;
    }
    set [_borderRight](value) {
      this.borderRight = value;
    }
    get [dartx.borderRightColor]() {
      return this[_borderRightColor];
    }
    set [dartx.borderRightColor](value) {
      this[_borderRightColor] = value == null ? '' : value;
    }
    get [_borderRightColor]() {
      return this.borderRightColor;
    }
    set [_borderRightColor](value) {
      this.borderRightColor = value;
    }
    get [dartx.borderRightStyle]() {
      return this[_borderRightStyle];
    }
    set [dartx.borderRightStyle](value) {
      this[_borderRightStyle] = value == null ? '' : value;
    }
    get [_borderRightStyle]() {
      return this.borderRightStyle;
    }
    set [_borderRightStyle](value) {
      this.borderRightStyle = value;
    }
    get [dartx.borderRightWidth]() {
      return this[_borderRightWidth];
    }
    set [dartx.borderRightWidth](value) {
      this[_borderRightWidth] = value == null ? '' : value;
    }
    get [_borderRightWidth]() {
      return this.borderRightWidth;
    }
    set [_borderRightWidth](value) {
      this.borderRightWidth = value;
    }
    get [dartx.borderSpacing]() {
      return this[_borderSpacing];
    }
    set [dartx.borderSpacing](value) {
      this[_borderSpacing] = value == null ? '' : value;
    }
    get [_borderSpacing]() {
      return this.borderSpacing;
    }
    set [_borderSpacing](value) {
      this.borderSpacing = value;
    }
    get [dartx.borderStyle]() {
      return this[_borderStyle];
    }
    set [dartx.borderStyle](value) {
      this[_borderStyle] = value == null ? '' : value;
    }
    get [_borderStyle]() {
      return this.borderStyle;
    }
    set [_borderStyle](value) {
      this.borderStyle = value;
    }
    get [dartx.borderTop]() {
      return this[_borderTop];
    }
    set [dartx.borderTop](value) {
      this[_borderTop] = value == null ? '' : value;
    }
    get [_borderTop]() {
      return this.borderTop;
    }
    set [_borderTop](value) {
      this.borderTop = value;
    }
    get [dartx.borderTopColor]() {
      return this[_borderTopColor];
    }
    set [dartx.borderTopColor](value) {
      this[_borderTopColor] = value == null ? '' : value;
    }
    get [_borderTopColor]() {
      return this.borderTopColor;
    }
    set [_borderTopColor](value) {
      this.borderTopColor = value;
    }
    get [dartx.borderTopStyle]() {
      return this[_borderTopStyle];
    }
    set [dartx.borderTopStyle](value) {
      this[_borderTopStyle] = value == null ? '' : value;
    }
    get [_borderTopStyle]() {
      return this.borderTopStyle;
    }
    set [_borderTopStyle](value) {
      this.borderTopStyle = value;
    }
    get [dartx.borderTopWidth]() {
      return this[_borderTopWidth];
    }
    set [dartx.borderTopWidth](value) {
      this[_borderTopWidth] = value == null ? '' : value;
    }
    get [_borderTopWidth]() {
      return this.borderTopWidth;
    }
    set [_borderTopWidth](value) {
      this.borderTopWidth = value;
    }
    get [dartx.borderWidth]() {
      return this[_borderWidth];
    }
    set [dartx.borderWidth](value) {
      this[_borderWidth] = value == null ? '' : value;
    }
    get [_borderWidth]() {
      return this.borderWidth;
    }
    set [_borderWidth](value) {
      this.borderWidth = value;
    }
    get [dartx.bottom]() {
      return this[_bottom];
    }
    set [dartx.bottom](value) {
      this[_bottom] = value == null ? '' : value;
    }
    get [_bottom]() {
      return this.bottom;
    }
    set [_bottom](value) {
      this.bottom = value;
    }
    get [dartx.captionSide]() {
      return this[_captionSide];
    }
    set [dartx.captionSide](value) {
      this[_captionSide] = value == null ? '' : value;
    }
    get [_captionSide]() {
      return this.captionSide;
    }
    set [_captionSide](value) {
      this.captionSide = value;
    }
    get [dartx.clear]() {
      return this[_clear];
    }
    set [dartx.clear](value) {
      this[_clear] = value == null ? '' : value;
    }
    get [_clear]() {
      return this.clear;
    }
    set [_clear](value) {
      this.clear = value;
    }
    get [dartx.clip]() {
      return this[_clip];
    }
    set [dartx.clip](value) {
      this[_clip] = value == null ? '' : value;
    }
    get [_clip]() {
      return this.clip;
    }
    set [_clip](value) {
      this.clip = value;
    }
    get [dartx.color]() {
      return this[_color];
    }
    set [dartx.color](value) {
      this[_color] = value == null ? '' : value;
    }
    get [_color]() {
      return this.color;
    }
    set [_color](value) {
      this.color = value;
    }
    get [dartx.content]() {
      return this[_content];
    }
    set [dartx.content](value) {
      this[_content] = value == null ? '' : value;
    }
    get [_content]() {
      return this.content;
    }
    set [_content](value) {
      this.content = value;
    }
    get [dartx.cursor]() {
      return this[_cursor];
    }
    set [dartx.cursor](value) {
      this[_cursor] = value == null ? '' : value;
    }
    get [_cursor]() {
      return this.cursor;
    }
    set [_cursor](value) {
      this.cursor = value;
    }
    get [dartx.direction]() {
      return this[_direction];
    }
    set [dartx.direction](value) {
      this[_direction] = value == null ? '' : value;
    }
    get [_direction]() {
      return this.direction;
    }
    set [_direction](value) {
      this.direction = value;
    }
    get [dartx.display]() {
      return this[_display];
    }
    set [dartx.display](value) {
      this[_display] = value == null ? '' : value;
    }
    get [_display]() {
      return this.display;
    }
    set [_display](value) {
      this.display = value;
    }
    get [dartx.emptyCells]() {
      return this[_emptyCells];
    }
    set [dartx.emptyCells](value) {
      this[_emptyCells] = value == null ? '' : value;
    }
    get [_emptyCells]() {
      return this.emptyCells;
    }
    set [_emptyCells](value) {
      this.emptyCells = value;
    }
    get [dartx.font]() {
      return this[_font];
    }
    set [dartx.font](value) {
      this[_font] = value == null ? '' : value;
    }
    get [_font]() {
      return this.font;
    }
    set [_font](value) {
      this.font = value;
    }
    get [dartx.fontFamily]() {
      return this[_fontFamily];
    }
    set [dartx.fontFamily](value) {
      this[_fontFamily] = value == null ? '' : value;
    }
    get [_fontFamily]() {
      return this.fontFamily;
    }
    set [_fontFamily](value) {
      this.fontFamily = value;
    }
    get [dartx.fontSize]() {
      return this[_fontSize];
    }
    set [dartx.fontSize](value) {
      this[_fontSize] = value == null ? '' : value;
    }
    get [_fontSize]() {
      return this.fontSize;
    }
    set [_fontSize](value) {
      this.fontSize = value;
    }
    get [dartx.fontStyle]() {
      return this[_fontStyle];
    }
    set [dartx.fontStyle](value) {
      this[_fontStyle] = value == null ? '' : value;
    }
    get [_fontStyle]() {
      return this.fontStyle;
    }
    set [_fontStyle](value) {
      this.fontStyle = value;
    }
    get [dartx.fontVariant]() {
      return this[_fontVariant];
    }
    set [dartx.fontVariant](value) {
      this[_fontVariant] = value == null ? '' : value;
    }
    get [_fontVariant]() {
      return this.fontVariant;
    }
    set [_fontVariant](value) {
      this.fontVariant = value;
    }
    get [dartx.fontWeight]() {
      return this[_fontWeight];
    }
    set [dartx.fontWeight](value) {
      this[_fontWeight] = value == null ? '' : value;
    }
    get [_fontWeight]() {
      return this.fontWeight;
    }
    set [_fontWeight](value) {
      this.fontWeight = value;
    }
    get [dartx.height]() {
      return this[_height];
    }
    set [dartx.height](value) {
      this[_height] = value == null ? '' : value;
    }
    get [_height]() {
      return this.height;
    }
    set [_height](value) {
      this.height = value;
    }
    get [dartx.left]() {
      return this[_left];
    }
    set [dartx.left](value) {
      this[_left] = value == null ? '' : value;
    }
    get [_left]() {
      return this.left;
    }
    set [_left](value) {
      this.left = value;
    }
    get [dartx.letterSpacing]() {
      return this[_letterSpacing];
    }
    set [dartx.letterSpacing](value) {
      this[_letterSpacing] = value == null ? '' : value;
    }
    get [_letterSpacing]() {
      return this.letterSpacing;
    }
    set [_letterSpacing](value) {
      this.letterSpacing = value;
    }
    get [dartx.lineHeight]() {
      return this[_lineHeight];
    }
    set [dartx.lineHeight](value) {
      this[_lineHeight] = value == null ? '' : value;
    }
    get [_lineHeight]() {
      return this.lineHeight;
    }
    set [_lineHeight](value) {
      this.lineHeight = value;
    }
    get [dartx.listStyle]() {
      return this[_listStyle];
    }
    set [dartx.listStyle](value) {
      this[_listStyle] = value == null ? '' : value;
    }
    get [_listStyle]() {
      return this.listStyle;
    }
    set [_listStyle](value) {
      this.listStyle = value;
    }
    get [dartx.listStyleImage]() {
      return this[_listStyleImage];
    }
    set [dartx.listStyleImage](value) {
      this[_listStyleImage] = value == null ? '' : value;
    }
    get [_listStyleImage]() {
      return this.listStyleImage;
    }
    set [_listStyleImage](value) {
      this.listStyleImage = value;
    }
    get [dartx.listStylePosition]() {
      return this[_listStylePosition];
    }
    set [dartx.listStylePosition](value) {
      this[_listStylePosition] = value == null ? '' : value;
    }
    get [_listStylePosition]() {
      return this.listStylePosition;
    }
    set [_listStylePosition](value) {
      this.listStylePosition = value;
    }
    get [dartx.listStyleType]() {
      return this[_listStyleType];
    }
    set [dartx.listStyleType](value) {
      this[_listStyleType] = value == null ? '' : value;
    }
    get [_listStyleType]() {
      return this.listStyleType;
    }
    set [_listStyleType](value) {
      this.listStyleType = value;
    }
    get [dartx.margin]() {
      return this[_margin];
    }
    set [dartx.margin](value) {
      this[_margin] = value == null ? '' : value;
    }
    get [_margin]() {
      return this.margin;
    }
    set [_margin](value) {
      this.margin = value;
    }
    get [dartx.marginBottom]() {
      return this[_marginBottom];
    }
    set [dartx.marginBottom](value) {
      this[_marginBottom] = value == null ? '' : value;
    }
    get [_marginBottom]() {
      return this.marginBottom;
    }
    set [_marginBottom](value) {
      this.marginBottom = value;
    }
    get [dartx.marginLeft]() {
      return this[_marginLeft];
    }
    set [dartx.marginLeft](value) {
      this[_marginLeft] = value == null ? '' : value;
    }
    get [_marginLeft]() {
      return this.marginLeft;
    }
    set [_marginLeft](value) {
      this.marginLeft = value;
    }
    get [dartx.marginRight]() {
      return this[_marginRight];
    }
    set [dartx.marginRight](value) {
      this[_marginRight] = value == null ? '' : value;
    }
    get [_marginRight]() {
      return this.marginRight;
    }
    set [_marginRight](value) {
      this.marginRight = value;
    }
    get [dartx.marginTop]() {
      return this[_marginTop];
    }
    set [dartx.marginTop](value) {
      this[_marginTop] = value == null ? '' : value;
    }
    get [_marginTop]() {
      return this.marginTop;
    }
    set [_marginTop](value) {
      this.marginTop = value;
    }
    get [dartx.maxHeight]() {
      return this[_maxHeight];
    }
    set [dartx.maxHeight](value) {
      this[_maxHeight] = value == null ? '' : value;
    }
    get [_maxHeight]() {
      return this.maxHeight;
    }
    set [_maxHeight](value) {
      this.maxHeight = value;
    }
    get [dartx.maxWidth]() {
      return this[_maxWidth];
    }
    set [dartx.maxWidth](value) {
      this[_maxWidth] = value == null ? '' : value;
    }
    get [_maxWidth]() {
      return this.maxWidth;
    }
    set [_maxWidth](value) {
      this.maxWidth = value;
    }
    get [dartx.minHeight]() {
      return this[_minHeight];
    }
    set [dartx.minHeight](value) {
      this[_minHeight] = value == null ? '' : value;
    }
    get [_minHeight]() {
      return this.minHeight;
    }
    set [_minHeight](value) {
      this.minHeight = value;
    }
    get [dartx.minWidth]() {
      return this[_minWidth];
    }
    set [dartx.minWidth](value) {
      this[_minWidth] = value == null ? '' : value;
    }
    get [_minWidth]() {
      return this.minWidth;
    }
    set [_minWidth](value) {
      this.minWidth = value;
    }
    get [dartx.outline]() {
      return this[_outline];
    }
    set [dartx.outline](value) {
      this[_outline] = value == null ? '' : value;
    }
    get [_outline]() {
      return this.outline;
    }
    set [_outline](value) {
      this.outline = value;
    }
    get [dartx.outlineColor]() {
      return this[_outlineColor];
    }
    set [dartx.outlineColor](value) {
      this[_outlineColor] = value == null ? '' : value;
    }
    get [_outlineColor]() {
      return this.outlineColor;
    }
    set [_outlineColor](value) {
      this.outlineColor = value;
    }
    get [dartx.outlineStyle]() {
      return this[_outlineStyle];
    }
    set [dartx.outlineStyle](value) {
      this[_outlineStyle] = value == null ? '' : value;
    }
    get [_outlineStyle]() {
      return this.outlineStyle;
    }
    set [_outlineStyle](value) {
      this.outlineStyle = value;
    }
    get [dartx.outlineWidth]() {
      return this[_outlineWidth];
    }
    set [dartx.outlineWidth](value) {
      this[_outlineWidth] = value == null ? '' : value;
    }
    get [_outlineWidth]() {
      return this.outlineWidth;
    }
    set [_outlineWidth](value) {
      this.outlineWidth = value;
    }
    get [dartx.overflow]() {
      return this[_overflow];
    }
    set [dartx.overflow](value) {
      this[_overflow] = value == null ? '' : value;
    }
    get [_overflow]() {
      return this.overflow;
    }
    set [_overflow](value) {
      this.overflow = value;
    }
    get [dartx.padding]() {
      return this[_padding];
    }
    set [dartx.padding](value) {
      this[_padding] = value == null ? '' : value;
    }
    get [_padding]() {
      return this.padding;
    }
    set [_padding](value) {
      this.padding = value;
    }
    get [dartx.paddingBottom]() {
      return this[_paddingBottom];
    }
    set [dartx.paddingBottom](value) {
      this[_paddingBottom] = value == null ? '' : value;
    }
    get [_paddingBottom]() {
      return this.paddingBottom;
    }
    set [_paddingBottom](value) {
      this.paddingBottom = value;
    }
    get [dartx.paddingLeft]() {
      return this[_paddingLeft];
    }
    set [dartx.paddingLeft](value) {
      this[_paddingLeft] = value == null ? '' : value;
    }
    get [_paddingLeft]() {
      return this.paddingLeft;
    }
    set [_paddingLeft](value) {
      this.paddingLeft = value;
    }
    get [dartx.paddingRight]() {
      return this[_paddingRight];
    }
    set [dartx.paddingRight](value) {
      this[_paddingRight] = value == null ? '' : value;
    }
    get [_paddingRight]() {
      return this.paddingRight;
    }
    set [_paddingRight](value) {
      this.paddingRight = value;
    }
    get [dartx.paddingTop]() {
      return this[_paddingTop];
    }
    set [dartx.paddingTop](value) {
      this[_paddingTop] = value == null ? '' : value;
    }
    get [_paddingTop]() {
      return this.paddingTop;
    }
    set [_paddingTop](value) {
      this.paddingTop = value;
    }
    get [dartx.pageBreakAfter]() {
      return this[_pageBreakAfter];
    }
    set [dartx.pageBreakAfter](value) {
      this[_pageBreakAfter] = value == null ? '' : value;
    }
    get [_pageBreakAfter]() {
      return this.pageBreakAfter;
    }
    set [_pageBreakAfter](value) {
      this.pageBreakAfter = value;
    }
    get [dartx.pageBreakBefore]() {
      return this[_pageBreakBefore];
    }
    set [dartx.pageBreakBefore](value) {
      this[_pageBreakBefore] = value == null ? '' : value;
    }
    get [_pageBreakBefore]() {
      return this.pageBreakBefore;
    }
    set [_pageBreakBefore](value) {
      this.pageBreakBefore = value;
    }
    get [dartx.pageBreakInside]() {
      return this[_pageBreakInside];
    }
    set [dartx.pageBreakInside](value) {
      this[_pageBreakInside] = value == null ? '' : value;
    }
    get [_pageBreakInside]() {
      return this.pageBreakInside;
    }
    set [_pageBreakInside](value) {
      this.pageBreakInside = value;
    }
    get [dartx.position]() {
      return this[_position];
    }
    set [dartx.position](value) {
      this[_position] = value == null ? '' : value;
    }
    get [_position]() {
      return this.position;
    }
    set [_position](value) {
      this.position = value;
    }
    get [dartx.quotes]() {
      return this[_quotes];
    }
    set [dartx.quotes](value) {
      this[_quotes] = value == null ? '' : value;
    }
    get [_quotes]() {
      return this.quotes;
    }
    set [_quotes](value) {
      this.quotes = value;
    }
    get [dartx.right]() {
      return this[_right];
    }
    set [dartx.right](value) {
      this[_right] = value == null ? '' : value;
    }
    get [_right]() {
      return this.right;
    }
    set [_right](value) {
      this.right = value;
    }
    get [dartx.tableLayout]() {
      return this[_tableLayout];
    }
    set [dartx.tableLayout](value) {
      this[_tableLayout] = value == null ? '' : value;
    }
    get [_tableLayout]() {
      return this.tableLayout;
    }
    set [_tableLayout](value) {
      this.tableLayout = value;
    }
    get [dartx.textAlign]() {
      return this[_textAlign];
    }
    set [dartx.textAlign](value) {
      this[_textAlign] = value == null ? '' : value;
    }
    get [_textAlign]() {
      return this.textAlign;
    }
    set [_textAlign](value) {
      this.textAlign = value;
    }
    get [dartx.textDecoration]() {
      return this[_textDecoration];
    }
    set [dartx.textDecoration](value) {
      this[_textDecoration] = value == null ? '' : value;
    }
    get [_textDecoration]() {
      return this.textDecoration;
    }
    set [_textDecoration](value) {
      this.textDecoration = value;
    }
    get [dartx.textIndent]() {
      return this[_textIndent];
    }
    set [dartx.textIndent](value) {
      this[_textIndent] = value == null ? '' : value;
    }
    get [_textIndent]() {
      return this.textIndent;
    }
    set [_textIndent](value) {
      this.textIndent = value;
    }
    get [dartx.textTransform]() {
      return this[_textTransform];
    }
    set [dartx.textTransform](value) {
      this[_textTransform] = value == null ? '' : value;
    }
    get [_textTransform]() {
      return this.textTransform;
    }
    set [_textTransform](value) {
      this.textTransform = value;
    }
    get [dartx.top]() {
      return this[_top];
    }
    set [dartx.top](value) {
      this[_top] = value == null ? '' : value;
    }
    get [_top]() {
      return this.top;
    }
    set [_top](value) {
      this.top = value;
    }
    get [dartx.unicodeBidi]() {
      return this[_unicodeBidi];
    }
    set [dartx.unicodeBidi](value) {
      this[_unicodeBidi] = value == null ? '' : value;
    }
    get [_unicodeBidi]() {
      return this.unicodeBidi;
    }
    set [_unicodeBidi](value) {
      this.unicodeBidi = value;
    }
    get [dartx.verticalAlign]() {
      return this[_verticalAlign];
    }
    set [dartx.verticalAlign](value) {
      this[_verticalAlign] = value == null ? '' : value;
    }
    get [_verticalAlign]() {
      return this.verticalAlign;
    }
    set [_verticalAlign](value) {
      this.verticalAlign = value;
    }
    get [dartx.visibility]() {
      return this[_visibility];
    }
    set [dartx.visibility](value) {
      this[_visibility] = value == null ? '' : value;
    }
    get [_visibility]() {
      return this.visibility;
    }
    set [_visibility](value) {
      this.visibility = value;
    }
    get [dartx.whiteSpace]() {
      return this[_whiteSpace];
    }
    set [dartx.whiteSpace](value) {
      this[_whiteSpace] = value == null ? '' : value;
    }
    get [_whiteSpace]() {
      return this.whiteSpace;
    }
    set [_whiteSpace](value) {
      this.whiteSpace = value;
    }
    get [dartx.width]() {
      return this[_width];
    }
    set [dartx.width](value) {
      this[_width] = value == null ? '' : value;
    }
    get [_width]() {
      return this.width;
    }
    set [_width](value) {
      this.width = value;
    }
    get [dartx.wordSpacing]() {
      return this[_wordSpacing];
    }
    set [dartx.wordSpacing](value) {
      this[_wordSpacing] = value == null ? '' : value;
    }
    get [_wordSpacing]() {
      return this.wordSpacing;
    }
    set [_wordSpacing](value) {
      this.wordSpacing = value;
    }
    get [dartx.zIndex]() {
      return this[_zIndex];
    }
    set [dartx.zIndex](value) {
      this[_zIndex] = value == null ? '' : value;
    }
    get [_zIndex]() {
      return this.zIndex;
    }
    set [_zIndex](value) {
      this.zIndex = value;
    }
  }
  dart.setSignature(CssStyleDeclaration, {
    constructors: () => ({
      new: [CssStyleDeclaration, []],
      css: [CssStyleDeclaration, [core.String]],
      _: [CssStyleDeclaration, []]
    }),
    methods: () => ({
      [dartx.getPropertyValue]: [core.String, [core.String]],
      [_getPropertyValueHelper]: [core.String, [core.String]],
      [dartx.supportsProperty]: [core.bool, [core.String]],
      [_supportsProperty]: [core.bool, [core.String]],
      [dartx.setProperty]: [dart.void, [core.String, core.String], [core.String]],
      [_browserPropertyName]: [core.String, [core.String]],
      [_setPropertyHelper]: [dart.void, [core.String, core.String], [core.String]],
      [__getter__]: [core.Object, [core.String]],
      [__setter__]: [dart.void, [core.String, core.String]],
      [dartx.getPropertyPriority]: [core.String, [core.String]],
      [_getPropertyValue]: [core.String, [core.String]],
      [dartx.item]: [core.String, [core.int]],
      [dartx.removeProperty]: [core.String, [core.String]]
    }),
    statics: () => ({
      _readCache: [core.String, [core.String]],
      _writeCache: [dart.void, [core.String, core.String]],
      _camelCase: [core.String, [core.String]]
    }),
    names: ['_readCache', '_writeCache', '_camelCase']
  });
  CssStyleDeclaration[dart.metadata] = () => [dart.const(new _metadata.DomName('CSSStyleDeclaration')), dart.const(new _js_helper.Native("CSSStyleDeclaration,MSStyleCSSProperties,CSS2Properties"))];
  dart.defineLazyProperties(CssStyleDeclaration, {
    get _propertyCache() {
      return {};
    }
  });
  dart.registerExtension(dart.global.CSSStyleDeclaration, CssStyleDeclaration);
  const _elementIterable = Symbol('_elementIterable');
  const _elementCssStyleDeclarationSetIterable = Symbol('_elementCssStyleDeclarationSetIterable');
  const _setAll = Symbol('_setAll');
  class _CssStyleDeclarationSet extends dart.mixin(core.Object, CssStyleDeclarationBase) {
    _CssStyleDeclarationSet(elementIterable) {
      this[_elementIterable] = elementIterable;
      this[_elementCssStyleDeclarationSetIterable] = null;
      this[_elementCssStyleDeclarationSetIterable] = core.List.from(this[_elementIterable])[dartx.map](dart.fn(e => dart.as(dart.dload(e, 'style'), CssStyleDeclaration), CssStyleDeclaration, [dart.dynamic]));
    }
    getPropertyValue(propertyName) {
      return this[_elementCssStyleDeclarationSetIterable][dartx.first][dartx.getPropertyValue](propertyName);
    }
    setProperty(propertyName, value, priority) {
      if (priority === void 0) priority = null;
      this[_elementCssStyleDeclarationSetIterable][dartx.forEach](dart.fn(e => e[dartx.setProperty](propertyName, value, priority), dart.void, [CssStyleDeclaration]));
    }
    [_setAll](propertyName, value) {
      value = value == null ? '' : value;
      for (let element of this[_elementIterable]) {
        element.style[propertyName] = value;
      }
    }
    set background(value) {
      this[_setAll]('background', value);
    }
    set backgroundAttachment(value) {
      this[_setAll]('backgroundAttachment', value);
    }
    set backgroundColor(value) {
      this[_setAll]('backgroundColor', value);
    }
    set backgroundImage(value) {
      this[_setAll]('backgroundImage', value);
    }
    set backgroundPosition(value) {
      this[_setAll]('backgroundPosition', value);
    }
    set backgroundRepeat(value) {
      this[_setAll]('backgroundRepeat', value);
    }
    set border(value) {
      this[_setAll]('border', value);
    }
    set borderBottom(value) {
      this[_setAll]('borderBottom', value);
    }
    set borderBottomColor(value) {
      this[_setAll]('borderBottomColor', value);
    }
    set borderBottomStyle(value) {
      this[_setAll]('borderBottomStyle', value);
    }
    set borderBottomWidth(value) {
      this[_setAll]('borderBottomWidth', value);
    }
    set borderCollapse(value) {
      this[_setAll]('borderCollapse', value);
    }
    set borderColor(value) {
      this[_setAll]('borderColor', value);
    }
    set borderLeft(value) {
      this[_setAll]('borderLeft', value);
    }
    set borderLeftColor(value) {
      this[_setAll]('borderLeftColor', value);
    }
    set borderLeftStyle(value) {
      this[_setAll]('borderLeftStyle', value);
    }
    set borderLeftWidth(value) {
      this[_setAll]('borderLeftWidth', value);
    }
    set borderRight(value) {
      this[_setAll]('borderRight', value);
    }
    set borderRightColor(value) {
      this[_setAll]('borderRightColor', value);
    }
    set borderRightStyle(value) {
      this[_setAll]('borderRightStyle', value);
    }
    set borderRightWidth(value) {
      this[_setAll]('borderRightWidth', value);
    }
    set borderSpacing(value) {
      this[_setAll]('borderSpacing', value);
    }
    set borderStyle(value) {
      this[_setAll]('borderStyle', value);
    }
    set borderTop(value) {
      this[_setAll]('borderTop', value);
    }
    set borderTopColor(value) {
      this[_setAll]('borderTopColor', value);
    }
    set borderTopStyle(value) {
      this[_setAll]('borderTopStyle', value);
    }
    set borderTopWidth(value) {
      this[_setAll]('borderTopWidth', value);
    }
    set borderWidth(value) {
      this[_setAll]('borderWidth', value);
    }
    set bottom(value) {
      this[_setAll]('bottom', value);
    }
    set captionSide(value) {
      this[_setAll]('captionSide', value);
    }
    set clear(value) {
      this[_setAll]('clear', value);
    }
    set clip(value) {
      this[_setAll]('clip', value);
    }
    set color(value) {
      this[_setAll]('color', value);
    }
    set content(value) {
      this[_setAll]('content', value);
    }
    set cursor(value) {
      this[_setAll]('cursor', value);
    }
    set direction(value) {
      this[_setAll]('direction', value);
    }
    set display(value) {
      this[_setAll]('display', value);
    }
    set emptyCells(value) {
      this[_setAll]('emptyCells', value);
    }
    set font(value) {
      this[_setAll]('font', value);
    }
    set fontFamily(value) {
      this[_setAll]('fontFamily', value);
    }
    set fontSize(value) {
      this[_setAll]('fontSize', value);
    }
    set fontStyle(value) {
      this[_setAll]('fontStyle', value);
    }
    set fontVariant(value) {
      this[_setAll]('fontVariant', value);
    }
    set fontWeight(value) {
      this[_setAll]('fontWeight', value);
    }
    set height(value) {
      this[_setAll]('height', value);
    }
    set left(value) {
      this[_setAll]('left', value);
    }
    set letterSpacing(value) {
      this[_setAll]('letterSpacing', value);
    }
    set lineHeight(value) {
      this[_setAll]('lineHeight', value);
    }
    set listStyle(value) {
      this[_setAll]('listStyle', value);
    }
    set listStyleImage(value) {
      this[_setAll]('listStyleImage', value);
    }
    set listStylePosition(value) {
      this[_setAll]('listStylePosition', value);
    }
    set listStyleType(value) {
      this[_setAll]('listStyleType', value);
    }
    set margin(value) {
      this[_setAll]('margin', value);
    }
    set marginBottom(value) {
      this[_setAll]('marginBottom', value);
    }
    set marginLeft(value) {
      this[_setAll]('marginLeft', value);
    }
    set marginRight(value) {
      this[_setAll]('marginRight', value);
    }
    set marginTop(value) {
      this[_setAll]('marginTop', value);
    }
    set maxHeight(value) {
      this[_setAll]('maxHeight', value);
    }
    set maxWidth(value) {
      this[_setAll]('maxWidth', value);
    }
    set minHeight(value) {
      this[_setAll]('minHeight', value);
    }
    set minWidth(value) {
      this[_setAll]('minWidth', value);
    }
    set outline(value) {
      this[_setAll]('outline', value);
    }
    set outlineColor(value) {
      this[_setAll]('outlineColor', value);
    }
    set outlineStyle(value) {
      this[_setAll]('outlineStyle', value);
    }
    set outlineWidth(value) {
      this[_setAll]('outlineWidth', value);
    }
    set overflow(value) {
      this[_setAll]('overflow', value);
    }
    set padding(value) {
      this[_setAll]('padding', value);
    }
    set paddingBottom(value) {
      this[_setAll]('paddingBottom', value);
    }
    set paddingLeft(value) {
      this[_setAll]('paddingLeft', value);
    }
    set paddingRight(value) {
      this[_setAll]('paddingRight', value);
    }
    set paddingTop(value) {
      this[_setAll]('paddingTop', value);
    }
    set pageBreakAfter(value) {
      this[_setAll]('pageBreakAfter', value);
    }
    set pageBreakBefore(value) {
      this[_setAll]('pageBreakBefore', value);
    }
    set pageBreakInside(value) {
      this[_setAll]('pageBreakInside', value);
    }
    set position(value) {
      this[_setAll]('position', value);
    }
    set quotes(value) {
      this[_setAll]('quotes', value);
    }
    set right(value) {
      this[_setAll]('right', value);
    }
    set tableLayout(value) {
      this[_setAll]('tableLayout', value);
    }
    set textAlign(value) {
      this[_setAll]('textAlign', value);
    }
    set textDecoration(value) {
      this[_setAll]('textDecoration', value);
    }
    set textIndent(value) {
      this[_setAll]('textIndent', value);
    }
    set textTransform(value) {
      this[_setAll]('textTransform', value);
    }
    set top(value) {
      this[_setAll]('top', value);
    }
    set unicodeBidi(value) {
      this[_setAll]('unicodeBidi', value);
    }
    set verticalAlign(value) {
      this[_setAll]('verticalAlign', value);
    }
    set visibility(value) {
      this[_setAll]('visibility', value);
    }
    set whiteSpace(value) {
      this[_setAll]('whiteSpace', value);
    }
    set width(value) {
      this[_setAll]('width', value);
    }
    set wordSpacing(value) {
      this[_setAll]('wordSpacing', value);
    }
    set zIndex(value) {
      this[_setAll]('zIndex', value);
    }
  }
  dart.setSignature(_CssStyleDeclarationSet, {
    constructors: () => ({_CssStyleDeclarationSet: [_CssStyleDeclarationSet, [core.Iterable$(Element)]]}),
    methods: () => ({
      getPropertyValue: [core.String, [core.String]],
      setProperty: [dart.void, [core.String, core.String], [core.String]],
      [_setAll]: [dart.void, [core.String, core.String]]
    })
  });
  dart.defineExtensionMembers(_CssStyleDeclarationSet, [
    'getPropertyValue',
    'setProperty',
    'background',
    'backgroundAttachment',
    'backgroundColor',
    'backgroundImage',
    'backgroundPosition',
    'backgroundRepeat',
    'border',
    'borderBottom',
    'borderBottomColor',
    'borderBottomStyle',
    'borderBottomWidth',
    'borderCollapse',
    'borderColor',
    'borderLeft',
    'borderLeftColor',
    'borderLeftStyle',
    'borderLeftWidth',
    'borderRight',
    'borderRightColor',
    'borderRightStyle',
    'borderRightWidth',
    'borderSpacing',
    'borderStyle',
    'borderTop',
    'borderTopColor',
    'borderTopStyle',
    'borderTopWidth',
    'borderWidth',
    'bottom',
    'captionSide',
    'clear',
    'clip',
    'color',
    'content',
    'cursor',
    'direction',
    'display',
    'emptyCells',
    'font',
    'fontFamily',
    'fontSize',
    'fontStyle',
    'fontVariant',
    'fontWeight',
    'height',
    'left',
    'letterSpacing',
    'lineHeight',
    'listStyle',
    'listStyleImage',
    'listStylePosition',
    'listStyleType',
    'margin',
    'marginBottom',
    'marginLeft',
    'marginRight',
    'marginTop',
    'maxHeight',
    'maxWidth',
    'minHeight',
    'minWidth',
    'outline',
    'outlineColor',
    'outlineStyle',
    'outlineWidth',
    'overflow',
    'padding',
    'paddingBottom',
    'paddingLeft',
    'paddingRight',
    'paddingTop',
    'pageBreakAfter',
    'pageBreakBefore',
    'pageBreakInside',
    'position',
    'quotes',
    'right',
    'tableLayout',
    'textAlign',
    'textDecoration',
    'textIndent',
    'textTransform',
    'top',
    'unicodeBidi',
    'verticalAlign',
    'visibility',
    'whiteSpace',
    'width',
    'wordSpacing',
    'zIndex'
  ]);
  dart.defineExtensionNames([
    'selectorText',
    'style'
  ]);
  class CssStyleRule extends CssRule {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.selectorText]() {
      return this.selectorText;
    }
    set [dartx.selectorText](value) {
      this.selectorText = value;
    }
    get [dartx.style]() {
      return this.style;
    }
  }
  dart.setSignature(CssStyleRule, {
    constructors: () => ({_: [CssStyleRule, []]})
  });
  CssStyleRule[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('CSSStyleRule')), dart.const(new _js_helper.Native("CSSStyleRule"))];
  dart.registerExtension(dart.global.CSSStyleRule, CssStyleRule);
  dart.defineExtensionNames([
    'disabled',
    'href',
    'media',
    'ownerNode',
    'parentStyleSheet',
    'title',
    'type'
  ]);
  class StyleSheet extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.disabled]() {
      return this.disabled;
    }
    set [dartx.disabled](value) {
      this.disabled = value;
    }
    get [dartx.href]() {
      return this.href;
    }
    get [dartx.media]() {
      return this.media;
    }
    get [dartx.ownerNode]() {
      return this.ownerNode;
    }
    get [dartx.parentStyleSheet]() {
      return this.parentStyleSheet;
    }
    get [dartx.title]() {
      return this.title;
    }
    get [dartx.type]() {
      return this.type;
    }
  }
  dart.setSignature(StyleSheet, {
    constructors: () => ({_: [StyleSheet, []]})
  });
  StyleSheet[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('StyleSheet')), dart.const(new _js_helper.Native("StyleSheet"))];
  dart.registerExtension(dart.global.StyleSheet, StyleSheet);
  dart.defineExtensionNames([
    'addRule',
    'deleteRule',
    'insertRule',
    'removeRule',
    'cssRules',
    'ownerRule',
    'rules'
  ]);
  class CssStyleSheet extends StyleSheet {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.cssRules]() {
      return this.cssRules;
    }
    get [dartx.ownerRule]() {
      return this.ownerRule;
    }
    get [dartx.rules]() {
      return this.rules;
    }
    [dartx.addRule](selector, style, index) {
      return this.addRule(selector, style, index);
    }
    [dartx.deleteRule](index) {
      return this.deleteRule(index);
    }
    [dartx.insertRule](rule, index) {
      return this.insertRule(rule, index);
    }
    [dartx.removeRule](index) {
      return this.removeRule(index);
    }
  }
  dart.setSignature(CssStyleSheet, {
    constructors: () => ({_: [CssStyleSheet, []]}),
    methods: () => ({
      [dartx.addRule]: [core.int, [core.String, core.String], [core.int]],
      [dartx.deleteRule]: [dart.void, [core.int]],
      [dartx.insertRule]: [core.int, [core.String], [core.int]],
      [dartx.removeRule]: [dart.void, [core.int]]
    })
  });
  CssStyleSheet[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('CSSStyleSheet')), dart.const(new _js_helper.Native("CSSStyleSheet"))];
  dart.registerExtension(dart.global.CSSStyleSheet, CssStyleSheet);
  dart.defineExtensionNames([
    'deleteRule',
    'insertRule',
    'conditionText',
    'cssRules'
  ]);
  class CssSupportsRule extends CssRule {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.conditionText]() {
      return this.conditionText;
    }
    get [dartx.cssRules]() {
      return this.cssRules;
    }
    [dartx.deleteRule](index) {
      return this.deleteRule(index);
    }
    [dartx.insertRule](rule, index) {
      return this.insertRule(rule, index);
    }
  }
  dart.setSignature(CssSupportsRule, {
    constructors: () => ({_: [CssSupportsRule, []]}),
    methods: () => ({
      [dartx.deleteRule]: [dart.void, [core.int]],
      [dartx.insertRule]: [core.int, [core.String, core.int]]
    })
  });
  CssSupportsRule[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('CSSSupportsRule')), dart.const(new _js_helper.Native("CSSSupportsRule"))];
  dart.registerExtension(dart.global.CSSSupportsRule, CssSupportsRule);
  dart.defineExtensionNames([
    'style'
  ]);
  class CssViewportRule extends CssRule {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.style]() {
      return this.style;
    }
  }
  dart.setSignature(CssViewportRule, {
    constructors: () => ({_: [CssViewportRule, []]})
  });
  CssViewportRule[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('CSSViewportRule')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("CSSViewportRule"))];
  dart.registerExtension(dart.global.CSSViewportRule, CssViewportRule);
  const _dartDetail = Symbol('_dartDetail');
  const _initCustomEvent = Symbol('_initCustomEvent');
  const _detail = Symbol('_detail');
  const _get__detail = Symbol('_get__detail');
  dart.defineExtensionNames([
    'detail'
  ]);
  class CustomEvent extends Event {
    get [_dartDetail]() {
      return this._dartDetail;
    }
    set [_dartDetail](value) {
      this._dartDetail = value;
    }
    static new(type, opts) {
      let canBubble = opts && 'canBubble' in opts ? opts.canBubble : true;
      let cancelable = opts && 'cancelable' in opts ? opts.cancelable : true;
      let detail = opts && 'detail' in opts ? opts.detail : null;
      let e = dart.as(exports.document[_createEvent]('CustomEvent'), CustomEvent);
      e[_dartDetail] = detail;
      if (dart.is(detail, core.List) || dart.is(detail, core.Map) || typeof detail == 'string' || typeof detail == 'number') {
        try {
          detail = html_common.convertDartToNative_SerializedScriptValue(detail);
          e[_initCustomEvent](type, canBubble, cancelable, detail);
        } catch (_) {
          e[_initCustomEvent](type, canBubble, cancelable, null);
        }

      } else {
        e[_initCustomEvent](type, canBubble, cancelable, null);
      }
      return e;
    }
    get [dartx.detail]() {
      if (this[_dartDetail] != null) {
        return this[_dartDetail];
      }
      return this[_detail];
    }
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [_detail]() {
      return html_common.convertNativeToDart_SerializedScriptValue(this[_get__detail]);
    }
    get [_get__detail]() {
      return this.detail;
    }
    [_initCustomEvent](typeArg, canBubbleArg, cancelableArg, detailArg) {
      return this.initCustomEvent(typeArg, canBubbleArg, cancelableArg, detailArg);
    }
  }
  dart.setSignature(CustomEvent, {
    constructors: () => ({
      new: [CustomEvent, [core.String], {canBubble: core.bool, cancelable: core.bool, detail: core.Object}],
      _: [CustomEvent, []]
    }),
    methods: () => ({[_initCustomEvent]: [dart.void, [core.String, core.bool, core.bool, core.Object]]})
  });
  CustomEvent[dart.metadata] = () => [dart.const(new _metadata.DomName('CustomEvent')), dart.const(new _js_helper.Native("CustomEvent"))];
  dart.registerExtension(dart.global.CustomEvent, CustomEvent);
  class DListElement extends HtmlElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return dart.as(exports.document[dartx.createElement]("dl"), DListElement);
    }
    created() {
      super.created();
    }
  }
  dart.defineNamedConstructor(DListElement, 'created');
  dart.setSignature(DListElement, {
    constructors: () => ({
      _: [DListElement, []],
      new: [DListElement, []],
      created: [DListElement, []]
    })
  });
  DListElement[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('HTMLDListElement')), dart.const(new _js_helper.Native("HTMLDListElement"))];
  dart.registerExtension(dart.global.HTMLDListElement, DListElement);
  dart.defineExtensionNames([
    'options'
  ]);
  class DataListElement extends HtmlElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return dart.as(exports.document[dartx.createElement]("datalist"), DataListElement);
    }
    created() {
      this[dartx.options] = null;
      super.created();
    }
    static get supported() {
      return Element.isTagSupported('datalist');
    }
    get [dartx.options]() {
      return this.options;
    }
  }
  dart.defineNamedConstructor(DataListElement, 'created');
  dart.setSignature(DataListElement, {
    constructors: () => ({
      _: [DataListElement, []],
      new: [DataListElement, []],
      created: [DataListElement, []]
    })
  });
  DataListElement[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('HTMLDataListElement')), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.CHROME)), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.FIREFOX)), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.IE, '10')), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.SAFARI)), dart.const(new _js_helper.Native("HTMLDataListElement"))];
  dart.registerExtension(dart.global.HTMLDataListElement, DataListElement);
  dart.defineExtensionNames([
    'clearData',
    'getData',
    'setData',
    'setDragImage',
    'dropEffect',
    'effectAllowed',
    'files',
    'items',
    'types'
  ]);
  class DataTransfer extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.dropEffect]() {
      return this.dropEffect;
    }
    set [dartx.dropEffect](value) {
      this.dropEffect = value;
    }
    get [dartx.effectAllowed]() {
      return this.effectAllowed;
    }
    set [dartx.effectAllowed](value) {
      this.effectAllowed = value;
    }
    get [dartx.files]() {
      return this.files;
    }
    get [dartx.items]() {
      return this.items;
    }
    get [dartx.types]() {
      return this.types;
    }
    [dartx.clearData](type) {
      return this.clearData(type);
    }
    [dartx.getData](type) {
      return this.getData(type);
    }
    [dartx.setData](type, data) {
      return this.setData(type, data);
    }
    [dartx.setDragImage](image, x, y) {
      return this.setDragImage(image, x, y);
    }
  }
  dart.setSignature(DataTransfer, {
    constructors: () => ({_: [DataTransfer, []]}),
    methods: () => ({
      [dartx.clearData]: [dart.void, [], [core.String]],
      [dartx.getData]: [core.String, [core.String]],
      [dartx.setData]: [dart.void, [core.String, core.String]],
      [dartx.setDragImage]: [dart.void, [Element, core.int, core.int]]
    })
  });
  DataTransfer[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('DataTransfer')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("DataTransfer"))];
  dart.registerExtension(dart.global.DataTransfer, DataTransfer);
  const _getAsString = Symbol('_getAsString');
  dart.defineExtensionNames([
    'getAsFile',
    'getAsString',
    'getAsEntry',
    'kind',
    'type'
  ]);
  class DataTransferItem extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.kind]() {
      return this.kind;
    }
    get [dartx.type]() {
      return this.type;
    }
    [dartx.getAsFile]() {
      return this.getAsFile();
    }
    [_getAsString](callback) {
      return this.getAsString(callback);
    }
    [dartx.getAsString]() {
      let completer = async.Completer$(core.String).new();
      this[_getAsString](dart.fn(value => {
        completer.complete(value);
      }, dart.void, [core.String]));
      return completer.future;
    }
    [dartx.getAsEntry]() {
      return this.webkitGetAsEntry();
    }
  }
  dart.setSignature(DataTransferItem, {
    constructors: () => ({_: [DataTransferItem, []]}),
    methods: () => ({
      [dartx.getAsFile]: [Blob, []],
      [_getAsString]: [dart.void, [_StringCallback]],
      [dartx.getAsString]: [async.Future$(core.String), []],
      [dartx.getAsEntry]: [Entry, []]
    })
  });
  DataTransferItem[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('DataTransferItem')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("DataTransferItem"))];
  dart.registerExtension(dart.global.DataTransferItem, DataTransferItem);
  dart.defineExtensionNames([
    'add',
    'addData',
    'addFile',
    'clear',
    'remove',
    'get',
    'length'
  ]);
  class DataTransferItemList extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.length]() {
      return this.length;
    }
    [__getter__](index) {
      return this.__getter__(index);
    }
    [dartx.add](data_OR_file, type) {
      return this.add(data_OR_file, type);
    }
    [dartx.addData](data, type) {
      return this.add(data, type);
    }
    [dartx.addFile](file) {
      return this.add(file);
    }
    [dartx.clear]() {
      return this.clear();
    }
    [dartx.remove](index) {
      return this.remove(index);
    }
    [dartx.get](index) {
      return dart.as(this[index], DataTransferItem);
    }
  }
  dart.setSignature(DataTransferItemList, {
    constructors: () => ({_: [DataTransferItemList, []]}),
    methods: () => ({
      [__getter__]: [DataTransferItem, [core.int]],
      [dartx.add]: [DataTransferItem, [dart.dynamic], [core.String]],
      [dartx.addData]: [DataTransferItem, [core.String, core.String]],
      [dartx.addFile]: [DataTransferItem, [File]],
      [dartx.clear]: [dart.void, []],
      [dartx.remove]: [dart.void, [core.int]],
      [dartx.get]: [DataTransferItem, [core.int]]
    })
  });
  DataTransferItemList[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('DataTransferItemList')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("DataTransferItemList"))];
  dart.registerExtension(dart.global.DataTransferItemList, DataTransferItemList);
  const DatabaseCallback = dart.typedef('DatabaseCallback', () => dart.functionType(dart.void, [web_sql.SqlDatabase]));
  const _webkitRequestFileSystem = Symbol('_webkitRequestFileSystem');
  const _webkitResolveLocalFileSystemUrl = Symbol('_webkitResolveLocalFileSystemUrl');
  const _clearInterval = Symbol('_clearInterval');
  const _clearTimeout = Symbol('_clearTimeout');
  const _setInterval = Symbol('_setInterval');
  const _setTimeout = Symbol('_setTimeout');
  dart.defineExtensionNames([
    'close',
    'importScripts',
    'webkitRequestFileSystem',
    'requestFileSystemSync',
    'resolveLocalFileSystemSyncUrl',
    'webkitResolveLocalFileSystemUrl',
    'atob',
    'btoa',
    'onError',
    'console',
    'crypto',
    'indexedDB',
    'location',
    'navigator',
    'performance',
    'self'
  ]);
  class WorkerGlobalScope extends EventTarget {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.console]() {
      return this.console;
    }
    get [dartx.crypto]() {
      return this.crypto;
    }
    get [dartx.indexedDB]() {
      return this.indexedDB;
    }
    get [dartx.location]() {
      return this.location;
    }
    get [dartx.navigator]() {
      return this.navigator;
    }
    get [dartx.performance]() {
      return this.performance;
    }
    get [dartx.self]() {
      return this.self;
    }
    [dartx.close]() {
      return this.close();
    }
    [dartx.importScripts](urls) {
      return this.importScripts(urls);
    }
    [_webkitRequestFileSystem](type, size, successCallback, errorCallback) {
      return this.webkitRequestFileSystem(type, size, successCallback, errorCallback);
    }
    [dartx.webkitRequestFileSystem](type, size) {
      let completer = async.Completer$(FileSystem).new();
      this[_webkitRequestFileSystem](type, size, dart.fn(value => {
        completer.complete(value);
      }, dart.void, [FileSystem]), dart.fn(error => {
        completer.completeError(error);
      }, dart.void, [FileError]));
      return completer.future;
    }
    [dartx.requestFileSystemSync](type, size) {
      return this.webkitRequestFileSystemSync(type, size);
    }
    [dartx.resolveLocalFileSystemSyncUrl](url) {
      return this.webkitResolveLocalFileSystemSyncURL(url);
    }
    [_webkitResolveLocalFileSystemUrl](url, successCallback, errorCallback) {
      return this.webkitResolveLocalFileSystemURL(url, successCallback, errorCallback);
    }
    [dartx.webkitResolveLocalFileSystemUrl](url) {
      let completer = async.Completer$(Entry).new();
      this[_webkitResolveLocalFileSystemUrl](url, dart.fn(value => {
        completer.complete(value);
      }, dart.void, [Entry]), dart.fn(error => {
        completer.completeError(error);
      }, dart.void, [FileError]));
      return completer.future;
    }
    [dartx.atob](string) {
      return this.atob(string);
    }
    [dartx.btoa](string) {
      return this.btoa(string);
    }
    [_clearInterval](handle) {
      return this.clearInterval(handle);
    }
    [_clearTimeout](handle) {
      return this.clearTimeout(handle);
    }
    [_setInterval](handler, timeout) {
      return this.setInterval(handler, timeout);
    }
    [_setTimeout](handler, timeout) {
      return this.setTimeout(handler, timeout);
    }
    get [dartx.onError]() {
      return WorkerGlobalScope.errorEvent.forTarget(this);
    }
  }
  WorkerGlobalScope[dart.implements] = () => [_WindowTimers, WindowBase64];
  dart.setSignature(WorkerGlobalScope, {
    constructors: () => ({_: [WorkerGlobalScope, []]}),
    methods: () => ({
      [dartx.close]: [dart.void, []],
      [dartx.importScripts]: [dart.void, [core.String]],
      [_webkitRequestFileSystem]: [dart.void, [core.int, core.int], [_FileSystemCallback, _ErrorCallback]],
      [dartx.webkitRequestFileSystem]: [async.Future$(FileSystem), [core.int, core.int]],
      [dartx.requestFileSystemSync]: [_DOMFileSystemSync, [core.int, core.int]],
      [dartx.resolveLocalFileSystemSyncUrl]: [_EntrySync, [core.String]],
      [_webkitResolveLocalFileSystemUrl]: [dart.void, [core.String, _EntryCallback], [_ErrorCallback]],
      [dartx.webkitResolveLocalFileSystemUrl]: [async.Future$(Entry), [core.String]],
      [dartx.atob]: [core.String, [core.String]],
      [dartx.btoa]: [core.String, [core.String]],
      [_clearInterval]: [dart.void, [core.int]],
      [_clearTimeout]: [dart.void, [core.int]],
      [_setInterval]: [core.int, [core.Object, core.int]],
      [_setTimeout]: [core.int, [core.Object, core.int]]
    })
  });
  WorkerGlobalScope[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('WorkerGlobalScope')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("WorkerGlobalScope"))];
  WorkerGlobalScope.PERSISTENT = 1;
  WorkerGlobalScope.TEMPORARY = 0;
  dart.defineLazyProperties(WorkerGlobalScope, {
    get errorEvent() {
      return dart.const(new (EventStreamProvider$(Event))('error'));
    }
  });
  dart.registerExtension(dart.global.WorkerGlobalScope, WorkerGlobalScope);
  const _postMessage_1 = Symbol('_postMessage_1');
  const _postMessage_2 = Symbol('_postMessage_2');
  dart.defineExtensionNames([
    'postMessage',
    'onMessage'
  ]);
  class DedicatedWorkerGlobalScope extends WorkerGlobalScope {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    [dartx.postMessage](message, transfer) {
      if (transfer === void 0) transfer = null;
      if (transfer != null) {
        let message_1 = html_common.convertDartToNative_SerializedScriptValue(message);
        this[_postMessage_1](message_1, transfer);
        return;
      }
      let message_1 = html_common.convertDartToNative_SerializedScriptValue(message);
      this[_postMessage_2](message_1);
      return;
    }
    [_postMessage_1](message, transfer) {
      return this.postMessage(message, transfer);
    }
    [_postMessage_2](message) {
      return this.postMessage(message);
    }
    get [dartx.onMessage]() {
      return DedicatedWorkerGlobalScope.messageEvent.forTarget(this);
    }
  }
  dart.setSignature(DedicatedWorkerGlobalScope, {
    constructors: () => ({_: [DedicatedWorkerGlobalScope, []]}),
    methods: () => ({
      [dartx.postMessage]: [dart.void, [dart.dynamic], [core.List$(MessagePort)]],
      [_postMessage_1]: [dart.void, [dart.dynamic, core.List$(MessagePort)]],
      [_postMessage_2]: [dart.void, [dart.dynamic]]
    })
  });
  DedicatedWorkerGlobalScope[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('DedicatedWorkerGlobalScope')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("DedicatedWorkerGlobalScope"))];
  dart.defineLazyProperties(DedicatedWorkerGlobalScope, {
    get messageEvent() {
      return dart.const(new (EventStreamProvider$(MessageEvent))('message'));
    }
  });
  dart.registerExtension(dart.global.DedicatedWorkerGlobalScope, DedicatedWorkerGlobalScope);
  dart.defineExtensionNames([
    'queryUsageAndQuota',
    'requestQuota'
  ]);
  class DeprecatedStorageInfo extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    [dartx.queryUsageAndQuota](storageType, usageCallback, errorCallback) {
      return this.queryUsageAndQuota(storageType, usageCallback, errorCallback);
    }
    [dartx.requestQuota](storageType, newQuotaInBytes, quotaCallback, errorCallback) {
      return this.requestQuota(storageType, newQuotaInBytes, quotaCallback, errorCallback);
    }
  }
  dart.setSignature(DeprecatedStorageInfo, {
    constructors: () => ({_: [DeprecatedStorageInfo, []]}),
    methods: () => ({
      [dartx.queryUsageAndQuota]: [dart.void, [core.int], [StorageUsageCallback, StorageErrorCallback]],
      [dartx.requestQuota]: [dart.void, [core.int, core.int], [StorageQuotaCallback, StorageErrorCallback]]
    })
  });
  DeprecatedStorageInfo[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('DeprecatedStorageInfo')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("DeprecatedStorageInfo"))];
  DeprecatedStorageInfo.PERSISTENT = 1;
  DeprecatedStorageInfo.TEMPORARY = 0;
  dart.registerExtension(dart.global.DeprecatedStorageInfo, DeprecatedStorageInfo);
  dart.defineExtensionNames([
    'queryUsageAndQuota',
    'requestQuota'
  ]);
  class DeprecatedStorageQuota extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    [dartx.queryUsageAndQuota](usageCallback, errorCallback) {
      return this.queryUsageAndQuota(usageCallback, errorCallback);
    }
    [dartx.requestQuota](newQuotaInBytes, quotaCallback, errorCallback) {
      return this.requestQuota(newQuotaInBytes, quotaCallback, errorCallback);
    }
  }
  dart.setSignature(DeprecatedStorageQuota, {
    constructors: () => ({_: [DeprecatedStorageQuota, []]}),
    methods: () => ({
      [dartx.queryUsageAndQuota]: [dart.void, [StorageUsageCallback], [StorageErrorCallback]],
      [dartx.requestQuota]: [dart.void, [core.int], [StorageQuotaCallback, StorageErrorCallback]]
    })
  });
  DeprecatedStorageQuota[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('DeprecatedStorageQuota')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("DeprecatedStorageQuota"))];
  dart.registerExtension(dart.global.DeprecatedStorageQuota, DeprecatedStorageQuota);
  dart.defineExtensionNames([
    'open'
  ]);
  class DetailsElement extends HtmlElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return dart.as(exports.document[dartx.createElement]("details"), DetailsElement);
    }
    created() {
      this[dartx.open] = null;
      super.created();
    }
    static get supported() {
      return Element.isTagSupported('details');
    }
    get [dartx.open]() {
      return this.open;
    }
    set [dartx.open](value) {
      this.open = value;
    }
  }
  dart.defineNamedConstructor(DetailsElement, 'created');
  dart.setSignature(DetailsElement, {
    constructors: () => ({
      _: [DetailsElement, []],
      new: [DetailsElement, []],
      created: [DetailsElement, []]
    })
  });
  DetailsElement[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('HTMLDetailsElement')), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.CHROME)), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.SAFARI)), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("HTMLDetailsElement"))];
  dart.registerExtension(dart.global.HTMLDetailsElement, DetailsElement);
  dart.defineExtensionNames([
    'x',
    'y',
    'z'
  ]);
  class DeviceAcceleration extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.x]() {
      return this.x;
    }
    get [dartx.y]() {
      return this.y;
    }
    get [dartx.z]() {
      return this.z;
    }
  }
  dart.setSignature(DeviceAcceleration, {
    constructors: () => ({_: [DeviceAcceleration, []]})
  });
  DeviceAcceleration[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('DeviceAcceleration')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("DeviceAcceleration"))];
  dart.registerExtension(dart.global.DeviceAcceleration, DeviceAcceleration);
  dart.defineExtensionNames([
    'value'
  ]);
  class DeviceLightEvent extends Event {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.value]() {
      return this.value;
    }
  }
  dart.setSignature(DeviceLightEvent, {
    constructors: () => ({_: [DeviceLightEvent, []]})
  });
  DeviceLightEvent[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('DeviceLightEvent')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("DeviceLightEvent"))];
  dart.registerExtension(dart.global.DeviceLightEvent, DeviceLightEvent);
  dart.defineExtensionNames([
    'initDeviceMotionEvent',
    'acceleration',
    'accelerationIncludingGravity',
    'interval',
    'rotationRate'
  ]);
  class DeviceMotionEvent extends Event {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.acceleration]() {
      return this.acceleration;
    }
    get [dartx.accelerationIncludingGravity]() {
      return this.accelerationIncludingGravity;
    }
    get [dartx.interval]() {
      return this.interval;
    }
    get [dartx.rotationRate]() {
      return this.rotationRate;
    }
    [dartx.initDeviceMotionEvent](type, bubbles, cancelable, acceleration, accelerationIncludingGravity, rotationRate, interval) {
      return this.initDeviceMotionEvent(type, bubbles, cancelable, acceleration, accelerationIncludingGravity, rotationRate, interval);
    }
  }
  dart.setSignature(DeviceMotionEvent, {
    constructors: () => ({_: [DeviceMotionEvent, []]}),
    methods: () => ({[dartx.initDeviceMotionEvent]: [dart.void, [core.String, core.bool, core.bool, DeviceAcceleration, DeviceAcceleration, DeviceRotationRate, core.num]]})
  });
  DeviceMotionEvent[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('DeviceMotionEvent')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("DeviceMotionEvent"))];
  dart.registerExtension(dart.global.DeviceMotionEvent, DeviceMotionEvent);
  const _initDeviceOrientationEvent = Symbol('_initDeviceOrientationEvent');
  dart.defineExtensionNames([
    'absolute',
    'alpha',
    'beta',
    'gamma'
  ]);
  class DeviceOrientationEvent extends Event {
    static new(type, opts) {
      let canBubble = opts && 'canBubble' in opts ? opts.canBubble : true;
      let cancelable = opts && 'cancelable' in opts ? opts.cancelable : true;
      let alpha = opts && 'alpha' in opts ? opts.alpha : 0;
      let beta = opts && 'beta' in opts ? opts.beta : 0;
      let gamma = opts && 'gamma' in opts ? opts.gamma : 0;
      let absolute = opts && 'absolute' in opts ? opts.absolute : false;
      let e = exports.document[_createEvent]("DeviceOrientationEvent");
      dart.dcall(e[_initDeviceOrientationEvent], type, canBubble, cancelable, alpha, beta, gamma, absolute);
      return dart.as(e, DeviceOrientationEvent);
    }
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.absolute]() {
      return this.absolute;
    }
    get [dartx.alpha]() {
      return this.alpha;
    }
    get [dartx.beta]() {
      return this.beta;
    }
    get [dartx.gamma]() {
      return this.gamma;
    }
    [_initDeviceOrientationEvent](type, bubbles, cancelable, alpha, beta, gamma, absolute) {
      return this.initDeviceOrientationEvent(type, bubbles, cancelable, alpha, beta, gamma, absolute);
    }
  }
  dart.setSignature(DeviceOrientationEvent, {
    constructors: () => ({
      new: [DeviceOrientationEvent, [core.String], {canBubble: core.bool, cancelable: core.bool, alpha: core.num, beta: core.num, gamma: core.num, absolute: core.bool}],
      _: [DeviceOrientationEvent, []]
    }),
    methods: () => ({[_initDeviceOrientationEvent]: [dart.void, [core.String, core.bool, core.bool, core.num, core.num, core.num, core.bool]]})
  });
  DeviceOrientationEvent[dart.metadata] = () => [dart.const(new _metadata.DomName('DeviceOrientationEvent')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("DeviceOrientationEvent"))];
  dart.registerExtension(dart.global.DeviceOrientationEvent, DeviceOrientationEvent);
  dart.defineExtensionNames([
    'alpha',
    'beta',
    'gamma'
  ]);
  class DeviceRotationRate extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.alpha]() {
      return this.alpha;
    }
    get [dartx.beta]() {
      return this.beta;
    }
    get [dartx.gamma]() {
      return this.gamma;
    }
  }
  dart.setSignature(DeviceRotationRate, {
    constructors: () => ({_: [DeviceRotationRate, []]})
  });
  DeviceRotationRate[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('DeviceRotationRate')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("DeviceRotationRate"))];
  dart.registerExtension(dart.global.DeviceRotationRate, DeviceRotationRate);
  dart.defineExtensionNames([
    'close',
    'show',
    'showModal',
    'open',
    'returnValue'
  ]);
  class DialogElement extends HtmlElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    created() {
      this[dartx.open] = null;
      this[dartx.returnValue] = null;
      super.created();
    }
    get [dartx.open]() {
      return this.open;
    }
    set [dartx.open](value) {
      this.open = value;
    }
    get [dartx.returnValue]() {
      return this.returnValue;
    }
    set [dartx.returnValue](value) {
      this.returnValue = value;
    }
    [dartx.close](returnValue) {
      return this.close(returnValue);
    }
    [dartx.show]() {
      return this.show();
    }
    [dartx.showModal]() {
      return this.showModal();
    }
  }
  dart.defineNamedConstructor(DialogElement, 'created');
  dart.setSignature(DialogElement, {
    constructors: () => ({
      _: [DialogElement, []],
      created: [DialogElement, []]
    }),
    methods: () => ({
      [dartx.close]: [dart.void, [core.String]],
      [dartx.show]: [dart.void, []],
      [dartx.showModal]: [dart.void, []]
    })
  });
  DialogElement[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('HTMLDialogElement')), dart.const(new _metadata.Unstable()), dart.const(new _js_helper.Native("HTMLDialogElement"))];
  dart.registerExtension(dart.global.HTMLDialogElement, DialogElement);
  const _copyTo = Symbol('_copyTo');
  const _getMetadata = Symbol('_getMetadata');
  const _getParent = Symbol('_getParent');
  const _moveTo = Symbol('_moveTo');
  const _remove = Symbol('_remove');
  dart.defineExtensionNames([
    'copyTo',
    'getMetadata',
    'getParent',
    'moveTo',
    'remove',
    'toUrl',
    'filesystem',
    'fullPath',
    'isDirectory',
    'isFile',
    'name'
  ]);
  class Entry extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.filesystem]() {
      return this.filesystem;
    }
    get [dartx.fullPath]() {
      return this.fullPath;
    }
    get [dartx.isDirectory]() {
      return this.isDirectory;
    }
    get [dartx.isFile]() {
      return this.isFile;
    }
    get [dartx.name]() {
      return this.name;
    }
    [_copyTo](parent, opts) {
      return this.copyTo(parent, opts);
    }
    [dartx.copyTo](parent, opts) {
      let name = opts && 'name' in opts ? opts.name : null;
      let completer = async.Completer$(Entry).new();
      this[_copyTo](parent, {name: name, successCallback: dart.fn(value => {
          completer.complete(value);
        }, dart.void, [Entry]), errorCallback: dart.fn(error => {
          completer.completeError(error);
        }, dart.void, [FileError])});
      return completer.future;
    }
    [_getMetadata](successCallback, errorCallback) {
      return this.getMetadata(successCallback, errorCallback);
    }
    [dartx.getMetadata]() {
      let completer = async.Completer$(Metadata).new();
      this[_getMetadata](dart.fn(value => {
        completer.complete(value);
      }, dart.void, [Metadata]), dart.fn(error => {
        completer.completeError(error);
      }, dart.void, [FileError]));
      return completer.future;
    }
    [_getParent](successCallback, errorCallback) {
      return this.getParent(successCallback, errorCallback);
    }
    [dartx.getParent]() {
      let completer = async.Completer$(Entry).new();
      this[_getParent](dart.fn(value => {
        completer.complete(value);
      }, dart.void, [Entry]), dart.fn(error => {
        completer.completeError(error);
      }, dart.void, [FileError]));
      return completer.future;
    }
    [_moveTo](parent, opts) {
      return this.moveTo(parent, opts);
    }
    [dartx.moveTo](parent, opts) {
      let name = opts && 'name' in opts ? opts.name : null;
      let completer = async.Completer$(Entry).new();
      this[_moveTo](parent, {name: name, successCallback: dart.fn(value => {
          completer.complete(value);
        }, dart.void, [Entry]), errorCallback: dart.fn(error => {
          completer.completeError(error);
        }, dart.void, [FileError])});
      return completer.future;
    }
    [_remove](successCallback, errorCallback) {
      return this.remove(successCallback, errorCallback);
    }
    [dartx.remove]() {
      let completer = async.Completer.new();
      this[_remove](dart.fn(() => {
        completer.complete();
      }, dart.void, []), dart.fn(error => {
        completer.completeError(error);
      }, dart.void, [FileError]));
      return completer.future;
    }
    [dartx.toUrl]() {
      return this.toURL();
    }
  }
  dart.setSignature(Entry, {
    constructors: () => ({_: [Entry, []]}),
    methods: () => ({
      [_copyTo]: [dart.void, [DirectoryEntry], {name: core.String, successCallback: _EntryCallback, errorCallback: _ErrorCallback}],
      [dartx.copyTo]: [async.Future$(Entry), [DirectoryEntry], {name: core.String}],
      [_getMetadata]: [dart.void, [MetadataCallback], [_ErrorCallback]],
      [dartx.getMetadata]: [async.Future$(Metadata), []],
      [_getParent]: [dart.void, [], [_EntryCallback, _ErrorCallback]],
      [dartx.getParent]: [async.Future$(Entry), []],
      [_moveTo]: [dart.void, [DirectoryEntry], {name: core.String, successCallback: _EntryCallback, errorCallback: _ErrorCallback}],
      [dartx.moveTo]: [async.Future$(Entry), [DirectoryEntry], {name: core.String}],
      [_remove]: [dart.void, [VoidCallback], [_ErrorCallback]],
      [dartx.remove]: [async.Future, []],
      [dartx.toUrl]: [core.String, []]
    })
  });
  Entry[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('Entry')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("Entry"))];
  dart.registerExtension(dart.global.Entry, Entry);
  const _getDirectory = Symbol('_getDirectory');
  const _getFile = Symbol('_getFile');
  const __getDirectory_1 = Symbol('__getDirectory_1');
  const __getDirectory_2 = Symbol('__getDirectory_2');
  const __getDirectory_3 = Symbol('__getDirectory_3');
  const __getDirectory_4 = Symbol('__getDirectory_4');
  const __getDirectory = Symbol('__getDirectory');
  const __getFile_1 = Symbol('__getFile_1');
  const __getFile_2 = Symbol('__getFile_2');
  const __getFile_3 = Symbol('__getFile_3');
  const __getFile_4 = Symbol('__getFile_4');
  const __getFile = Symbol('__getFile');
  const _removeRecursively = Symbol('_removeRecursively');
  dart.defineExtensionNames([
    'createDirectory',
    'getDirectory',
    'createFile',
    'getFile',
    'createReader',
    'removeRecursively'
  ]);
  class DirectoryEntry extends Entry {
    [dartx.createDirectory](path, opts) {
      let exclusive = opts && 'exclusive' in opts ? opts.exclusive : false;
      return this[_getDirectory](path, {options: dart.map({create: true, exclusive: exclusive})});
    }
    [dartx.getDirectory](path) {
      return this[_getDirectory](path);
    }
    [dartx.createFile](path, opts) {
      let exclusive = opts && 'exclusive' in opts ? opts.exclusive : false;
      return this[_getFile](path, {options: dart.map({create: true, exclusive: exclusive})});
    }
    [dartx.getFile](path) {
      return this[_getFile](path);
    }
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    [dartx.createReader]() {
      return this.createReader();
    }
    [__getDirectory](path, opts) {
      let options = opts && 'options' in opts ? opts.options : null;
      let successCallback = opts && 'successCallback' in opts ? opts.successCallback : null;
      let errorCallback = opts && 'errorCallback' in opts ? opts.errorCallback : null;
      if (errorCallback != null) {
        let options_1 = html_common.convertDartToNative_Dictionary(options);
        this[__getDirectory_1](path, options_1, successCallback, errorCallback);
        return;
      }
      if (successCallback != null) {
        let options_1 = html_common.convertDartToNative_Dictionary(options);
        this[__getDirectory_2](path, options_1, successCallback);
        return;
      }
      if (options != null) {
        let options_1 = html_common.convertDartToNative_Dictionary(options);
        this[__getDirectory_3](path, options_1);
        return;
      }
      this[__getDirectory_4](path);
      return;
    }
    [__getDirectory_1](path, options, successCallback, errorCallback) {
      return this.getDirectory(path, options, successCallback, errorCallback);
    }
    [__getDirectory_2](path, options, successCallback) {
      return this.getDirectory(path, options, successCallback);
    }
    [__getDirectory_3](path, options) {
      return this.getDirectory(path, options);
    }
    [__getDirectory_4](path) {
      return this.getDirectory(path);
    }
    [_getDirectory](path, opts) {
      let options = opts && 'options' in opts ? opts.options : null;
      let completer = async.Completer$(Entry).new();
      this[__getDirectory](path, {options: options, successCallback: dart.fn(value => {
          completer.complete(value);
        }, dart.void, [Entry]), errorCallback: dart.fn(error => {
          completer.completeError(error);
        }, dart.void, [FileError])});
      return completer.future;
    }
    [__getFile](path, opts) {
      let options = opts && 'options' in opts ? opts.options : null;
      let successCallback = opts && 'successCallback' in opts ? opts.successCallback : null;
      let errorCallback = opts && 'errorCallback' in opts ? opts.errorCallback : null;
      if (errorCallback != null) {
        let options_1 = html_common.convertDartToNative_Dictionary(options);
        this[__getFile_1](path, options_1, successCallback, errorCallback);
        return;
      }
      if (successCallback != null) {
        let options_1 = html_common.convertDartToNative_Dictionary(options);
        this[__getFile_2](path, options_1, successCallback);
        return;
      }
      if (options != null) {
        let options_1 = html_common.convertDartToNative_Dictionary(options);
        this[__getFile_3](path, options_1);
        return;
      }
      this[__getFile_4](path);
      return;
    }
    [__getFile_1](path, options, successCallback, errorCallback) {
      return this.getFile(path, options, successCallback, errorCallback);
    }
    [__getFile_2](path, options, successCallback) {
      return this.getFile(path, options, successCallback);
    }
    [__getFile_3](path, options) {
      return this.getFile(path, options);
    }
    [__getFile_4](path) {
      return this.getFile(path);
    }
    [_getFile](path, opts) {
      let options = opts && 'options' in opts ? opts.options : null;
      let completer = async.Completer$(Entry).new();
      this[__getFile](path, {options: options, successCallback: dart.fn(value => {
          completer.complete(value);
        }, dart.void, [Entry]), errorCallback: dart.fn(error => {
          completer.completeError(error);
        }, dart.void, [FileError])});
      return completer.future;
    }
    [_removeRecursively](successCallback, errorCallback) {
      return this.removeRecursively(successCallback, errorCallback);
    }
    [dartx.removeRecursively]() {
      let completer = async.Completer.new();
      this[_removeRecursively](dart.fn(() => {
        completer.complete();
      }, dart.void, []), dart.fn(error => {
        completer.completeError(error);
      }, dart.void, [FileError]));
      return completer.future;
    }
  }
  dart.setSignature(DirectoryEntry, {
    constructors: () => ({_: [DirectoryEntry, []]}),
    methods: () => ({
      [dartx.createDirectory]: [async.Future$(Entry), [core.String], {exclusive: core.bool}],
      [dartx.getDirectory]: [async.Future$(Entry), [core.String]],
      [dartx.createFile]: [async.Future$(Entry), [core.String], {exclusive: core.bool}],
      [dartx.getFile]: [async.Future$(Entry), [core.String]],
      [dartx.createReader]: [DirectoryReader, []],
      [__getDirectory]: [dart.void, [core.String], {options: core.Map, successCallback: _EntryCallback, errorCallback: _ErrorCallback}],
      [__getDirectory_1]: [dart.void, [dart.dynamic, dart.dynamic, _EntryCallback, _ErrorCallback]],
      [__getDirectory_2]: [dart.void, [dart.dynamic, dart.dynamic, _EntryCallback]],
      [__getDirectory_3]: [dart.void, [dart.dynamic, dart.dynamic]],
      [__getDirectory_4]: [dart.void, [dart.dynamic]],
      [_getDirectory]: [async.Future$(Entry), [core.String], {options: core.Map}],
      [__getFile]: [dart.void, [core.String], {options: core.Map, successCallback: _EntryCallback, errorCallback: _ErrorCallback}],
      [__getFile_1]: [dart.void, [dart.dynamic, dart.dynamic, _EntryCallback, _ErrorCallback]],
      [__getFile_2]: [dart.void, [dart.dynamic, dart.dynamic, _EntryCallback]],
      [__getFile_3]: [dart.void, [dart.dynamic, dart.dynamic]],
      [__getFile_4]: [dart.void, [dart.dynamic]],
      [_getFile]: [async.Future$(Entry), [core.String], {options: core.Map}],
      [_removeRecursively]: [dart.void, [VoidCallback], [_ErrorCallback]],
      [dartx.removeRecursively]: [async.Future, []]
    })
  });
  DirectoryEntry[dart.metadata] = () => [dart.const(new _metadata.DomName('DirectoryEntry')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("DirectoryEntry"))];
  dart.registerExtension(dart.global.DirectoryEntry, DirectoryEntry);
  const _readEntries = Symbol('_readEntries');
  dart.defineExtensionNames([
    'readEntries'
  ]);
  class DirectoryReader extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    [_readEntries](successCallback, errorCallback) {
      return this.readEntries(successCallback, errorCallback);
    }
    [dartx.readEntries]() {
      let completer = async.Completer$(core.List$(Entry)).new();
      this[_readEntries](dart.fn(value => {
        completer.complete(value);
      }, dart.void, [core.List$(Entry)]), dart.fn(error => {
        completer.completeError(error);
      }, dart.void, [FileError]));
      return completer.future;
    }
  }
  dart.setSignature(DirectoryReader, {
    constructors: () => ({_: [DirectoryReader, []]}),
    methods: () => ({
      [_readEntries]: [dart.void, [_EntriesCallback], [_ErrorCallback]],
      [dartx.readEntries]: [async.Future$(core.List$(Entry)), []]
    })
  });
  DirectoryReader[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('DirectoryReader')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("DirectoryReader"))];
  dart.registerExtension(dart.global.DirectoryReader, DirectoryReader);
  class DivElement extends HtmlElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return dart.as(exports.document[dartx.createElement]("div"), DivElement);
    }
    created() {
      super.created();
    }
  }
  dart.defineNamedConstructor(DivElement, 'created');
  dart.setSignature(DivElement, {
    constructors: () => ({
      _: [DivElement, []],
      new: [DivElement, []],
      created: [DivElement, []]
    })
  });
  DivElement[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('HTMLDivElement')), dart.const(new _js_helper.Native("HTMLDivElement"))];
  dart.registerExtension(dart.global.HTMLDivElement, DivElement);
  const _body = Symbol('_body');
  const _get_window = Symbol('_get_window');
  const _head = Symbol('_head');
  const _lastModified = Symbol('_lastModified');
  const _preferredStylesheetSet = Symbol('_preferredStylesheetSet');
  const _referrer = Symbol('_referrer');
  const _selectedStylesheetSet = Symbol('_selectedStylesheetSet');
  const _styleSheets = Symbol('_styleSheets');
  const _title = Symbol('_title');
  const _webkitFullscreenElement = Symbol('_webkitFullscreenElement');
  const _webkitFullscreenEnabled = Symbol('_webkitFullscreenEnabled');
  const _webkitHidden = Symbol('_webkitHidden');
  const _webkitVisibilityState = Symbol('_webkitVisibilityState');
  const _caretRangeFromPoint = Symbol('_caretRangeFromPoint');
  const _createElement = Symbol('_createElement');
  const _createElementNS = Symbol('_createElementNS');
  const _createTouch_1 = Symbol('_createTouch_1');
  const _createTouch = Symbol('_createTouch');
  const _createTouchList = Symbol('_createTouchList');
  const _elementFromPoint = Symbol('_elementFromPoint');
  const _getCssCanvasContext = Symbol('_getCssCanvasContext');
  const _webkitExitFullscreen = Symbol('_webkitExitFullscreen');
  const _createElement_2 = Symbol('_createElement_2');
  const _createElementNS_2 = Symbol('_createElementNS_2');
  const _createNodeIterator = Symbol('_createNodeIterator');
  const _createTreeWalker = Symbol('_createTreeWalker');
  dart.defineExtensionNames([
    'window',
    'adoptNode',
    'createDocumentFragment',
    'createRange',
    'execCommand',
    'exitFullscreen',
    'exitPointerLock',
    'getElementById',
    'getElementsByClassName',
    'getElementsByName',
    'getElementsByTagName',
    'importNode',
    'queryCommandEnabled',
    'queryCommandIndeterm',
    'queryCommandState',
    'queryCommandSupported',
    'queryCommandValue',
    'transformDocumentToTreeView',
    'querySelector',
    'onAbort',
    'onBeforeCopy',
    'onBeforeCut',
    'onBeforePaste',
    'onBlur',
    'onCanPlay',
    'onCanPlayThrough',
    'onChange',
    'onClick',
    'onContextMenu',
    'onCopy',
    'onCut',
    'onDoubleClick',
    'onDrag',
    'onDragEnd',
    'onDragEnter',
    'onDragLeave',
    'onDragOver',
    'onDragStart',
    'onDrop',
    'onDurationChange',
    'onEmptied',
    'onEnded',
    'onError',
    'onFocus',
    'onInput',
    'onInvalid',
    'onKeyDown',
    'onKeyPress',
    'onKeyUp',
    'onLoad',
    'onLoadedData',
    'onLoadedMetadata',
    'onMouseDown',
    'onMouseEnter',
    'onMouseLeave',
    'onMouseMove',
    'onMouseOut',
    'onMouseOver',
    'onMouseUp',
    'onMouseWheel',
    'onPaste',
    'onPause',
    'onPlay',
    'onPlaying',
    'onPointerLockChange',
    'onPointerLockError',
    'onRateChange',
    'onReadyStateChange',
    'onReset',
    'onResize',
    'onScroll',
    'onSearch',
    'onSecurityPolicyViolation',
    'onSeeked',
    'onSeeking',
    'onSelect',
    'onSelectionChange',
    'onSelectStart',
    'onStalled',
    'onSubmit',
    'onSuspend',
    'onTimeUpdate',
    'onTouchCancel',
    'onTouchEnd',
    'onTouchMove',
    'onTouchStart',
    'onVolumeChange',
    'onWaiting',
    'onFullscreenChange',
    'onFullscreenError',
    'querySelectorAll',
    'query',
    'queryAll',
    'supportsRegisterElement',
    'supportsRegister',
    'createElement',
    'createElementNS',
    'activeElement',
    'contentType',
    'cookie',
    'currentScript',
    'documentElement',
    'domain',
    'fonts',
    'fullscreenElement',
    'fullscreenEnabled',
    'hidden',
    'implementation',
    'pointerLockElement',
    'readyState',
    'rootElement',
    'timeline',
    'visibilityState'
  ]);
  class Document extends Node {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.activeElement]() {
      return this.activeElement;
    }
    get [_body]() {
      return this.body;
    }
    set [_body](value) {
      this.body = value;
    }
    get [dartx.contentType]() {
      return this.contentType;
    }
    get [dartx.cookie]() {
      return this.cookie;
    }
    set [dartx.cookie](value) {
      this.cookie = value;
    }
    get [dartx.currentScript]() {
      return this.currentScript;
    }
    get [dartx.window]() {
      return _convertNativeToDart_Window(this[_get_window]);
    }
    get [_get_window]() {
      return this.defaultView;
    }
    get [dartx.documentElement]() {
      return this.documentElement;
    }
    get [dartx.domain]() {
      return this.domain;
    }
    get [dartx.fonts]() {
      return this.fonts;
    }
    get [dartx.fullscreenElement]() {
      return this.fullscreenElement;
    }
    get [dartx.fullscreenEnabled]() {
      return this.fullscreenEnabled;
    }
    get [_head]() {
      return this.head;
    }
    get [dartx.hidden]() {
      return this.hidden;
    }
    get [dartx.implementation]() {
      return this.implementation;
    }
    get [_lastModified]() {
      return this.lastModified;
    }
    get [dartx.pointerLockElement]() {
      return this.pointerLockElement;
    }
    get [_preferredStylesheetSet]() {
      return this.preferredStylesheetSet;
    }
    get [dartx.readyState]() {
      return this.readyState;
    }
    get [_referrer]() {
      return this.referrer;
    }
    get [dartx.rootElement]() {
      return this.rootElement;
    }
    get [_selectedStylesheetSet]() {
      return this.selectedStylesheetSet;
    }
    set [_selectedStylesheetSet](value) {
      this.selectedStylesheetSet = value;
    }
    get [_styleSheets]() {
      return this.styleSheets;
    }
    get [dartx.timeline]() {
      return this.timeline;
    }
    get [_title]() {
      return this.title;
    }
    set [_title](value) {
      this.title = value;
    }
    get [dartx.visibilityState]() {
      return this.visibilityState;
    }
    get [_webkitFullscreenElement]() {
      return this.webkitFullscreenElement;
    }
    get [_webkitFullscreenEnabled]() {
      return this.webkitFullscreenEnabled;
    }
    get [_webkitHidden]() {
      return this.webkitHidden;
    }
    get [_webkitVisibilityState]() {
      return this.webkitVisibilityState;
    }
    [dartx.adoptNode](node) {
      return this.adoptNode(node);
    }
    [_caretRangeFromPoint](x, y) {
      return this.caretRangeFromPoint(x, y);
    }
    [dartx.createDocumentFragment]() {
      return this.createDocumentFragment();
    }
    [_createElement](localName_OR_tagName, typeExtension) {
      return this.createElement(localName_OR_tagName, typeExtension);
    }
    [_createElementNS](namespaceURI, qualifiedName, typeExtension) {
      return this.createElementNS(namespaceURI, qualifiedName, typeExtension);
    }
    [_createEvent](eventType) {
      return this.createEvent(eventType);
    }
    [dartx.createRange]() {
      return this.createRange();
    }
    [_createTextNode](data) {
      return this.createTextNode(data);
    }
    [_createTouch](window, target, identifier, pageX, pageY, screenX, screenY, webkitRadiusX, webkitRadiusY, webkitRotationAngle, webkitForce) {
      let target_1 = _convertDartToNative_EventTarget(target);
      return this[_createTouch_1](window, target_1, identifier, pageX, pageY, screenX, screenY, webkitRadiusX, webkitRadiusY, webkitRotationAngle, webkitForce);
    }
    [_createTouch_1](window, target, identifier, pageX, pageY, screenX, screenY, webkitRadiusX, webkitRadiusY, webkitRotationAngle, webkitForce) {
      return this.createTouch(window, target, identifier, pageX, pageY, screenX, screenY, webkitRadiusX, webkitRadiusY, webkitRotationAngle, webkitForce);
    }
    [_createTouchList](touches) {
      return this.createTouchList(touches);
    }
    [_elementFromPoint](x, y) {
      return this.elementFromPoint(x, y);
    }
    [dartx.execCommand](command, userInterface, value) {
      return this.execCommand(command, userInterface, value);
    }
    [dartx.exitFullscreen]() {
      return this.exitFullscreen();
    }
    [dartx.exitPointerLock]() {
      return this.exitPointerLock();
    }
    [_getCssCanvasContext](contextId, name, width, height) {
      return this.getCSSCanvasContext(contextId, name, width, height);
    }
    [dartx.getElementById](elementId) {
      return this.getElementById(elementId);
    }
    [dartx.getElementsByClassName](classNames) {
      return this.getElementsByClassName(classNames);
    }
    [dartx.getElementsByName](elementName) {
      return this.getElementsByName(elementName);
    }
    [dartx.getElementsByTagName](localName) {
      return this.getElementsByTagName(localName);
    }
    [dartx.importNode](node, deep) {
      return this.importNode(node, deep);
    }
    [dartx.queryCommandEnabled](command) {
      return this.queryCommandEnabled(command);
    }
    [dartx.queryCommandIndeterm](command) {
      return this.queryCommandIndeterm(command);
    }
    [dartx.queryCommandState](command) {
      return this.queryCommandState(command);
    }
    [dartx.queryCommandSupported](command) {
      return this.queryCommandSupported(command);
    }
    [dartx.queryCommandValue](command) {
      return this.queryCommandValue(command);
    }
    [dartx.transformDocumentToTreeView](noStyleMessage) {
      return this.transformDocumentToTreeView(noStyleMessage);
    }
    [_webkitExitFullscreen]() {
      return this.webkitExitFullscreen();
    }
    get [_childElementCount]() {
      return this.childElementCount;
    }
    get [_children]() {
      return this.children;
    }
    get [_firstElementChild]() {
      return this.firstElementChild;
    }
    get [_lastElementChild]() {
      return this.lastElementChild;
    }
    [dartx.querySelector](selectors) {
      return this.querySelector(selectors);
    }
    [_querySelectorAll](selectors) {
      return this.querySelectorAll(selectors);
    }
    get [dartx.onAbort]() {
      return Element.abortEvent.forTarget(this);
    }
    get [dartx.onBeforeCopy]() {
      return Element.beforeCopyEvent.forTarget(this);
    }
    get [dartx.onBeforeCut]() {
      return Element.beforeCutEvent.forTarget(this);
    }
    get [dartx.onBeforePaste]() {
      return Element.beforePasteEvent.forTarget(this);
    }
    get [dartx.onBlur]() {
      return Element.blurEvent.forTarget(this);
    }
    get [dartx.onCanPlay]() {
      return Element.canPlayEvent.forTarget(this);
    }
    get [dartx.onCanPlayThrough]() {
      return Element.canPlayThroughEvent.forTarget(this);
    }
    get [dartx.onChange]() {
      return Element.changeEvent.forTarget(this);
    }
    get [dartx.onClick]() {
      return Element.clickEvent.forTarget(this);
    }
    get [dartx.onContextMenu]() {
      return Element.contextMenuEvent.forTarget(this);
    }
    get [dartx.onCopy]() {
      return Element.copyEvent.forTarget(this);
    }
    get [dartx.onCut]() {
      return Element.cutEvent.forTarget(this);
    }
    get [dartx.onDoubleClick]() {
      return Element.doubleClickEvent.forTarget(this);
    }
    get [dartx.onDrag]() {
      return Element.dragEvent.forTarget(this);
    }
    get [dartx.onDragEnd]() {
      return Element.dragEndEvent.forTarget(this);
    }
    get [dartx.onDragEnter]() {
      return Element.dragEnterEvent.forTarget(this);
    }
    get [dartx.onDragLeave]() {
      return Element.dragLeaveEvent.forTarget(this);
    }
    get [dartx.onDragOver]() {
      return Element.dragOverEvent.forTarget(this);
    }
    get [dartx.onDragStart]() {
      return Element.dragStartEvent.forTarget(this);
    }
    get [dartx.onDrop]() {
      return Element.dropEvent.forTarget(this);
    }
    get [dartx.onDurationChange]() {
      return Element.durationChangeEvent.forTarget(this);
    }
    get [dartx.onEmptied]() {
      return Element.emptiedEvent.forTarget(this);
    }
    get [dartx.onEnded]() {
      return Element.endedEvent.forTarget(this);
    }
    get [dartx.onError]() {
      return Element.errorEvent.forTarget(this);
    }
    get [dartx.onFocus]() {
      return Element.focusEvent.forTarget(this);
    }
    get [dartx.onInput]() {
      return Element.inputEvent.forTarget(this);
    }
    get [dartx.onInvalid]() {
      return Element.invalidEvent.forTarget(this);
    }
    get [dartx.onKeyDown]() {
      return Element.keyDownEvent.forTarget(this);
    }
    get [dartx.onKeyPress]() {
      return Element.keyPressEvent.forTarget(this);
    }
    get [dartx.onKeyUp]() {
      return Element.keyUpEvent.forTarget(this);
    }
    get [dartx.onLoad]() {
      return Element.loadEvent.forTarget(this);
    }
    get [dartx.onLoadedData]() {
      return Element.loadedDataEvent.forTarget(this);
    }
    get [dartx.onLoadedMetadata]() {
      return Element.loadedMetadataEvent.forTarget(this);
    }
    get [dartx.onMouseDown]() {
      return Element.mouseDownEvent.forTarget(this);
    }
    get [dartx.onMouseEnter]() {
      return Element.mouseEnterEvent.forTarget(this);
    }
    get [dartx.onMouseLeave]() {
      return Element.mouseLeaveEvent.forTarget(this);
    }
    get [dartx.onMouseMove]() {
      return Element.mouseMoveEvent.forTarget(this);
    }
    get [dartx.onMouseOut]() {
      return Element.mouseOutEvent.forTarget(this);
    }
    get [dartx.onMouseOver]() {
      return Element.mouseOverEvent.forTarget(this);
    }
    get [dartx.onMouseUp]() {
      return Element.mouseUpEvent.forTarget(this);
    }
    get [dartx.onMouseWheel]() {
      return Element.mouseWheelEvent.forTarget(this);
    }
    get [dartx.onPaste]() {
      return Element.pasteEvent.forTarget(this);
    }
    get [dartx.onPause]() {
      return Element.pauseEvent.forTarget(this);
    }
    get [dartx.onPlay]() {
      return Element.playEvent.forTarget(this);
    }
    get [dartx.onPlaying]() {
      return Element.playingEvent.forTarget(this);
    }
    get [dartx.onPointerLockChange]() {
      return Document.pointerLockChangeEvent.forTarget(this);
    }
    get [dartx.onPointerLockError]() {
      return Document.pointerLockErrorEvent.forTarget(this);
    }
    get [dartx.onRateChange]() {
      return Element.rateChangeEvent.forTarget(this);
    }
    get [dartx.onReadyStateChange]() {
      return Document.readyStateChangeEvent.forTarget(this);
    }
    get [dartx.onReset]() {
      return Element.resetEvent.forTarget(this);
    }
    get [dartx.onResize]() {
      return Element.resizeEvent.forTarget(this);
    }
    get [dartx.onScroll]() {
      return Element.scrollEvent.forTarget(this);
    }
    get [dartx.onSearch]() {
      return Element.searchEvent.forTarget(this);
    }
    get [dartx.onSecurityPolicyViolation]() {
      return Document.securityPolicyViolationEvent.forTarget(this);
    }
    get [dartx.onSeeked]() {
      return Element.seekedEvent.forTarget(this);
    }
    get [dartx.onSeeking]() {
      return Element.seekingEvent.forTarget(this);
    }
    get [dartx.onSelect]() {
      return Element.selectEvent.forTarget(this);
    }
    get [dartx.onSelectionChange]() {
      return Document.selectionChangeEvent.forTarget(this);
    }
    get [dartx.onSelectStart]() {
      return Element.selectStartEvent.forTarget(this);
    }
    get [dartx.onStalled]() {
      return Element.stalledEvent.forTarget(this);
    }
    get [dartx.onSubmit]() {
      return Element.submitEvent.forTarget(this);
    }
    get [dartx.onSuspend]() {
      return Element.suspendEvent.forTarget(this);
    }
    get [dartx.onTimeUpdate]() {
      return Element.timeUpdateEvent.forTarget(this);
    }
    get [dartx.onTouchCancel]() {
      return Element.touchCancelEvent.forTarget(this);
    }
    get [dartx.onTouchEnd]() {
      return Element.touchEndEvent.forTarget(this);
    }
    get [dartx.onTouchMove]() {
      return Element.touchMoveEvent.forTarget(this);
    }
    get [dartx.onTouchStart]() {
      return Element.touchStartEvent.forTarget(this);
    }
    get [dartx.onVolumeChange]() {
      return Element.volumeChangeEvent.forTarget(this);
    }
    get [dartx.onWaiting]() {
      return Element.waitingEvent.forTarget(this);
    }
    get [dartx.onFullscreenChange]() {
      return Element.fullscreenChangeEvent.forTarget(this);
    }
    get [dartx.onFullscreenError]() {
      return Element.fullscreenErrorEvent.forTarget(this);
    }
    [dartx.querySelectorAll](selectors) {
      return new _FrozenElementList._wrap(this[_querySelectorAll](selectors));
    }
    [dartx.query](relativeSelectors) {
      return this[dartx.querySelector](relativeSelectors);
    }
    [dartx.queryAll](relativeSelectors) {
      return this[dartx.querySelectorAll](relativeSelectors);
    }
    get [dartx.supportsRegisterElement]() {
      return "registerElement" in this;
    }
    get [dartx.supportsRegister]() {
      return this[dartx.supportsRegisterElement];
    }
    [dartx.createElement](tagName, typeExtension) {
      if (typeExtension === void 0) typeExtension = null;
      return dart.as(typeExtension == null ? this[_createElement_2](tagName) : this[_createElement](tagName, typeExtension), Element);
    }
    [_createElement_2](tagName) {
      return this.createElement(tagName);
    }
    [_createElementNS_2](namespaceURI, qualifiedName) {
      return this.createElementNS(namespaceURI, qualifiedName);
    }
    [dartx.createElementNS](namespaceURI, qualifiedName, typeExtension) {
      if (typeExtension === void 0) typeExtension = null;
      return dart.as(typeExtension == null ? this[_createElementNS_2](namespaceURI, qualifiedName) : this[_createElementNS](namespaceURI, qualifiedName, typeExtension), Element);
    }
    [_createNodeIterator](root, whatToShow, filter) {
      if (whatToShow === void 0) whatToShow = null;
      if (filter === void 0) filter = null;
      return dart.as(this.createNodeIterator(root, whatToShow, filter, false), NodeIterator);
    }
    [_createTreeWalker](root, whatToShow, filter) {
      if (whatToShow === void 0) whatToShow = null;
      if (filter === void 0) filter = null;
      return dart.as(this.createTreeWalker(root, whatToShow, filter, false), TreeWalker);
    }
  }
  dart.setSignature(Document, {
    constructors: () => ({_: [Document, []]}),
    methods: () => ({
      [dartx.adoptNode]: [Node, [Node]],
      [_caretRangeFromPoint]: [Range, [core.int, core.int]],
      [dartx.createDocumentFragment]: [DocumentFragment, []],
      [_createElement]: [Element, [core.String], [core.String]],
      [_createElementNS]: [Element, [core.String, core.String], [core.String]],
      [_createEvent]: [Event, [core.String]],
      [dartx.createRange]: [Range, []],
      [_createTextNode]: [Text, [core.String]],
      [_createTouch]: [Touch, [Window, EventTarget, core.int, core.num, core.num, core.num, core.num, core.num, core.num, core.num, core.num]],
      [_createTouch_1]: [Touch, [Window, dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic]],
      [_createTouchList]: [TouchList, [Touch]],
      [_elementFromPoint]: [Element, [core.int, core.int]],
      [dartx.execCommand]: [core.bool, [core.String, core.bool, core.String]],
      [dartx.exitFullscreen]: [dart.void, []],
      [dartx.exitPointerLock]: [dart.void, []],
      [_getCssCanvasContext]: [core.Object, [core.String, core.String, core.int, core.int]],
      [dartx.getElementById]: [Element, [core.String]],
      [dartx.getElementsByClassName]: [core.List$(Node), [core.String]],
      [dartx.getElementsByName]: [core.List$(Node), [core.String]],
      [dartx.getElementsByTagName]: [core.List$(Node), [core.String]],
      [dartx.importNode]: [Node, [Node], [core.bool]],
      [dartx.queryCommandEnabled]: [core.bool, [core.String]],
      [dartx.queryCommandIndeterm]: [core.bool, [core.String]],
      [dartx.queryCommandState]: [core.bool, [core.String]],
      [dartx.queryCommandSupported]: [core.bool, [core.String]],
      [dartx.queryCommandValue]: [core.String, [core.String]],
      [dartx.transformDocumentToTreeView]: [dart.void, [core.String]],
      [_webkitExitFullscreen]: [dart.void, []],
      [dartx.querySelector]: [Element, [core.String]],
      [_querySelectorAll]: [core.List$(Node), [core.String]],
      [dartx.querySelectorAll]: [ElementList$(Element), [core.String]],
      [dartx.query]: [Element, [core.String]],
      [dartx.queryAll]: [ElementList$(Element), [core.String]],
      [dartx.createElement]: [Element, [core.String], [core.String]],
      [_createElement_2]: [dart.dynamic, [core.String]],
      [_createElementNS_2]: [dart.dynamic, [core.String, core.String]],
      [dartx.createElementNS]: [Element, [core.String, core.String], [core.String]],
      [_createNodeIterator]: [NodeIterator, [Node], [core.int, NodeFilter]],
      [_createTreeWalker]: [TreeWalker, [Node], [core.int, NodeFilter]]
    })
  });
  Document[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('Document')), dart.const(new _js_helper.Native("Document"))];
  dart.defineLazyProperties(Document, {
    get pointerLockChangeEvent() {
      return dart.const(new (EventStreamProvider$(Event))('pointerlockchange'));
    },
    get pointerLockErrorEvent() {
      return dart.const(new (EventStreamProvider$(Event))('pointerlockerror'));
    },
    get readyStateChangeEvent() {
      return dart.const(new (EventStreamProvider$(Event))('readystatechange'));
    },
    get securityPolicyViolationEvent() {
      return dart.const(new (EventStreamProvider$(SecurityPolicyViolationEvent))('securitypolicyviolation'));
    },
    get selectionChangeEvent() {
      return dart.const(new (EventStreamProvider$(Event))('selectionchange'));
    }
  });
  dart.registerExtension(dart.global.Document, Document);
  const _docChildren = Symbol('_docChildren');
  dart.defineExtensionNames([
    'children',
    'children',
    'querySelectorAll',
    'innerHtml',
    'innerHtml',
    'setInnerHtml',
    'appendText',
    'appendHtml',
    'query',
    'queryAll',
    'getElementById',
    'querySelector'
  ]);
  class DocumentFragment extends Node {
    static new() {
      return exports.document[dartx.createDocumentFragment]();
    }
    static html(html, opts) {
      let validator = opts && 'validator' in opts ? opts.validator : null;
      let treeSanitizer = opts && 'treeSanitizer' in opts ? opts.treeSanitizer : null;
      return exports.document[dartx.body][dartx.createFragment](html, {validator: validator, treeSanitizer: treeSanitizer});
    }
    static svg(svgContent, opts) {
      let validator = opts && 'validator' in opts ? opts.validator : null;
      let treeSanitizer = opts && 'treeSanitizer' in opts ? opts.treeSanitizer : null;
      return svg.SvgSvgElement.new()[dartx.createFragment](svgContent, {validator: validator, treeSanitizer: treeSanitizer});
    }
    get [_children]() {
      return dart.throw(new core.UnimplementedError('Use _docChildren instead'));
    }
    get [_docChildren]() {
      return this._docChildren;
    }
    set [_docChildren](value) {
      this._docChildren = value;
    }
    get [dartx.children]() {
      if (this[_docChildren] == null) {
        this[_docChildren] = new html_common.FilteredElementList(this);
      }
      return this[_docChildren];
    }
    set [dartx.children](value) {
      let copy = core.List.from(value);
      let children = this[dartx.children];
      children[dartx.clear]();
      children[dartx.addAll](dart.as(copy, core.Iterable$(Element)));
    }
    [dartx.querySelectorAll](selectors) {
      return new _FrozenElementList._wrap(this[_querySelectorAll](selectors));
    }
    get [dartx.innerHtml]() {
      let e = Element.tag("div");
      e[dartx.append](this[dartx.clone](true));
      return e[dartx.innerHtml];
    }
    set [dartx.innerHtml](value) {
      this[dartx.setInnerHtml](value);
    }
    [dartx.setInnerHtml](html, opts) {
      let validator = opts && 'validator' in opts ? opts.validator : null;
      let treeSanitizer = opts && 'treeSanitizer' in opts ? opts.treeSanitizer : null;
      this[dartx.nodes][dartx.clear]();
      this[dartx.append](exports.document[dartx.body][dartx.createFragment](html, {validator: validator, treeSanitizer: treeSanitizer}));
    }
    [dartx.appendText](text) {
      this[dartx.append](Text.new(text));
    }
    [dartx.appendHtml](text, opts) {
      let validator = opts && 'validator' in opts ? opts.validator : null;
      let NodeTreeSanitizer = opts && 'NodeTreeSanitizer' in opts ? opts.NodeTreeSanitizer : null;
      let treeSanitizer = opts && 'treeSanitizer' in opts ? opts.treeSanitizer : null;
      this[dartx.append](DocumentFragment.html(text, {validator: validator, treeSanitizer: dart.as(treeSanitizer, NodeTreeSanitizer)}));
    }
    [dartx.query](relativeSelectors) {
      return this[dartx.querySelector](relativeSelectors);
    }
    [dartx.queryAll](relativeSelectors) {
      return this[dartx.querySelectorAll](relativeSelectors);
    }
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    [dartx.getElementById](elementId) {
      return this.getElementById(elementId);
    }
    get [_childElementCount]() {
      return this.childElementCount;
    }
    get [_firstElementChild]() {
      return this.firstElementChild;
    }
    get [_lastElementChild]() {
      return this.lastElementChild;
    }
    [dartx.querySelector](selectors) {
      return this.querySelector(selectors);
    }
    [_querySelectorAll](selectors) {
      return this.querySelectorAll(selectors);
    }
  }
  DocumentFragment[dart.implements] = () => [ParentNode];
  dart.setSignature(DocumentFragment, {
    constructors: () => ({
      new: [DocumentFragment, []],
      html: [DocumentFragment, [core.String], {validator: NodeValidator, treeSanitizer: NodeTreeSanitizer}],
      svg: [DocumentFragment, [core.String], {validator: NodeValidator, treeSanitizer: NodeTreeSanitizer}],
      _: [DocumentFragment, []]
    }),
    methods: () => ({
      [dartx.querySelectorAll]: [ElementList$(Element), [core.String]],
      [dartx.setInnerHtml]: [dart.void, [core.String], {validator: NodeValidator, treeSanitizer: NodeTreeSanitizer}],
      [dartx.appendText]: [dart.void, [core.String]],
      [dartx.appendHtml]: [dart.void, [core.String], {validator: NodeValidator, NodeTreeSanitizer: dart.dynamic, treeSanitizer: dart.dynamic}],
      [dartx.query]: [Element, [core.String]],
      [dartx.queryAll]: [ElementList$(Element), [core.String]],
      [dartx.getElementById]: [Element, [core.String]],
      [dartx.querySelector]: [Element, [core.String]],
      [_querySelectorAll]: [core.List$(Node), [core.String]]
    })
  });
  DocumentFragment[dart.metadata] = () => [dart.const(new _metadata.DomName('DocumentFragment')), dart.const(new _js_helper.Native("DocumentFragment"))];
  dart.registerExtension(dart.global.DocumentFragment, DocumentFragment);
  dart.defineExtensionNames([
    'message',
    'name'
  ]);
  class DomError extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new(name, message) {
      if (message === void 0) message = null;
      if (message != null) {
        return DomError._create_1(name, message);
      }
      return DomError._create_2(name);
    }
    static _create_1(name, message) {
      return dart.as(new DOMError(name, message), DomError);
    }
    static _create_2(name) {
      return dart.as(new DOMError(name), DomError);
    }
    get [dartx.message]() {
      return this.message;
    }
    get [dartx.name]() {
      return this.name;
    }
  }
  dart.setSignature(DomError, {
    constructors: () => ({
      _: [DomError, []],
      new: [DomError, [core.String], [core.String]]
    }),
    statics: () => ({
      _create_1: [DomError, [dart.dynamic, dart.dynamic]],
      _create_2: [DomError, [dart.dynamic]]
    }),
    names: ['_create_1', '_create_2']
  });
  DomError[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('DOMError')), dart.const(new _js_helper.Native("DOMError"))];
  dart.registerExtension(dart.global.DOMError, DomError);
  dart.defineExtensionNames([
    'name',
    'toString',
    'message'
  ]);
  class DomException extends _interceptors.Interceptor {
    get [dartx.name]() {
      let errorName = this.name;
      if (dart.notNull(html_common.Device.isWebKit) && errorName == 'SECURITY_ERR') return 'SecurityError';
      if (dart.notNull(html_common.Device.isWebKit) && errorName == 'SYNTAX_ERR') return 'SyntaxError';
      return errorName;
    }
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.message]() {
      return this.message;
    }
    toString() {
      return String(this);
    }
  }
  dart.setSignature(DomException, {
    constructors: () => ({_: [DomException, []]})
  });
  DomException[dart.metadata] = () => [dart.const(new _metadata.DomName('DOMException')), dart.const(new _metadata.Unstable()), dart.const(new _js_helper.Native("DOMException"))];
  DomException.INDEX_SIZE = 'IndexSizeError';
  DomException.HIERARCHY_REQUEST = 'HierarchyRequestError';
  DomException.WRONG_DOCUMENT = 'WrongDocumentError';
  DomException.INVALID_CHARACTER = 'InvalidCharacterError';
  DomException.NO_MODIFICATION_ALLOWED = 'NoModificationAllowedError';
  DomException.NOT_FOUND = 'NotFoundError';
  DomException.NOT_SUPPORTED = 'NotSupportedError';
  DomException.INVALID_STATE = 'InvalidStateError';
  DomException.SYNTAX = 'SyntaxError';
  DomException.INVALID_MODIFICATION = 'InvalidModificationError';
  DomException.NAMESPACE = 'NamespaceError';
  DomException.INVALID_ACCESS = 'InvalidAccessError';
  DomException.TYPE_MISMATCH = 'TypeMismatchError';
  DomException.SECURITY = 'SecurityError';
  DomException.NETWORK = 'NetworkError';
  DomException.ABORT = 'AbortError';
  DomException.URL_MISMATCH = 'URLMismatchError';
  DomException.QUOTA_EXCEEDED = 'QuotaExceededError';
  DomException.TIMEOUT = 'TimeoutError';
  DomException.INVALID_NODE_TYPE = 'InvalidNodeTypeError';
  DomException.DATA_CLONE = 'DataCloneError';
  dart.registerExtension(dart.global.DOMException, DomException);
  dart.defineExtensionNames([
    'createDocument',
    'createDocumentType',
    'createHtmlDocument',
    'hasFeature'
  ]);
  class DomImplementation extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    [dartx.createDocument](namespaceURI, qualifiedName, doctype) {
      return this.createDocument(namespaceURI, qualifiedName, doctype);
    }
    [dartx.createDocumentType](qualifiedName, publicId, systemId) {
      return this.createDocumentType(qualifiedName, publicId, systemId);
    }
    [dartx.createHtmlDocument](title) {
      return this.createHTMLDocument(title);
    }
    [dartx.hasFeature](feature, version) {
      return this.hasFeature(feature, version);
    }
  }
  dart.setSignature(DomImplementation, {
    constructors: () => ({_: [DomImplementation, []]}),
    methods: () => ({
      [dartx.createDocument]: [XmlDocument, [core.String, core.String, _DocumentType]],
      [dartx.createDocumentType]: [_DocumentType, [core.String, core.String, core.String]],
      [dartx.createHtmlDocument]: [HtmlDocument, [core.String]],
      [dartx.hasFeature]: [core.bool, [core.String, core.String]]
    })
  });
  DomImplementation[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('DOMImplementation')), dart.const(new _js_helper.Native("DOMImplementation"))];
  dart.registerExtension(dart.global.DOMImplementation, DomImplementation);
  dart.defineExtensionNames([
    'next'
  ]);
  class DomIterator extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    [dartx.next](value) {
      return this.next(value);
    }
  }
  dart.setSignature(DomIterator, {
    constructors: () => ({_: [DomIterator, []]}),
    methods: () => ({[dartx.next]: [core.Object, [], [core.Object]]})
  });
  DomIterator[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('Iterator')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("Iterator"))];
  dart.registerExtension(dart.global.Iterator, DomIterator);
  dart.defineExtensionNames([
    'multiply',
    'scale',
    'scale3d',
    'scaleNonUniform',
    'toFloat32Array',
    'toFloat64Array',
    'translate',
    'a',
    'b',
    'c',
    'd',
    'e',
    'f',
    'is2D',
    'isIdentity',
    'm11',
    'm12',
    'm13',
    'm14',
    'm21',
    'm22',
    'm23',
    'm24',
    'm31',
    'm32',
    'm33',
    'm34',
    'm41',
    'm42',
    'm43',
    'm44'
  ]);
  class DomMatrixReadOnly extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.a]() {
      return this.a;
    }
    get [dartx.b]() {
      return this.b;
    }
    get [dartx.c]() {
      return this.c;
    }
    get [dartx.d]() {
      return this.d;
    }
    get [dartx.e]() {
      return this.e;
    }
    get [dartx.f]() {
      return this.f;
    }
    get [dartx.is2D]() {
      return this.is2D;
    }
    get [dartx.isIdentity]() {
      return this.isIdentity;
    }
    get [dartx.m11]() {
      return this.m11;
    }
    get [dartx.m12]() {
      return this.m12;
    }
    get [dartx.m13]() {
      return this.m13;
    }
    get [dartx.m14]() {
      return this.m14;
    }
    get [dartx.m21]() {
      return this.m21;
    }
    get [dartx.m22]() {
      return this.m22;
    }
    get [dartx.m23]() {
      return this.m23;
    }
    get [dartx.m24]() {
      return this.m24;
    }
    get [dartx.m31]() {
      return this.m31;
    }
    get [dartx.m32]() {
      return this.m32;
    }
    get [dartx.m33]() {
      return this.m33;
    }
    get [dartx.m34]() {
      return this.m34;
    }
    get [dartx.m41]() {
      return this.m41;
    }
    get [dartx.m42]() {
      return this.m42;
    }
    get [dartx.m43]() {
      return this.m43;
    }
    get [dartx.m44]() {
      return this.m44;
    }
    [dartx.multiply](other) {
      return this.multiply(other);
    }
    [dartx.scale](scale, ox, oy) {
      return this.scale(scale, ox, oy);
    }
    [dartx.scale3d](scale, ox, oy, oz) {
      return this.scale3d(scale, ox, oy, oz);
    }
    [dartx.scaleNonUniform](sx, sy, sz, ox, oy, oz) {
      return this.scaleNonUniform(sx, sy, sz, ox, oy, oz);
    }
    [dartx.toFloat32Array]() {
      return this.toFloat32Array();
    }
    [dartx.toFloat64Array]() {
      return this.toFloat64Array();
    }
    [dartx.translate](tx, ty, tz) {
      return this.translate(tx, ty, tz);
    }
  }
  dart.setSignature(DomMatrixReadOnly, {
    constructors: () => ({_: [DomMatrixReadOnly, []]}),
    methods: () => ({
      [dartx.multiply]: [DomMatrix, [DomMatrix]],
      [dartx.scale]: [DomMatrix, [core.num], [core.num, core.num]],
      [dartx.scale3d]: [DomMatrix, [core.num], [core.num, core.num, core.num]],
      [dartx.scaleNonUniform]: [DomMatrix, [core.num], [core.num, core.num, core.num, core.num, core.num]],
      [dartx.toFloat32Array]: [typed_data.Float32List, []],
      [dartx.toFloat64Array]: [typed_data.Float64List, []],
      [dartx.translate]: [DomMatrix, [core.num, core.num], [core.num]]
    })
  });
  DomMatrixReadOnly[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('DOMMatrixReadOnly')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("DOMMatrixReadOnly"))];
  dart.registerExtension(dart.global.DOMMatrixReadOnly, DomMatrixReadOnly);
  dart.defineExtensionNames([
    'a',
    'a',
    'b',
    'b',
    'c',
    'c',
    'd',
    'd',
    'e',
    'e',
    'f',
    'f',
    'm11',
    'm11',
    'm12',
    'm12',
    'm13',
    'm13',
    'm14',
    'm14',
    'm21',
    'm21',
    'm22',
    'm22',
    'm23',
    'm23',
    'm24',
    'm24',
    'm31',
    'm31',
    'm32',
    'm32',
    'm33',
    'm33',
    'm34',
    'm34',
    'm41',
    'm41',
    'm42',
    'm42',
    'm43',
    'm43',
    'm44',
    'm44',
    'multiplySelf',
    'preMultiplySelf',
    'scale3dSelf',
    'scaleNonUniformSelf',
    'scaleSelf',
    'translateSelf'
  ]);
  class DomMatrix extends DomMatrixReadOnly {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new(other) {
      if (other === void 0) other = null;
      if (other == null) {
        return DomMatrix._create_1();
      }
      if (dart.is(other, DomMatrixReadOnly) || other == null) {
        return DomMatrix._create_2(other);
      }
      dart.throw(new core.ArgumentError("Incorrect number or type of arguments"));
    }
    static _create_1() {
      return dart.as(new DOMMatrix(), DomMatrix);
    }
    static _create_2(other) {
      return dart.as(new DOMMatrix(other), DomMatrix);
    }
    get [dartx.a]() {
      return this.a;
    }
    set [dartx.a](value) {
      this.a = value;
    }
    get [dartx.b]() {
      return this.b;
    }
    set [dartx.b](value) {
      this.b = value;
    }
    get [dartx.c]() {
      return this.c;
    }
    set [dartx.c](value) {
      this.c = value;
    }
    get [dartx.d]() {
      return this.d;
    }
    set [dartx.d](value) {
      this.d = value;
    }
    get [dartx.e]() {
      return this.e;
    }
    set [dartx.e](value) {
      this.e = value;
    }
    get [dartx.f]() {
      return this.f;
    }
    set [dartx.f](value) {
      this.f = value;
    }
    get [dartx.m11]() {
      return this.m11;
    }
    set [dartx.m11](value) {
      this.m11 = value;
    }
    get [dartx.m12]() {
      return this.m12;
    }
    set [dartx.m12](value) {
      this.m12 = value;
    }
    get [dartx.m13]() {
      return this.m13;
    }
    set [dartx.m13](value) {
      this.m13 = value;
    }
    get [dartx.m14]() {
      return this.m14;
    }
    set [dartx.m14](value) {
      this.m14 = value;
    }
    get [dartx.m21]() {
      return this.m21;
    }
    set [dartx.m21](value) {
      this.m21 = value;
    }
    get [dartx.m22]() {
      return this.m22;
    }
    set [dartx.m22](value) {
      this.m22 = value;
    }
    get [dartx.m23]() {
      return this.m23;
    }
    set [dartx.m23](value) {
      this.m23 = value;
    }
    get [dartx.m24]() {
      return this.m24;
    }
    set [dartx.m24](value) {
      this.m24 = value;
    }
    get [dartx.m31]() {
      return this.m31;
    }
    set [dartx.m31](value) {
      this.m31 = value;
    }
    get [dartx.m32]() {
      return this.m32;
    }
    set [dartx.m32](value) {
      this.m32 = value;
    }
    get [dartx.m33]() {
      return this.m33;
    }
    set [dartx.m33](value) {
      this.m33 = value;
    }
    get [dartx.m34]() {
      return this.m34;
    }
    set [dartx.m34](value) {
      this.m34 = value;
    }
    get [dartx.m41]() {
      return this.m41;
    }
    set [dartx.m41](value) {
      this.m41 = value;
    }
    get [dartx.m42]() {
      return this.m42;
    }
    set [dartx.m42](value) {
      this.m42 = value;
    }
    get [dartx.m43]() {
      return this.m43;
    }
    set [dartx.m43](value) {
      this.m43 = value;
    }
    get [dartx.m44]() {
      return this.m44;
    }
    set [dartx.m44](value) {
      this.m44 = value;
    }
    [dartx.multiplySelf](other) {
      return this.multiplySelf(other);
    }
    [dartx.preMultiplySelf](other) {
      return this.preMultiplySelf(other);
    }
    [dartx.scale3dSelf](scale, ox, oy, oz) {
      return this.scale3dSelf(scale, ox, oy, oz);
    }
    [dartx.scaleNonUniformSelf](sx, sy, sz, ox, oy, oz) {
      return this.scaleNonUniformSelf(sx, sy, sz, ox, oy, oz);
    }
    [dartx.scaleSelf](scale, ox, oy) {
      return this.scaleSelf(scale, ox, oy);
    }
    [dartx.translateSelf](tx, ty, tz) {
      return this.translateSelf(tx, ty, tz);
    }
  }
  dart.setSignature(DomMatrix, {
    constructors: () => ({
      _: [DomMatrix, []],
      new: [DomMatrix, [], [DomMatrixReadOnly]]
    }),
    methods: () => ({
      [dartx.multiplySelf]: [DomMatrix, [DomMatrix]],
      [dartx.preMultiplySelf]: [DomMatrix, [DomMatrix]],
      [dartx.scale3dSelf]: [DomMatrix, [core.num], [core.num, core.num, core.num]],
      [dartx.scaleNonUniformSelf]: [DomMatrix, [core.num], [core.num, core.num, core.num, core.num, core.num]],
      [dartx.scaleSelf]: [DomMatrix, [core.num], [core.num, core.num]],
      [dartx.translateSelf]: [DomMatrix, [core.num, core.num], [core.num]]
    }),
    statics: () => ({
      _create_1: [DomMatrix, []],
      _create_2: [DomMatrix, [dart.dynamic]]
    }),
    names: ['_create_1', '_create_2']
  });
  DomMatrix[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('DOMMatrix')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("DOMMatrix"))];
  dart.registerExtension(dart.global.DOMMatrix, DomMatrix);
  dart.defineExtensionNames([
    'parseFromString'
  ]);
  class DomParser extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return DomParser._create_1();
    }
    static _create_1() {
      return dart.as(new DOMParser(), DomParser);
    }
    [dartx.parseFromString](str, contentType) {
      return this.parseFromString(str, contentType);
    }
  }
  dart.setSignature(DomParser, {
    constructors: () => ({
      _: [DomParser, []],
      new: [DomParser, []]
    }),
    methods: () => ({[dartx.parseFromString]: [Document, [core.String, core.String]]}),
    statics: () => ({_create_1: [DomParser, []]}),
    names: ['_create_1']
  });
  DomParser[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('DOMParser')), dart.const(new _js_helper.Native("DOMParser"))];
  dart.registerExtension(dart.global.DOMParser, DomParser);
  dart.defineExtensionNames([
    'w',
    'x',
    'y',
    'z'
  ]);
  class DomPointReadOnly extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new(x, y, z, w) {
      return DomPointReadOnly._create_1(x, y, z, w);
    }
    static _create_1(x, y, z, w) {
      return dart.as(new DOMPointReadOnly(x, y, z, w), DomPointReadOnly);
    }
    get [dartx.w]() {
      return this.w;
    }
    get [dartx.x]() {
      return this.x;
    }
    get [dartx.y]() {
      return this.y;
    }
    get [dartx.z]() {
      return this.z;
    }
  }
  dart.setSignature(DomPointReadOnly, {
    constructors: () => ({
      _: [DomPointReadOnly, []],
      new: [DomPointReadOnly, [core.num, core.num, core.num, core.num]]
    }),
    statics: () => ({_create_1: [DomPointReadOnly, [dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic]]}),
    names: ['_create_1']
  });
  DomPointReadOnly[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('DOMPointReadOnly')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("DOMPointReadOnly"))];
  dart.registerExtension(dart.global.DOMPointReadOnly, DomPointReadOnly);
  dart.defineExtensionNames([
    'w',
    'w',
    'x',
    'x',
    'y',
    'y',
    'z',
    'z'
  ]);
  class DomPoint extends DomPointReadOnly {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new(point_OR_x, y, z, w) {
      if (point_OR_x === void 0) point_OR_x = null;
      if (y === void 0) y = null;
      if (z === void 0) z = null;
      if (w === void 0) w = null;
      if (point_OR_x == null && y == null && z == null && w == null) {
        return DomPoint._create_1();
      }
      if ((dart.is(point_OR_x, core.Map) || point_OR_x == null) && y == null && z == null && w == null) {
        let point_1 = html_common.convertDartToNative_Dictionary(dart.as(point_OR_x, core.Map));
        return DomPoint._create_2(point_1);
      }
      if ((typeof y == 'number' || y == null) && (typeof point_OR_x == 'number' || point_OR_x == null) && z == null && w == null) {
        return DomPoint._create_3(point_OR_x, y);
      }
      if ((typeof z == 'number' || z == null) && (typeof y == 'number' || y == null) && (typeof point_OR_x == 'number' || point_OR_x == null) && w == null) {
        return DomPoint._create_4(point_OR_x, y, z);
      }
      if ((typeof w == 'number' || w == null) && (typeof z == 'number' || z == null) && (typeof y == 'number' || y == null) && (typeof point_OR_x == 'number' || point_OR_x == null)) {
        return DomPoint._create_5(point_OR_x, y, z, w);
      }
      dart.throw(new core.ArgumentError("Incorrect number or type of arguments"));
    }
    static _create_1() {
      return dart.as(new DOMPoint(), DomPoint);
    }
    static _create_2(point_OR_x) {
      return dart.as(new DOMPoint(point_OR_x), DomPoint);
    }
    static _create_3(point_OR_x, y) {
      return dart.as(new DOMPoint(point_OR_x, y), DomPoint);
    }
    static _create_4(point_OR_x, y, z) {
      return dart.as(new DOMPoint(point_OR_x, y, z), DomPoint);
    }
    static _create_5(point_OR_x, y, z, w) {
      return dart.as(new DOMPoint(point_OR_x, y, z, w), DomPoint);
    }
    static get supported() {
      return !!window.DOMPoint || !!window.WebKitPoint;
    }
    get [dartx.w]() {
      return this.w;
    }
    set [dartx.w](value) {
      this.w = value;
    }
    get [dartx.x]() {
      return this.x;
    }
    set [dartx.x](value) {
      this.x = value;
    }
    get [dartx.y]() {
      return this.y;
    }
    set [dartx.y](value) {
      this.y = value;
    }
    get [dartx.z]() {
      return this.z;
    }
    set [dartx.z](value) {
      this.z = value;
    }
  }
  dart.setSignature(DomPoint, {
    constructors: () => ({
      _: [DomPoint, []],
      new: [DomPoint, [], [dart.dynamic, core.num, core.num, core.num]]
    }),
    statics: () => ({
      _create_1: [DomPoint, []],
      _create_2: [DomPoint, [dart.dynamic]],
      _create_3: [DomPoint, [dart.dynamic, dart.dynamic]],
      _create_4: [DomPoint, [dart.dynamic, dart.dynamic, dart.dynamic]],
      _create_5: [DomPoint, [dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic]]
    }),
    names: ['_create_1', '_create_2', '_create_3', '_create_4', '_create_5']
  });
  DomPoint[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('DOMPoint')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("DOMPoint"))];
  dart.registerExtension(dart.global.DOMPoint, DomPoint);
  dart.defineExtensionNames([
    'toString',
    '==',
    'hashCode',
    'intersection',
    'intersects',
    'boundingBox',
    'containsRectangle',
    'containsPoint',
    'topLeft',
    'topRight',
    'bottomRight',
    'bottomLeft',
    'bottom',
    'height',
    'left',
    'right',
    'top',
    'width',
    'x',
    'y'
  ]);
  class DomRectReadOnly extends _interceptors.Interceptor {
    toString() {
      return `Rectangle (${this[dartx.left]}, ${this[dartx.top]}) ${this[dartx.width]} x ${this[dartx.height]}`;
    }
    ['=='](other) {
      if (!dart.is(other, math.Rectangle)) return false;
      return dart.equals(this[dartx.left], dart.dload(other, 'left')) && dart.equals(this[dartx.top], dart.dload(other, 'top')) && dart.equals(this[dartx.width], dart.dload(other, 'width')) && dart.equals(this[dartx.height], dart.dload(other, 'height'));
    }
    get hashCode() {
      return _JenkinsSmiHash.hash4(dart.hashCode(this[dartx.left]), dart.hashCode(this[dartx.top]), dart.hashCode(this[dartx.width]), dart.hashCode(this[dartx.height]));
    }
    [dartx.intersection](other) {
      let x0 = math.max(this[dartx.left], dart.as(other[dartx.left], core.num));
      let x1 = math.min(dart.notNull(this[dartx.left]) + dart.notNull(this[dartx.width]), dart.as(dart.dsend(other[dartx.left], '+', other[dartx.width]), core.num));
      if (dart.notNull(x0) <= dart.notNull(x1)) {
        let y0 = math.max(this[dartx.top], dart.as(other[dartx.top], core.num));
        let y1 = math.min(dart.notNull(this[dartx.top]) + dart.notNull(this[dartx.height]), dart.as(dart.dsend(other[dartx.top], '+', other[dartx.height]), core.num));
        if (dart.notNull(y0) <= dart.notNull(y1)) {
          return new math.Rectangle(x0, y0, dart.notNull(x1) - dart.notNull(x0), dart.notNull(y1) - dart.notNull(y0));
        }
      }
      return null;
    }
    [dartx.intersects](other) {
      return dart.notNull(this[dartx.left]) <= dart.notNull(other[dartx.left]) + dart.notNull(other[dartx.width]) && dart.notNull(other[dartx.left]) <= dart.notNull(this[dartx.left]) + dart.notNull(this[dartx.width]) && dart.notNull(this[dartx.top]) <= dart.notNull(other[dartx.top]) + dart.notNull(other[dartx.height]) && dart.notNull(other[dartx.top]) <= dart.notNull(this[dartx.top]) + dart.notNull(this[dartx.height]);
    }
    [dartx.boundingBox](other) {
      let right = math.max(dart.notNull(this[dartx.left]) + dart.notNull(this[dartx.width]), dart.as(dart.dsend(other[dartx.left], '+', other[dartx.width]), core.num));
      let bottom = math.max(dart.notNull(this[dartx.top]) + dart.notNull(this[dartx.height]), dart.as(dart.dsend(other[dartx.top], '+', other[dartx.height]), core.num));
      let left = math.min(this[dartx.left], dart.as(other[dartx.left], core.num));
      let top = math.min(this[dartx.top], dart.as(other[dartx.top], core.num));
      return new math.Rectangle(left, top, dart.notNull(right) - dart.notNull(left), dart.notNull(bottom) - dart.notNull(top));
    }
    [dartx.containsRectangle](another) {
      return dart.notNull(this[dartx.left]) <= dart.notNull(another[dartx.left]) && dart.notNull(this[dartx.left]) + dart.notNull(this[dartx.width]) >= dart.notNull(another[dartx.left]) + dart.notNull(another[dartx.width]) && dart.notNull(this[dartx.top]) <= dart.notNull(another[dartx.top]) && dart.notNull(this[dartx.top]) + dart.notNull(this[dartx.height]) >= dart.notNull(another[dartx.top]) + dart.notNull(another[dartx.height]);
    }
    [dartx.containsPoint](another) {
      return dart.notNull(another.x) >= dart.notNull(this[dartx.left]) && dart.notNull(another.x) <= dart.notNull(this[dartx.left]) + dart.notNull(this[dartx.width]) && dart.notNull(another.y) >= dart.notNull(this[dartx.top]) && dart.notNull(another.y) <= dart.notNull(this[dartx.top]) + dart.notNull(this[dartx.height]);
    }
    get [dartx.topLeft]() {
      return new math.Point(this[dartx.left], this[dartx.top]);
    }
    get [dartx.topRight]() {
      return new math.Point(dart.notNull(this[dartx.left]) + dart.notNull(this[dartx.width]), this[dartx.top]);
    }
    get [dartx.bottomRight]() {
      return new math.Point(dart.notNull(this[dartx.left]) + dart.notNull(this[dartx.width]), dart.notNull(this[dartx.top]) + dart.notNull(this[dartx.height]));
    }
    get [dartx.bottomLeft]() {
      return new math.Point(this[dartx.left], dart.notNull(this[dartx.top]) + dart.notNull(this[dartx.height]));
    }
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new(x, y, width, height) {
      return DomRectReadOnly._create_1(x, y, width, height);
    }
    static _create_1(x, y, width, height) {
      return dart.as(new DOMRectReadOnly(x, y, width, height), DomRectReadOnly);
    }
    get [dartx.bottom]() {
      return this.bottom;
    }
    get [dartx.height]() {
      return this.height;
    }
    get [dartx.left]() {
      return this.left;
    }
    get [dartx.right]() {
      return this.right;
    }
    get [dartx.top]() {
      return this.top;
    }
    get [dartx.width]() {
      return this.width;
    }
    get [dartx.x]() {
      return this.x;
    }
    get [dartx.y]() {
      return this.y;
    }
  }
  DomRectReadOnly[dart.implements] = () => [math.Rectangle];
  dart.setSignature(DomRectReadOnly, {
    constructors: () => ({
      _: [DomRectReadOnly, []],
      new: [DomRectReadOnly, [core.num, core.num, core.num, core.num]]
    }),
    methods: () => ({
      [dartx.intersection]: [math.Rectangle, [math.Rectangle]],
      [dartx.intersects]: [core.bool, [math.Rectangle$(core.num)]],
      [dartx.boundingBox]: [math.Rectangle, [math.Rectangle]],
      [dartx.containsRectangle]: [core.bool, [math.Rectangle$(core.num)]],
      [dartx.containsPoint]: [core.bool, [math.Point$(core.num)]]
    }),
    statics: () => ({_create_1: [DomRectReadOnly, [dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic]]}),
    names: ['_create_1']
  });
  DomRectReadOnly[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('DOMRectReadOnly')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("DOMRectReadOnly"))];
  dart.registerExtension(dart.global.DOMRectReadOnly, DomRectReadOnly);
  dart.defineExtensionNames([
    'add',
    'contains',
    'item',
    'remove',
    'toggle',
    'length'
  ]);
  class DomTokenList extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.length]() {
      return this.length;
    }
    [dartx.add](tokens) {
      return this.add(tokens);
    }
    [dartx.contains](token) {
      return this.contains(token);
    }
    [dartx.item](index) {
      return this.item(index);
    }
    [dartx.remove](tokens) {
      return this.remove(tokens);
    }
    [dartx.toggle](token, force) {
      return this.toggle(token, force);
    }
  }
  dart.setSignature(DomTokenList, {
    constructors: () => ({_: [DomTokenList, []]}),
    methods: () => ({
      [dartx.add]: [dart.void, [core.String]],
      [dartx.contains]: [core.bool, [core.String]],
      [dartx.item]: [core.String, [core.int]],
      [dartx.remove]: [dart.void, [core.String]],
      [dartx.toggle]: [core.bool, [core.String], [core.bool]]
    })
  });
  DomTokenList[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('DOMTokenList')), dart.const(new _js_helper.Native("DOMTokenList"))];
  dart.registerExtension(dart.global.DOMTokenList, DomTokenList);
  dart.defineExtensionNames([
    'value'
  ]);
  class DomSettableTokenList extends DomTokenList {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.value]() {
      return this.value;
    }
    set [dartx.value](value) {
      this.value = value;
    }
    [__getter__](index) {
      return this.__getter__(index);
    }
  }
  dart.setSignature(DomSettableTokenList, {
    constructors: () => ({_: [DomSettableTokenList, []]}),
    methods: () => ({[__getter__]: [core.String, [core.int]]})
  });
  DomSettableTokenList[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('DOMSettableTokenList')), dart.const(new _js_helper.Native("DOMSettableTokenList"))];
  dart.registerExtension(dart.global.DOMSettableTokenList, DomSettableTokenList);
  const ImmutableListMixin$ = dart.generic(function(E) {
    dart.defineExtensionNames([
      'iterator',
      'add',
      'addAll',
      'sort',
      'shuffle',
      'insert',
      'insertAll',
      'setAll',
      'removeAt',
      'removeLast',
      'remove',
      'removeWhere',
      'retainWhere',
      'setRange',
      'removeRange',
      'replaceRange',
      'fillRange'
    ]);
    class ImmutableListMixin extends core.Object {
      get [dartx.iterator]() {
        return new (FixedSizeListIterator$(E))(this);
      }
      [Symbol.iterator]() {
        return new dart.JsIterator(this[dartx.iterator]);
      }
      [dartx.add](value) {
        dart.as(value, E);
        dart.throw(new core.UnsupportedError("Cannot add to immutable List."));
      }
      [dartx.addAll](iterable) {
        dart.as(iterable, core.Iterable$(E));
        dart.throw(new core.UnsupportedError("Cannot add to immutable List."));
      }
      [dartx.sort](compare) {
        if (compare === void 0) compare = null;
        dart.as(compare, dart.functionType(core.int, [E, E]));
        dart.throw(new core.UnsupportedError("Cannot sort immutable List."));
      }
      [dartx.shuffle](random) {
        if (random === void 0) random = null;
        dart.throw(new core.UnsupportedError("Cannot shuffle immutable List."));
      }
      [dartx.insert](index, element) {
        dart.as(element, E);
        dart.throw(new core.UnsupportedError("Cannot add to immutable List."));
      }
      [dartx.insertAll](index, iterable) {
        dart.as(iterable, core.Iterable$(E));
        dart.throw(new core.UnsupportedError("Cannot add to immutable List."));
      }
      [dartx.setAll](index, iterable) {
        dart.as(iterable, core.Iterable$(E));
        dart.throw(new core.UnsupportedError("Cannot modify an immutable List."));
      }
      [dartx.removeAt](pos) {
        dart.throw(new core.UnsupportedError("Cannot remove from immutable List."));
      }
      [dartx.removeLast]() {
        dart.throw(new core.UnsupportedError("Cannot remove from immutable List."));
      }
      [dartx.remove](object) {
        dart.throw(new core.UnsupportedError("Cannot remove from immutable List."));
      }
      [dartx.removeWhere](test) {
        dart.as(test, dart.functionType(core.bool, [E]));
        dart.throw(new core.UnsupportedError("Cannot remove from immutable List."));
      }
      [dartx.retainWhere](test) {
        dart.as(test, dart.functionType(core.bool, [E]));
        dart.throw(new core.UnsupportedError("Cannot remove from immutable List."));
      }
      [dartx.setRange](start, end, iterable, skipCount) {
        dart.as(iterable, core.Iterable$(E));
        if (skipCount === void 0) skipCount = 0;
        dart.throw(new core.UnsupportedError("Cannot setRange on immutable List."));
      }
      [dartx.removeRange](start, end) {
        dart.throw(new core.UnsupportedError("Cannot removeRange on immutable List."));
      }
      [dartx.replaceRange](start, end, iterable) {
        dart.as(iterable, core.Iterable$(E));
        dart.throw(new core.UnsupportedError("Cannot modify an immutable List."));
      }
      [dartx.fillRange](start, end, fillValue) {
        if (fillValue === void 0) fillValue = null;
        dart.as(fillValue, E);
        dart.throw(new core.UnsupportedError("Cannot modify an immutable List."));
      }
    }
    ImmutableListMixin[dart.implements] = () => [core.List$(E)];
    dart.setSignature(ImmutableListMixin, {
      methods: () => ({
        [dartx.add]: [dart.void, [E]],
        [dartx.addAll]: [dart.void, [core.Iterable$(E)]],
        [dartx.sort]: [dart.void, [], [dart.functionType(core.int, [E, E])]],
        [dartx.shuffle]: [dart.void, [], [math.Random]],
        [dartx.insert]: [dart.void, [core.int, E]],
        [dartx.insertAll]: [dart.void, [core.int, core.Iterable$(E)]],
        [dartx.setAll]: [dart.void, [core.int, core.Iterable$(E)]],
        [dartx.removeAt]: [E, [core.int]],
        [dartx.removeLast]: [E, []],
        [dartx.remove]: [core.bool, [core.Object]],
        [dartx.removeWhere]: [dart.void, [dart.functionType(core.bool, [E])]],
        [dartx.retainWhere]: [dart.void, [dart.functionType(core.bool, [E])]],
        [dartx.setRange]: [dart.void, [core.int, core.int, core.Iterable$(E)], [core.int]],
        [dartx.removeRange]: [dart.void, [core.int, core.int]],
        [dartx.replaceRange]: [dart.void, [core.int, core.int, core.Iterable$(E)]],
        [dartx.fillRange]: [dart.void, [core.int, core.int], [E]]
      })
    });
    return ImmutableListMixin;
  });
  let ImmutableListMixin = ImmutableListMixin$();
  dart.defineExtensionNames([
    'length',
    'get',
    'set',
    'length',
    'first',
    'last',
    'single',
    'elementAt',
    'contains',
    'item'
  ]);
  class DomStringList extends dart.mixin(_interceptors.Interceptor, collection.ListMixin$(core.String), ImmutableListMixin$(core.String)) {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.length]() {
      return this.length;
    }
    [dartx.get](index) {
      if (index >>> 0 !== index || index >= this[dartx.length]) dart.throw(core.RangeError.index(index, this));
      return this[index];
    }
    [dartx.set](index, value) {
      dart.throw(new core.UnsupportedError("Cannot assign element of immutable List."));
      return value;
    }
    set [dartx.length](value) {
      dart.throw(new core.UnsupportedError("Cannot resize immutable List."));
    }
    get [dartx.first]() {
      if (dart.notNull(this[dartx.length]) > 0) {
        return this[0];
      }
      dart.throw(new core.StateError("No elements"));
    }
    get [dartx.last]() {
      let len = this[dartx.length];
      if (dart.notNull(len) > 0) {
        return this[dart.notNull(len) - 1];
      }
      dart.throw(new core.StateError("No elements"));
    }
    get [dartx.single]() {
      let len = this[dartx.length];
      if (len == 1) {
        return this[0];
      }
      if (len == 0) dart.throw(new core.StateError("No elements"));
      dart.throw(new core.StateError("More than one element"));
    }
    [dartx.elementAt](index) {
      return this[dartx.get](index);
    }
    [dartx.contains](string) {
      return this.contains(string);
    }
    [dartx.item](index) {
      return this.item(index);
    }
  }
  DomStringList[dart.implements] = () => [_js_helper.JavaScriptIndexingBehavior, core.List$(core.String)];
  dart.setSignature(DomStringList, {
    constructors: () => ({_: [DomStringList, []]}),
    methods: () => ({
      [dartx.get]: [core.String, [core.int]],
      [dartx.set]: [dart.void, [core.int, core.String]],
      [dartx.elementAt]: [core.String, [core.int]],
      [dartx.contains]: [core.bool, [core.String]],
      [dartx.item]: [core.String, [core.int]]
    })
  });
  DomStringList[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('DOMStringList')), dart.const(new _js_helper.Native("DOMStringList"))];
  dart.registerExtension(dart.global.DOMStringList, DomStringList);
  class DomStringMap extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
  }
  dart.setSignature(DomStringMap, {
    constructors: () => ({_: [DomStringMap, []]})
  });
  DomStringMap[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('DOMStringMap'))];
  const _childElements = Symbol('_childElements');
  const _element = Symbol('_element');
  const _filter = Symbol('_filter');
  class _ChildrenElementList extends collection.ListBase$(Element) {
    _wrap(element) {
      this[_childElements] = dart.as(element[_children], HtmlCollection);
      this[_element] = element;
    }
    contains(element) {
      return this[_childElements][dartx.contains](element);
    }
    get isEmpty() {
      return this[_element][_firstElementChild] == null;
    }
    get length() {
      return this[_childElements][dartx.length];
    }
    get(index) {
      return dart.as(this[_childElements][dartx.get](index), Element);
    }
    set(index, value) {
      this[_element][_replaceChild](value, this[_childElements][dartx.get](index));
      return value;
    }
    set length(newLength) {
      dart.throw(new core.UnsupportedError('Cannot resize element lists'));
    }
    add(value) {
      this[_element][dartx.append](value);
      return value;
    }
    get iterator() {
      return this[dartx.toList]()[dartx.iterator];
    }
    addAll(iterable) {
      if (dart.is(iterable, _ChildNodeListLazy)) {
        iterable = core.List$(Element).from(iterable);
      }
      for (let element of iterable) {
        this[_element][dartx.append](element);
      }
    }
    sort(compare) {
      if (compare === void 0) compare = null;
      dart.throw(new core.UnsupportedError('Cannot sort element lists'));
    }
    shuffle(random) {
      if (random === void 0) random = null;
      dart.throw(new core.UnsupportedError('Cannot shuffle element lists'));
    }
    removeWhere(test) {
      this[_filter](test, false);
    }
    retainWhere(test) {
      this[_filter](test, true);
    }
    [_filter](test, retainMatching) {
      let removed = null;
      if (dart.notNull(retainMatching)) {
        removed = this[_element][dartx.children][dartx.where](dart.fn(e => !dart.notNull(dart.dcall(test, e)), core.bool, [Element]));
      } else {
        removed = this[_element][dartx.children][dartx.where](dart.as(test, __CastType0));
      }
      for (let e of dart.as(removed, core.Iterable))
        dart.dsend(e, 'remove');
    }
    setRange(start, end, iterable, skipCount) {
      if (skipCount === void 0) skipCount = 0;
      dart.throw(new core.UnimplementedError());
    }
    replaceRange(start, end, iterable) {
      dart.throw(new core.UnimplementedError());
    }
    fillRange(start, end, fillValue) {
      if (fillValue === void 0) fillValue = null;
      dart.throw(new core.UnimplementedError());
    }
    remove(object) {
      if (dart.is(object, Element)) {
        let element = object;
        if (core.identical(element[dartx.parentNode], this[_element])) {
          this[_element][_removeChild](element);
          return true;
        }
      }
      return false;
    }
    insert(index, element) {
      if (dart.notNull(index) < 0 || dart.notNull(index) > dart.notNull(this.length)) {
        dart.throw(new core.RangeError.range(index, 0, this.length));
      }
      if (index == this.length) {
        this[_element][dartx.append](element);
      } else {
        this[_element][dartx.insertBefore](element, this.get(index));
      }
    }
    setAll(index, iterable) {
      dart.throw(new core.UnimplementedError());
    }
    clear() {
      this[_element][_clearChildren]();
    }
    removeAt(index) {
      let result = this.get(index);
      if (result != null) {
        this[_element][_removeChild](result);
      }
      return result;
    }
    removeLast() {
      let result = this.last;
      if (result != null) {
        this[_element][_removeChild](result);
      }
      return result;
    }
    get first() {
      let result = this[_element][_firstElementChild];
      if (result == null) dart.throw(new core.StateError("No elements"));
      return result;
    }
    get last() {
      let result = this[_element][_lastElementChild];
      if (result == null) dart.throw(new core.StateError("No elements"));
      return result;
    }
    get single() {
      if (dart.notNull(this.length) > 1) dart.throw(new core.StateError("More than one element"));
      return this.first;
    }
    get rawList() {
      return this[_childElements];
    }
  }
  _ChildrenElementList[dart.implements] = () => [html_common.NodeListWrapper];
  dart.defineNamedConstructor(_ChildrenElementList, '_wrap');
  dart.setSignature(_ChildrenElementList, {
    constructors: () => ({_wrap: [_ChildrenElementList, [Element]]}),
    methods: () => ({
      get: [Element, [core.int]],
      set: [dart.void, [core.int, Element]],
      add: [Element, [Element]],
      addAll: [dart.void, [core.Iterable$(Element)]],
      sort: [dart.void, [], [dart.functionType(core.int, [Element, Element])]],
      removeWhere: [dart.void, [dart.functionType(core.bool, [Element])]],
      retainWhere: [dart.void, [dart.functionType(core.bool, [Element])]],
      [_filter]: [dart.void, [dart.functionType(core.bool, [dart.dynamic]), core.bool]],
      setRange: [dart.void, [core.int, core.int, core.Iterable$(Element)], [core.int]],
      replaceRange: [dart.void, [core.int, core.int, core.Iterable$(Element)]],
      fillRange: [dart.void, [core.int, core.int], [Element]],
      insert: [dart.void, [core.int, Element]],
      setAll: [dart.void, [core.int, core.Iterable$(Element)]],
      removeAt: [Element, [core.int]],
      removeLast: [Element, []]
    })
  });
  dart.defineExtensionMembers(_ChildrenElementList, [
    'contains',
    'get',
    'set',
    'add',
    'addAll',
    'sort',
    'shuffle',
    'removeWhere',
    'retainWhere',
    'setRange',
    'replaceRange',
    'fillRange',
    'remove',
    'insert',
    'setAll',
    'clear',
    'removeAt',
    'removeLast',
    'isEmpty',
    'length',
    'length',
    'iterator',
    'first',
    'last',
    'single'
  ]);
  const ElementList$ = dart.generic(function(T) {
    class ElementList extends collection.ListBase$(T) {}
    return ElementList;
  });
  let ElementList = ElementList$();
  const _nodeList = Symbol('_nodeList');
  const _forElementList = Symbol('_forElementList');
  class _FrozenElementList extends collection.ListBase {
    _wrap(nodeList) {
      this[_nodeList] = nodeList;
    }
    get length() {
      return this[_nodeList][dartx.length];
    }
    get(index) {
      return dart.as(this[_nodeList][dartx.get](index), Element);
    }
    set(index, value) {
      dart.throw(new core.UnsupportedError('Cannot modify list'));
      return value;
    }
    set length(newLength) {
      dart.throw(new core.UnsupportedError('Cannot modify list'));
    }
    sort(compare) {
      if (compare === void 0) compare = null;
      dart.throw(new core.UnsupportedError('Cannot sort list'));
    }
    shuffle(random) {
      if (random === void 0) random = null;
      dart.throw(new core.UnsupportedError('Cannot shuffle list'));
    }
    get first() {
      return dart.as(this[_nodeList][dartx.first], Element);
    }
    get last() {
      return dart.as(this[_nodeList][dartx.last], Element);
    }
    get single() {
      return dart.as(this[_nodeList][dartx.single], Element);
    }
    get classes() {
      return exports._MultiElementCssClassSet.new(dart.as(this, core.Iterable$(Element)));
    }
    get style() {
      return new _CssStyleDeclarationSet(dart.as(this, core.Iterable$(Element)));
    }
    set classes(value) {
      this[_nodeList][dartx.forEach](dart.fn(e => dart.dput(e, 'classes', value), core.Iterable$(core.String), [Node]));
    }
    get contentEdge() {
      return new _ContentCssListRect(this);
    }
    get paddingEdge() {
      return this.first[dartx.paddingEdge];
    }
    get borderEdge() {
      return this.first[dartx.borderEdge];
    }
    get marginEdge() {
      return this.first[dartx.marginEdge];
    }
    get rawList() {
      return this[_nodeList];
    }
    get onAbort() {
      return Element.abortEvent[_forElementList](this);
    }
    get onBeforeCopy() {
      return Element.beforeCopyEvent[_forElementList](this);
    }
    get onBeforeCut() {
      return Element.beforeCutEvent[_forElementList](this);
    }
    get onBeforePaste() {
      return Element.beforePasteEvent[_forElementList](this);
    }
    get onBlur() {
      return Element.blurEvent[_forElementList](this);
    }
    get onCanPlay() {
      return Element.canPlayEvent[_forElementList](this);
    }
    get onCanPlayThrough() {
      return Element.canPlayThroughEvent[_forElementList](this);
    }
    get onChange() {
      return Element.changeEvent[_forElementList](this);
    }
    get onClick() {
      return Element.clickEvent[_forElementList](this);
    }
    get onContextMenu() {
      return Element.contextMenuEvent[_forElementList](this);
    }
    get onCopy() {
      return Element.copyEvent[_forElementList](this);
    }
    get onCut() {
      return Element.cutEvent[_forElementList](this);
    }
    get onDoubleClick() {
      return Element.doubleClickEvent[_forElementList](this);
    }
    get onDrag() {
      return Element.dragEvent[_forElementList](this);
    }
    get onDragEnd() {
      return Element.dragEndEvent[_forElementList](this);
    }
    get onDragEnter() {
      return Element.dragEnterEvent[_forElementList](this);
    }
    get onDragLeave() {
      return Element.dragLeaveEvent[_forElementList](this);
    }
    get onDragOver() {
      return Element.dragOverEvent[_forElementList](this);
    }
    get onDragStart() {
      return Element.dragStartEvent[_forElementList](this);
    }
    get onDrop() {
      return Element.dropEvent[_forElementList](this);
    }
    get onDurationChange() {
      return Element.durationChangeEvent[_forElementList](this);
    }
    get onEmptied() {
      return Element.emptiedEvent[_forElementList](this);
    }
    get onEnded() {
      return Element.endedEvent[_forElementList](this);
    }
    get onError() {
      return Element.errorEvent[_forElementList](this);
    }
    get onFocus() {
      return Element.focusEvent[_forElementList](this);
    }
    get onInput() {
      return Element.inputEvent[_forElementList](this);
    }
    get onInvalid() {
      return Element.invalidEvent[_forElementList](this);
    }
    get onKeyDown() {
      return Element.keyDownEvent[_forElementList](this);
    }
    get onKeyPress() {
      return Element.keyPressEvent[_forElementList](this);
    }
    get onKeyUp() {
      return Element.keyUpEvent[_forElementList](this);
    }
    get onLoad() {
      return Element.loadEvent[_forElementList](this);
    }
    get onLoadedData() {
      return Element.loadedDataEvent[_forElementList](this);
    }
    get onLoadedMetadata() {
      return Element.loadedMetadataEvent[_forElementList](this);
    }
    get onMouseDown() {
      return Element.mouseDownEvent[_forElementList](this);
    }
    get onMouseEnter() {
      return Element.mouseEnterEvent[_forElementList](this);
    }
    get onMouseLeave() {
      return Element.mouseLeaveEvent[_forElementList](this);
    }
    get onMouseMove() {
      return Element.mouseMoveEvent[_forElementList](this);
    }
    get onMouseOut() {
      return Element.mouseOutEvent[_forElementList](this);
    }
    get onMouseOver() {
      return Element.mouseOverEvent[_forElementList](this);
    }
    get onMouseUp() {
      return Element.mouseUpEvent[_forElementList](this);
    }
    get onMouseWheel() {
      return Element.mouseWheelEvent[_forElementList](this);
    }
    get onPaste() {
      return Element.pasteEvent[_forElementList](this);
    }
    get onPause() {
      return Element.pauseEvent[_forElementList](this);
    }
    get onPlay() {
      return Element.playEvent[_forElementList](this);
    }
    get onPlaying() {
      return Element.playingEvent[_forElementList](this);
    }
    get onRateChange() {
      return Element.rateChangeEvent[_forElementList](this);
    }
    get onReset() {
      return Element.resetEvent[_forElementList](this);
    }
    get onResize() {
      return Element.resizeEvent[_forElementList](this);
    }
    get onScroll() {
      return Element.scrollEvent[_forElementList](this);
    }
    get onSearch() {
      return Element.searchEvent[_forElementList](this);
    }
    get onSeeked() {
      return Element.seekedEvent[_forElementList](this);
    }
    get onSeeking() {
      return Element.seekingEvent[_forElementList](this);
    }
    get onSelect() {
      return Element.selectEvent[_forElementList](this);
    }
    get onSelectStart() {
      return Element.selectStartEvent[_forElementList](this);
    }
    get onStalled() {
      return Element.stalledEvent[_forElementList](this);
    }
    get onSubmit() {
      return Element.submitEvent[_forElementList](this);
    }
    get onSuspend() {
      return Element.suspendEvent[_forElementList](this);
    }
    get onTimeUpdate() {
      return Element.timeUpdateEvent[_forElementList](this);
    }
    get onTouchCancel() {
      return Element.touchCancelEvent[_forElementList](this);
    }
    get onTouchEnd() {
      return Element.touchEndEvent[_forElementList](this);
    }
    get onTouchEnter() {
      return Element.touchEnterEvent[_forElementList](this);
    }
    get onTouchLeave() {
      return Element.touchLeaveEvent[_forElementList](this);
    }
    get onTouchMove() {
      return Element.touchMoveEvent[_forElementList](this);
    }
    get onTouchStart() {
      return Element.touchStartEvent[_forElementList](this);
    }
    get onTransitionEnd() {
      return Element.transitionEndEvent[_forElementList](this);
    }
    get onVolumeChange() {
      return Element.volumeChangeEvent[_forElementList](this);
    }
    get onWaiting() {
      return Element.waitingEvent[_forElementList](this);
    }
    get onFullscreenChange() {
      return Element.fullscreenChangeEvent[_forElementList](this);
    }
    get onFullscreenError() {
      return Element.fullscreenErrorEvent[_forElementList](this);
    }
  }
  _FrozenElementList[dart.implements] = () => [ElementList, html_common.NodeListWrapper];
  dart.defineNamedConstructor(_FrozenElementList, '_wrap');
  dart.setSignature(_FrozenElementList, {
    constructors: () => ({_wrap: [_FrozenElementList, [core.List$(Node)]]}),
    methods: () => ({
      get: [Element, [core.int]],
      set: [dart.void, [core.int, Element]],
      sort: [dart.void, [], [core.Comparator$(Element)]]
    })
  });
  dart.defineExtensionMembers(_FrozenElementList, [
    'get',
    'set',
    'sort',
    'shuffle',
    'length',
    'length',
    'first',
    'last',
    'single'
  ]);
  class _ElementFactoryProvider extends core.Object {
    static createElement_tag(tag, typeExtension) {
      if (typeExtension != null) {
        return document.createElement(tag, typeExtension);
      }
      return document.createElement(tag);
    }
  }
  dart.setSignature(_ElementFactoryProvider, {
    statics: () => ({createElement_tag: [dart.dynamic, [core.String, core.String]]}),
    names: ['createElement_tag']
  });
  const _value = Symbol('_value');
  class ScrollAlignment extends core.Object {
    _internal(value) {
      this[_value] = value;
    }
    toString() {
      return `ScrollAlignment.${this[_value]}`;
    }
  }
  dart.defineNamedConstructor(ScrollAlignment, '_internal');
  dart.setSignature(ScrollAlignment, {
    constructors: () => ({_internal: [ScrollAlignment, [dart.dynamic]]})
  });
  dart.defineLazyProperties(ScrollAlignment, {
    get TOP() {
      return dart.const(new ScrollAlignment._internal('TOP'));
    },
    get CENTER() {
      return dart.const(new ScrollAlignment._internal('CENTER'));
    },
    get BOTTOM() {
      return dart.const(new ScrollAlignment._internal('BOTTOM'));
    }
  });
  dart.defineExtensionNames([
    'height',
    'integrity',
    'name',
    'src',
    'type',
    'width'
  ]);
  class EmbedElement extends HtmlElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return dart.as(exports.document[dartx.createElement]("embed"), EmbedElement);
    }
    created() {
      this[dartx.height] = null;
      this[dartx.integrity] = null;
      this[dartx.name] = null;
      this[dartx.src] = null;
      this[dartx.type] = null;
      this[dartx.width] = null;
      super.created();
    }
    static get supported() {
      return Element.isTagSupported('embed');
    }
    get [dartx.height]() {
      return this.height;
    }
    set [dartx.height](value) {
      this.height = value;
    }
    get [dartx.integrity]() {
      return this.integrity;
    }
    set [dartx.integrity](value) {
      this.integrity = value;
    }
    get [dartx.name]() {
      return this.name;
    }
    set [dartx.name](value) {
      this.name = value;
    }
    get [dartx.src]() {
      return this.src;
    }
    set [dartx.src](value) {
      this.src = value;
    }
    get [dartx.type]() {
      return this.type;
    }
    set [dartx.type](value) {
      this.type = value;
    }
    get [dartx.width]() {
      return this.width;
    }
    set [dartx.width](value) {
      this.width = value;
    }
    [__getter__](index_OR_name) {
      return this.__getter__(index_OR_name);
    }
    [__setter__](index_OR_name, value) {
      return this.__setter__(index_OR_name, value);
    }
  }
  dart.defineNamedConstructor(EmbedElement, 'created');
  dart.setSignature(EmbedElement, {
    constructors: () => ({
      _: [EmbedElement, []],
      new: [EmbedElement, []],
      created: [EmbedElement, []]
    }),
    methods: () => ({
      [__getter__]: [core.bool, [dart.dynamic]],
      [__setter__]: [dart.void, [dart.dynamic, Node]]
    })
  });
  EmbedElement[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('HTMLEmbedElement')), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.CHROME)), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.IE)), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.SAFARI)), dart.const(new _metadata.Unstable()), dart.const(new _js_helper.Native("HTMLEmbedElement"))];
  dart.registerExtension(dart.global.HTMLEmbedElement, EmbedElement);
  const _EntriesCallback = dart.typedef('_EntriesCallback', () => dart.functionType(dart.void, [core.List$(Entry)]));
  const _EntryCallback = dart.typedef('_EntryCallback', () => dart.functionType(dart.void, [Entry]));
  const _ErrorCallback = dart.typedef('_ErrorCallback', () => dart.functionType(dart.void, [FileError]));
  dart.defineExtensionNames([
    'colno',
    'error',
    'filename',
    'lineno',
    'message'
  ]);
  class ErrorEvent extends Event {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.colno]() {
      return this.colno;
    }
    get [dartx.error]() {
      return this.error;
    }
    get [dartx.filename]() {
      return this.filename;
    }
    get [dartx.lineno]() {
      return this.lineno;
    }
    get [dartx.message]() {
      return this.message;
    }
  }
  dart.setSignature(ErrorEvent, {
    constructors: () => ({_: [ErrorEvent, []]})
  });
  ErrorEvent[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('ErrorEvent')), dart.const(new _metadata.Unstable()), dart.const(new _js_helper.Native("ErrorEvent"))];
  dart.registerExtension(dart.global.ErrorEvent, ErrorEvent);
  dart.defineExtensionNames([
    'close',
    'onError',
    'onMessage',
    'onOpen',
    'readyState',
    'url',
    'withCredentials'
  ]);
  class EventSource extends EventTarget {
    static new(url, opts) {
      let withCredentials = opts && 'withCredentials' in opts ? opts.withCredentials : false;
      let parsedOptions = dart.map({withCredentials: withCredentials});
      return EventSource._factoryEventSource(url, parsedOptions);
    }
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static _factoryEventSource(url, eventSourceInit) {
      if (eventSourceInit === void 0) eventSourceInit = null;
      if (eventSourceInit != null) {
        let eventSourceInit_1 = html_common.convertDartToNative_Dictionary(eventSourceInit);
        return EventSource._create_1(url, eventSourceInit_1);
      }
      return EventSource._create_2(url);
    }
    static _create_1(url, eventSourceInit) {
      return dart.as(new EventSource(url, eventSourceInit), EventSource);
    }
    static _create_2(url) {
      return dart.as(new EventSource(url), EventSource);
    }
    get [dartx.readyState]() {
      return this.readyState;
    }
    get [dartx.url]() {
      return this.url;
    }
    get [dartx.withCredentials]() {
      return this.withCredentials;
    }
    [dartx.close]() {
      return this.close();
    }
    get [dartx.onError]() {
      return EventSource.errorEvent.forTarget(this);
    }
    get [dartx.onMessage]() {
      return EventSource.messageEvent.forTarget(this);
    }
    get [dartx.onOpen]() {
      return EventSource.openEvent.forTarget(this);
    }
  }
  dart.setSignature(EventSource, {
    constructors: () => ({
      new: [EventSource, [core.String], {withCredentials: dart.dynamic}],
      _: [EventSource, []]
    }),
    methods: () => ({[dartx.close]: [dart.void, []]}),
    statics: () => ({
      _factoryEventSource: [EventSource, [core.String], [core.Map]],
      _create_1: [EventSource, [dart.dynamic, dart.dynamic]],
      _create_2: [EventSource, [dart.dynamic]]
    }),
    names: ['_factoryEventSource', '_create_1', '_create_2']
  });
  EventSource[dart.metadata] = () => [dart.const(new _metadata.DomName('EventSource')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("EventSource"))];
  EventSource.CLOSED = 2;
  EventSource.CONNECTING = 0;
  EventSource.OPEN = 1;
  dart.defineLazyProperties(EventSource, {
    get errorEvent() {
      return dart.const(new (EventStreamProvider$(Event))('error'));
    },
    get messageEvent() {
      return dart.const(new (EventStreamProvider$(MessageEvent))('message'));
    },
    get openEvent() {
      return dart.const(new (EventStreamProvider$(Event))('open'));
    }
  });
  dart.registerExtension(dart.global.EventSource, EventSource);
  const _ptr = Symbol('_ptr');
  class Events extends core.Object {
    Events(ptr) {
      this[_ptr] = ptr;
    }
    get(type) {
      return new _EventStream(this[_ptr], type, false);
    }
  }
  dart.virtualField(Events, _ptr);
  dart.setSignature(Events, {
    constructors: () => ({Events: [Events, [EventTarget]]}),
    methods: () => ({get: [async.Stream, [core.String]]})
  });
  class ElementEvents extends Events {
    ElementEvents(ptr) {
      this[_ptr] = ptr;
      super.Events(ptr);
    }
    get(type) {
      if (dart.notNull(ElementEvents.webkitEvents[dartx.keys][dartx.contains](type[dartx.toLowerCase]()))) {
        if (dart.notNull(html_common.Device.isWebKit)) {
          return new _ElementEventStreamImpl(this[_ptr], ElementEvents.webkitEvents[dartx.get](type[dartx.toLowerCase]()), false);
        }
      }
      return new _ElementEventStreamImpl(this[_ptr], type, false);
    }
  }
  dart.virtualField(ElementEvents, _ptr);
  dart.setSignature(ElementEvents, {
    constructors: () => ({ElementEvents: [ElementEvents, [Element]]})
  });
  dart.defineLazyProperties(ElementEvents, {
    get webkitEvents() {
      return dart.map({animationend: 'webkitAnimationEnd', animationiteration: 'webkitAnimationIteration', animationstart: 'webkitAnimationStart', fullscreenchange: 'webkitfullscreenchange', fullscreenerror: 'webkitfullscreenerror', keyadded: 'webkitkeyadded', keyerror: 'webkitkeyerror', keymessage: 'webkitkeymessage', needkey: 'webkitneedkey', pointerlockchange: 'webkitpointerlockchange', pointerlockerror: 'webkitpointerlockerror', resourcetimingbufferfull: 'webkitresourcetimingbufferfull', transitionend: 'webkitTransitionEnd', speechchange: 'webkitSpeechChange'});
    }
  });
  dart.defineExtensionNames([
    'waitUntil'
  ]);
  class ExtendableEvent extends Event {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    [dartx.waitUntil](value) {
      return this.waitUntil(value);
    }
  }
  dart.setSignature(ExtendableEvent, {
    constructors: () => ({_: [ExtendableEvent, []]}),
    methods: () => ({[dartx.waitUntil]: [dart.void, [core.Object]]})
  });
  ExtendableEvent[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('ExtendableEvent')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("ExtendableEvent"))];
  dart.registerExtension(dart.global.ExtendableEvent, ExtendableEvent);
  dart.defineExtensionNames([
    'federation'
  ]);
  class FederatedCredential extends Credential {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new(id, name, avatarURL, federation) {
      return FederatedCredential._create_1(id, name, avatarURL, federation);
    }
    static _create_1(id, name, avatarURL, federation) {
      return dart.as(new FederatedCredential(id, name, avatarURL, federation), FederatedCredential);
    }
    get [dartx.federation]() {
      return this.federation;
    }
  }
  dart.setSignature(FederatedCredential, {
    constructors: () => ({
      _: [FederatedCredential, []],
      new: [FederatedCredential, [core.String, core.String, core.String, core.String]]
    }),
    statics: () => ({_create_1: [FederatedCredential, [dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic]]}),
    names: ['_create_1']
  });
  FederatedCredential[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('FederatedCredential')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("FederatedCredential"))];
  dart.registerExtension(dart.global.FederatedCredential, FederatedCredential);
  dart.defineExtensionNames([
    'respondWith',
    'isReload',
    'request'
  ]);
  class FetchEvent extends Event {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.isReload]() {
      return this.isReload;
    }
    get [dartx.request]() {
      return this.request;
    }
    [dartx.respondWith](value) {
      return this.respondWith(value);
    }
  }
  dart.setSignature(FetchEvent, {
    constructors: () => ({_: [FetchEvent, []]}),
    methods: () => ({[dartx.respondWith]: [dart.void, [core.Object]]})
  });
  FetchEvent[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('FetchEvent')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("FetchEvent"))];
  dart.registerExtension(dart.global.FetchEvent, FetchEvent);
  dart.defineExtensionNames([
    'checkValidity',
    'setCustomValidity',
    'disabled',
    'elements',
    'form',
    'name',
    'type',
    'validationMessage',
    'validity',
    'willValidate'
  ]);
  class FieldSetElement extends HtmlElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return dart.as(exports.document[dartx.createElement]("fieldset"), FieldSetElement);
    }
    created() {
      this[dartx.disabled] = null;
      this[dartx.elements] = null;
      this[dartx.form] = null;
      this[dartx.name] = null;
      this[dartx.type] = null;
      this[dartx.validationMessage] = null;
      this[dartx.validity] = null;
      this[dartx.willValidate] = null;
      super.created();
    }
    get [dartx.disabled]() {
      return this.disabled;
    }
    set [dartx.disabled](value) {
      this.disabled = value;
    }
    get [dartx.elements]() {
      return this.elements;
    }
    get [dartx.form]() {
      return this.form;
    }
    get [dartx.name]() {
      return this.name;
    }
    set [dartx.name](value) {
      this.name = value;
    }
    get [dartx.type]() {
      return this.type;
    }
    get [dartx.validationMessage]() {
      return this.validationMessage;
    }
    get [dartx.validity]() {
      return this.validity;
    }
    get [dartx.willValidate]() {
      return this.willValidate;
    }
    [dartx.checkValidity]() {
      return this.checkValidity();
    }
    [dartx.setCustomValidity](error) {
      return this.setCustomValidity(error);
    }
  }
  dart.defineNamedConstructor(FieldSetElement, 'created');
  dart.setSignature(FieldSetElement, {
    constructors: () => ({
      _: [FieldSetElement, []],
      new: [FieldSetElement, []],
      created: [FieldSetElement, []]
    }),
    methods: () => ({
      [dartx.checkValidity]: [core.bool, []],
      [dartx.setCustomValidity]: [dart.void, [core.String]]
    })
  });
  FieldSetElement[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('HTMLFieldSetElement')), dart.const(new _metadata.Unstable()), dart.const(new _js_helper.Native("HTMLFieldSetElement"))];
  dart.registerExtension(dart.global.HTMLFieldSetElement, FieldSetElement);
  const _get_lastModifiedDate = Symbol('_get_lastModifiedDate');
  dart.defineExtensionNames([
    'lastModifiedDate',
    'lastModified',
    'name',
    'relativePath'
  ]);
  class File extends Blob {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.lastModified]() {
      return this.lastModified;
    }
    get [dartx.lastModifiedDate]() {
      return html_common.convertNativeToDart_DateTime(this[_get_lastModifiedDate]);
    }
    get [_get_lastModifiedDate]() {
      return this.lastModifiedDate;
    }
    get [dartx.name]() {
      return this.name;
    }
    get [dartx.relativePath]() {
      return this.webkitRelativePath;
    }
  }
  dart.setSignature(File, {
    constructors: () => ({_: [File, []]})
  });
  File[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('File')), dart.const(new _js_helper.Native("File"))];
  dart.registerExtension(dart.global.File, File);
  const _FileCallback = dart.typedef('_FileCallback', () => dart.functionType(dart.void, [File]));
  const _createWriter = Symbol('_createWriter');
  const _file = Symbol('_file');
  dart.defineExtensionNames([
    'createWriter',
    'file'
  ]);
  class FileEntry extends Entry {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    [_createWriter](successCallback, errorCallback) {
      return this.createWriter(successCallback, errorCallback);
    }
    [dartx.createWriter]() {
      let completer = async.Completer$(FileWriter).new();
      this[_createWriter](dart.fn(value => {
        completer.complete(value);
      }, dart.void, [FileWriter]), dart.fn(error => {
        completer.completeError(error);
      }, dart.void, [FileError]));
      return completer.future;
    }
    [_file](successCallback, errorCallback) {
      return this.file(successCallback, errorCallback);
    }
    [dartx.file]() {
      let completer = async.Completer$(File).new();
      this[_file](dart.fn(value => {
        completer.complete(value);
      }, dart.void, [File]), dart.fn(error => {
        completer.completeError(error);
      }, dart.void, [FileError]));
      return completer.future;
    }
  }
  dart.setSignature(FileEntry, {
    constructors: () => ({_: [FileEntry, []]}),
    methods: () => ({
      [_createWriter]: [dart.void, [_FileWriterCallback], [_ErrorCallback]],
      [dartx.createWriter]: [async.Future$(FileWriter), []],
      [_file]: [dart.void, [_FileCallback], [_ErrorCallback]],
      [dartx.file]: [async.Future$(File), []]
    })
  });
  FileEntry[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('FileEntry')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("FileEntry"))];
  dart.registerExtension(dart.global.FileEntry, FileEntry);
  dart.defineExtensionNames([
    'code'
  ]);
  class FileError extends DomError {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.code]() {
      return this.code;
    }
  }
  dart.setSignature(FileError, {
    constructors: () => ({_: [FileError, []]})
  });
  FileError[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('FileError')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("FileError"))];
  FileError.ABORT_ERR = 3;
  FileError.ENCODING_ERR = 5;
  FileError.INVALID_MODIFICATION_ERR = 9;
  FileError.INVALID_STATE_ERR = 7;
  FileError.NOT_FOUND_ERR = 1;
  FileError.NOT_READABLE_ERR = 4;
  FileError.NO_MODIFICATION_ALLOWED_ERR = 6;
  FileError.PATH_EXISTS_ERR = 12;
  FileError.QUOTA_EXCEEDED_ERR = 10;
  FileError.SECURITY_ERR = 2;
  FileError.SYNTAX_ERR = 8;
  FileError.TYPE_MISMATCH_ERR = 11;
  dart.registerExtension(dart.global.FileError, FileError);
  dart.defineExtensionNames([
    'length',
    'get',
    'set',
    'length',
    'first',
    'last',
    'single',
    'elementAt',
    'item'
  ]);
  class FileList extends dart.mixin(_interceptors.Interceptor, collection.ListMixin$(File), ImmutableListMixin$(File)) {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.length]() {
      return this.length;
    }
    [dartx.get](index) {
      if (index >>> 0 !== index || index >= this[dartx.length]) dart.throw(core.RangeError.index(index, this));
      return dart.as(this[index], File);
    }
    [dartx.set](index, value) {
      dart.throw(new core.UnsupportedError("Cannot assign element of immutable List."));
      return value;
    }
    set [dartx.length](value) {
      dart.throw(new core.UnsupportedError("Cannot resize immutable List."));
    }
    get [dartx.first]() {
      if (dart.notNull(this[dartx.length]) > 0) {
        return dart.as(this[0], File);
      }
      dart.throw(new core.StateError("No elements"));
    }
    get [dartx.last]() {
      let len = this[dartx.length];
      if (dart.notNull(len) > 0) {
        return dart.as(this[dart.notNull(len) - 1], File);
      }
      dart.throw(new core.StateError("No elements"));
    }
    get [dartx.single]() {
      let len = this[dartx.length];
      if (len == 1) {
        return dart.as(this[0], File);
      }
      if (len == 0) dart.throw(new core.StateError("No elements"));
      dart.throw(new core.StateError("More than one element"));
    }
    [dartx.elementAt](index) {
      return this[dartx.get](index);
    }
    [dartx.item](index) {
      return this.item(index);
    }
  }
  FileList[dart.implements] = () => [_js_helper.JavaScriptIndexingBehavior, core.List$(File)];
  dart.setSignature(FileList, {
    constructors: () => ({_: [FileList, []]}),
    methods: () => ({
      [dartx.get]: [File, [core.int]],
      [dartx.set]: [dart.void, [core.int, File]],
      [dartx.elementAt]: [File, [core.int]],
      [dartx.item]: [File, [core.int]]
    })
  });
  FileList[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('FileList')), dart.const(new _js_helper.Native("FileList"))];
  dart.registerExtension(dart.global.FileList, FileList);
  dart.defineExtensionNames([
    'result',
    'abort',
    'readAsArrayBuffer',
    'readAsDataUrl',
    'readAsText',
    'onAbort',
    'onError',
    'onLoad',
    'onLoadEnd',
    'onLoadStart',
    'onProgress',
    'error',
    'readyState'
  ]);
  class FileReader extends EventTarget {
    get [dartx.result]() {
      let res = this.result;
      if (dart.is(res, typed_data.ByteBuffer)) {
        return typed_data.Uint8List.view(res);
      }
      return res;
    }
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return FileReader._create_1();
    }
    static _create_1() {
      return dart.as(new FileReader(), FileReader);
    }
    get [dartx.error]() {
      return this.error;
    }
    get [dartx.readyState]() {
      return this.readyState;
    }
    [dartx.abort]() {
      return this.abort();
    }
    [dartx.readAsArrayBuffer](blob) {
      return this.readAsArrayBuffer(blob);
    }
    [dartx.readAsDataUrl](blob) {
      return this.readAsDataURL(blob);
    }
    [dartx.readAsText](blob, encoding) {
      return this.readAsText(blob, encoding);
    }
    get [dartx.onAbort]() {
      return FileReader.abortEvent.forTarget(this);
    }
    get [dartx.onError]() {
      return FileReader.errorEvent.forTarget(this);
    }
    get [dartx.onLoad]() {
      return FileReader.loadEvent.forTarget(this);
    }
    get [dartx.onLoadEnd]() {
      return FileReader.loadEndEvent.forTarget(this);
    }
    get [dartx.onLoadStart]() {
      return FileReader.loadStartEvent.forTarget(this);
    }
    get [dartx.onProgress]() {
      return FileReader.progressEvent.forTarget(this);
    }
  }
  dart.setSignature(FileReader, {
    constructors: () => ({
      _: [FileReader, []],
      new: [FileReader, []]
    }),
    methods: () => ({
      [dartx.abort]: [dart.void, []],
      [dartx.readAsArrayBuffer]: [dart.void, [Blob]],
      [dartx.readAsDataUrl]: [dart.void, [Blob]],
      [dartx.readAsText]: [dart.void, [Blob], [core.String]]
    }),
    statics: () => ({_create_1: [FileReader, []]}),
    names: ['_create_1']
  });
  FileReader[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('FileReader')), dart.const(new _js_helper.Native("FileReader"))];
  FileReader.DONE = 2;
  FileReader.EMPTY = 0;
  FileReader.LOADING = 1;
  dart.defineLazyProperties(FileReader, {
    get abortEvent() {
      return dart.const(new (EventStreamProvider$(ProgressEvent))('abort'));
    },
    get errorEvent() {
      return dart.const(new (EventStreamProvider$(Event))('error'));
    },
    get loadEvent() {
      return dart.const(new (EventStreamProvider$(ProgressEvent))('load'));
    },
    get loadEndEvent() {
      return dart.const(new (EventStreamProvider$(ProgressEvent))('loadend'));
    },
    get loadStartEvent() {
      return dart.const(new (EventStreamProvider$(ProgressEvent))('loadstart'));
    },
    get progressEvent() {
      return dart.const(new (EventStreamProvider$(ProgressEvent))('progress'));
    }
  });
  dart.registerExtension(dart.global.FileReader, FileReader);
  dart.defineExtensionNames([
    'type'
  ]);
  class FileStream extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.type]() {
      return this.type;
    }
  }
  dart.setSignature(FileStream, {
    constructors: () => ({_: [FileStream, []]})
  });
  FileStream[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('Stream')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("Stream"))];
  dart.registerExtension(dart.global.Stream, FileStream);
  dart.defineExtensionNames([
    'name',
    'root'
  ]);
  class FileSystem extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static get supported() {
      return !!window.webkitRequestFileSystem;
    }
    get [dartx.name]() {
      return this.name;
    }
    get [dartx.root]() {
      return this.root;
    }
  }
  dart.setSignature(FileSystem, {
    constructors: () => ({_: [FileSystem, []]})
  });
  FileSystem[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('DOMFileSystem')), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.CHROME)), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("DOMFileSystem"))];
  dart.registerExtension(dart.global.DOMFileSystem, FileSystem);
  const _FileSystemCallback = dart.typedef('_FileSystemCallback', () => dart.functionType(dart.void, [FileSystem]));
  dart.defineExtensionNames([
    'abort',
    'seek',
    'truncate',
    'write',
    'onAbort',
    'onError',
    'onProgress',
    'onWrite',
    'onWriteEnd',
    'onWriteStart',
    'error',
    'length',
    'position',
    'readyState'
  ]);
  class FileWriter extends EventTarget {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.error]() {
      return this.error;
    }
    get [dartx.length]() {
      return this.length;
    }
    get [dartx.position]() {
      return this.position;
    }
    get [dartx.readyState]() {
      return this.readyState;
    }
    [dartx.abort]() {
      return this.abort();
    }
    [dartx.seek](position) {
      return this.seek(position);
    }
    [dartx.truncate](size) {
      return this.truncate(size);
    }
    [dartx.write](data) {
      return this.write(data);
    }
    get [dartx.onAbort]() {
      return FileWriter.abortEvent.forTarget(this);
    }
    get [dartx.onError]() {
      return FileWriter.errorEvent.forTarget(this);
    }
    get [dartx.onProgress]() {
      return FileWriter.progressEvent.forTarget(this);
    }
    get [dartx.onWrite]() {
      return FileWriter.writeEvent.forTarget(this);
    }
    get [dartx.onWriteEnd]() {
      return FileWriter.writeEndEvent.forTarget(this);
    }
    get [dartx.onWriteStart]() {
      return FileWriter.writeStartEvent.forTarget(this);
    }
  }
  dart.setSignature(FileWriter, {
    constructors: () => ({_: [FileWriter, []]}),
    methods: () => ({
      [dartx.abort]: [dart.void, []],
      [dartx.seek]: [dart.void, [core.int]],
      [dartx.truncate]: [dart.void, [core.int]],
      [dartx.write]: [dart.void, [Blob]]
    })
  });
  FileWriter[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('FileWriter')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("FileWriter"))];
  FileWriter.DONE = 2;
  FileWriter.INIT = 0;
  FileWriter.WRITING = 1;
  dart.defineLazyProperties(FileWriter, {
    get abortEvent() {
      return dart.const(new (EventStreamProvider$(ProgressEvent))('abort'));
    },
    get errorEvent() {
      return dart.const(new (EventStreamProvider$(Event))('error'));
    },
    get progressEvent() {
      return dart.const(new (EventStreamProvider$(ProgressEvent))('progress'));
    },
    get writeEvent() {
      return dart.const(new (EventStreamProvider$(ProgressEvent))('write'));
    },
    get writeEndEvent() {
      return dart.const(new (EventStreamProvider$(ProgressEvent))('writeend'));
    },
    get writeStartEvent() {
      return dart.const(new (EventStreamProvider$(ProgressEvent))('writestart'));
    }
  });
  dart.registerExtension(dart.global.FileWriter, FileWriter);
  const _FileWriterCallback = dart.typedef('_FileWriterCallback', () => dart.functionType(dart.void, [FileWriter]));
  const _get_relatedTarget = Symbol('_get_relatedTarget');
  dart.defineExtensionNames([
    'relatedTarget'
  ]);
  class FocusEvent extends UIEvent {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.relatedTarget]() {
      return _convertNativeToDart_EventTarget(this[_get_relatedTarget]);
    }
    get [_get_relatedTarget]() {
      return this.relatedTarget;
    }
  }
  dart.setSignature(FocusEvent, {
    constructors: () => ({_: [FocusEvent, []]})
  });
  FocusEvent[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('FocusEvent')), dart.const(new _js_helper.Native("FocusEvent"))];
  dart.registerExtension(dart.global.FocusEvent, FocusEvent);
  dart.defineExtensionNames([
    'load',
    'family',
    'featureSettings',
    'loaded',
    'status',
    'stretch',
    'style',
    'unicodeRange',
    'variant',
    'weight'
  ]);
  class FontFace extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new(family, source, descriptors) {
      if (descriptors === void 0) descriptors = null;
      if ((typeof source == 'string' || source == null) && (typeof family == 'string' || family == null) && descriptors == null) {
        return FontFace._create_1(family, source);
      }
      if ((dart.is(descriptors, core.Map) || descriptors == null) && (typeof source == 'string' || source == null) && (typeof family == 'string' || family == null)) {
        let descriptors_1 = html_common.convertDartToNative_Dictionary(descriptors);
        return FontFace._create_2(family, source, descriptors_1);
      }
      if ((dart.is(source, typed_data.TypedData) || source == null) && (typeof family == 'string' || family == null) && descriptors == null) {
        return FontFace._create_3(family, source);
      }
      if ((dart.is(descriptors, core.Map) || descriptors == null) && (dart.is(source, typed_data.TypedData) || source == null) && (typeof family == 'string' || family == null)) {
        let descriptors_1 = html_common.convertDartToNative_Dictionary(descriptors);
        return FontFace._create_4(family, source, descriptors_1);
      }
      if ((dart.is(source, typed_data.ByteBuffer) || source == null) && (typeof family == 'string' || family == null) && descriptors == null) {
        return FontFace._create_5(family, source);
      }
      if ((dart.is(descriptors, core.Map) || descriptors == null) && (dart.is(source, typed_data.ByteBuffer) || source == null) && (typeof family == 'string' || family == null)) {
        let descriptors_1 = html_common.convertDartToNative_Dictionary(descriptors);
        return FontFace._create_6(family, source, descriptors_1);
      }
      dart.throw(new core.ArgumentError("Incorrect number or type of arguments"));
    }
    static _create_1(family, source) {
      return dart.as(new FontFace(family, source), FontFace);
    }
    static _create_2(family, source, descriptors) {
      return dart.as(new FontFace(family, source, descriptors), FontFace);
    }
    static _create_3(family, source) {
      return dart.as(new FontFace(family, source), FontFace);
    }
    static _create_4(family, source, descriptors) {
      return dart.as(new FontFace(family, source, descriptors), FontFace);
    }
    static _create_5(family, source) {
      return dart.as(new FontFace(family, source), FontFace);
    }
    static _create_6(family, source, descriptors) {
      return dart.as(new FontFace(family, source, descriptors), FontFace);
    }
    get [dartx.family]() {
      return this.family;
    }
    set [dartx.family](value) {
      this.family = value;
    }
    get [dartx.featureSettings]() {
      return this.featureSettings;
    }
    set [dartx.featureSettings](value) {
      this.featureSettings = value;
    }
    get [dartx.loaded]() {
      return this.loaded;
    }
    get [dartx.status]() {
      return this.status;
    }
    get [dartx.stretch]() {
      return this.stretch;
    }
    set [dartx.stretch](value) {
      this.stretch = value;
    }
    get [dartx.style]() {
      return this.style;
    }
    set [dartx.style](value) {
      this.style = value;
    }
    get [dartx.unicodeRange]() {
      return this.unicodeRange;
    }
    set [dartx.unicodeRange](value) {
      this.unicodeRange = value;
    }
    get [dartx.variant]() {
      return this.variant;
    }
    set [dartx.variant](value) {
      this.variant = value;
    }
    get [dartx.weight]() {
      return this.weight;
    }
    set [dartx.weight](value) {
      this.weight = value;
    }
    [dartx.load]() {
      return this.load();
    }
  }
  dart.setSignature(FontFace, {
    constructors: () => ({
      _: [FontFace, []],
      new: [FontFace, [core.String, dart.dynamic], [core.Map]]
    }),
    methods: () => ({[dartx.load]: [async.Future, []]}),
    statics: () => ({
      _create_1: [FontFace, [dart.dynamic, dart.dynamic]],
      _create_2: [FontFace, [dart.dynamic, dart.dynamic, dart.dynamic]],
      _create_3: [FontFace, [dart.dynamic, dart.dynamic]],
      _create_4: [FontFace, [dart.dynamic, dart.dynamic, dart.dynamic]],
      _create_5: [FontFace, [dart.dynamic, dart.dynamic]],
      _create_6: [FontFace, [dart.dynamic, dart.dynamic, dart.dynamic]]
    }),
    names: ['_create_1', '_create_2', '_create_3', '_create_4', '_create_5', '_create_6']
  });
  FontFace[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('FontFace')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("FontFace"))];
  dart.registerExtension(dart.global.FontFace, FontFace);
  dart.defineExtensionNames([
    'add',
    'check',
    'clear',
    'delete',
    'forEach',
    'has',
    'size',
    'status'
  ]);
  class FontFaceSet extends EventTarget {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.size]() {
      return this.size;
    }
    get [dartx.status]() {
      return this.status;
    }
    [dartx.add](fontFace) {
      return this.add(fontFace);
    }
    [dartx.check](font, text) {
      return this.check(font, text);
    }
    [dartx.clear]() {
      return this.clear();
    }
    [dartx.delete](fontFace) {
      return this.delete(fontFace);
    }
    [dartx.forEach](callback, thisArg) {
      return this.forEach(callback, thisArg);
    }
    [dartx.has](fontFace) {
      return this.has(fontFace);
    }
  }
  dart.setSignature(FontFaceSet, {
    constructors: () => ({_: [FontFaceSet, []]}),
    methods: () => ({
      [dartx.add]: [dart.void, [FontFace]],
      [dartx.check]: [core.bool, [core.String], [core.String]],
      [dartx.clear]: [dart.void, []],
      [dartx.delete]: [core.bool, [FontFace]],
      [dartx.forEach]: [dart.void, [FontFaceSetForEachCallback], [core.Object]],
      [dartx.has]: [core.bool, [FontFace]]
    })
  });
  FontFaceSet[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('FontFaceSet')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("FontFaceSet"))];
  dart.registerExtension(dart.global.FontFaceSet, FontFaceSet);
  const FontFaceSetForEachCallback = dart.typedef('FontFaceSetForEachCallback', () => dart.functionType(dart.void, [FontFace, FontFace, FontFaceSet]));
  dart.defineExtensionNames([
    'fontfaces'
  ]);
  class FontFaceSetLoadEvent extends Event {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.fontfaces]() {
      return this.fontfaces;
    }
  }
  dart.setSignature(FontFaceSetLoadEvent, {
    constructors: () => ({_: [FontFaceSetLoadEvent, []]})
  });
  FontFaceSetLoadEvent[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('FontFaceSetLoadEvent')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("FontFaceSetLoadEvent"))];
  dart.registerExtension(dart.global.FontFaceSetLoadEvent, FontFaceSetLoadEvent);
  dart.defineExtensionNames([
    'append',
    'appendBlob'
  ]);
  class FormData extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new(form) {
      if (form === void 0) form = null;
      if (form != null) {
        return FormData._create_1(form);
      }
      return FormData._create_2();
    }
    static _create_1(form) {
      return dart.as(new FormData(form), FormData);
    }
    static _create_2() {
      return dart.as(new FormData(), FormData);
    }
    static get supported() {
      return !!window.FormData;
    }
    [dartx.append](name, value) {
      return this.append(name, value);
    }
    [dartx.appendBlob](name, value, filename) {
      return this.append(name, value, filename);
    }
  }
  dart.setSignature(FormData, {
    constructors: () => ({
      _: [FormData, []],
      new: [FormData, [], [FormElement]]
    }),
    methods: () => ({
      [dartx.append]: [dart.void, [core.String, core.String]],
      [dartx.appendBlob]: [dart.void, [core.String, Blob], [core.String]]
    }),
    statics: () => ({
      _create_1: [FormData, [dart.dynamic]],
      _create_2: [FormData, []]
    }),
    names: ['_create_1', '_create_2']
  });
  FormData[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('FormData')), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.CHROME)), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.FIREFOX)), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.IE, '10')), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.SAFARI)), dart.const(new _js_helper.Native("FormData"))];
  dart.registerExtension(dart.global.FormData, FormData);
  const _requestAutocomplete_1 = Symbol('_requestAutocomplete_1');
  dart.defineExtensionNames([
    'checkValidity',
    'requestAutocomplete',
    'reset',
    'submit',
    'acceptCharset',
    'action',
    'autocomplete',
    'encoding',
    'enctype',
    'length',
    'method',
    'name',
    'noValidate',
    'target'
  ]);
  class FormElement extends HtmlElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return dart.as(exports.document[dartx.createElement]("form"), FormElement);
    }
    created() {
      this[dartx.acceptCharset] = null;
      this[dartx.action] = null;
      this[dartx.autocomplete] = null;
      this[dartx.encoding] = null;
      this[dartx.enctype] = null;
      this[dartx.length] = null;
      this[dartx.method] = null;
      this[dartx.name] = null;
      this[dartx.noValidate] = null;
      this[dartx.target] = null;
      super.created();
    }
    get [dartx.acceptCharset]() {
      return this.acceptCharset;
    }
    set [dartx.acceptCharset](value) {
      this.acceptCharset = value;
    }
    get [dartx.action]() {
      return this.action;
    }
    set [dartx.action](value) {
      this.action = value;
    }
    get [dartx.autocomplete]() {
      return this.autocomplete;
    }
    set [dartx.autocomplete](value) {
      this.autocomplete = value;
    }
    get [dartx.encoding]() {
      return this.encoding;
    }
    set [dartx.encoding](value) {
      this.encoding = value;
    }
    get [dartx.enctype]() {
      return this.enctype;
    }
    set [dartx.enctype](value) {
      this.enctype = value;
    }
    get [dartx.length]() {
      return this.length;
    }
    get [dartx.method]() {
      return this.method;
    }
    set [dartx.method](value) {
      this.method = value;
    }
    get [dartx.name]() {
      return this.name;
    }
    set [dartx.name](value) {
      this.name = value;
    }
    get [dartx.noValidate]() {
      return this.noValidate;
    }
    set [dartx.noValidate](value) {
      this.noValidate = value;
    }
    get [dartx.target]() {
      return this.target;
    }
    set [dartx.target](value) {
      this.target = value;
    }
    [__getter__](index_OR_name) {
      return this.__getter__(index_OR_name);
    }
    [dartx.checkValidity]() {
      return this.checkValidity();
    }
    [dartx.requestAutocomplete](details) {
      let details_1 = html_common.convertDartToNative_Dictionary(details);
      this[_requestAutocomplete_1](details_1);
      return;
    }
    [_requestAutocomplete_1](details) {
      return this.requestAutocomplete(details);
    }
    [dartx.reset]() {
      return this.reset();
    }
    [dartx.submit]() {
      return this.submit();
    }
  }
  dart.defineNamedConstructor(FormElement, 'created');
  dart.setSignature(FormElement, {
    constructors: () => ({
      _: [FormElement, []],
      new: [FormElement, []],
      created: [FormElement, []]
    }),
    methods: () => ({
      [__getter__]: [Element, [dart.dynamic]],
      [dartx.checkValidity]: [core.bool, []],
      [dartx.requestAutocomplete]: [dart.void, [core.Map]],
      [_requestAutocomplete_1]: [dart.void, [dart.dynamic]],
      [dartx.reset]: [dart.void, []],
      [dartx.submit]: [dart.void, []]
    })
  });
  FormElement[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('HTMLFormElement')), dart.const(new _js_helper.Native("HTMLFormElement"))];
  dart.registerExtension(dart.global.HTMLFormElement, FormElement);
  dart.defineExtensionNames([
    'axes',
    'connected',
    'id',
    'index',
    'mapping',
    'timestamp'
  ]);
  class Gamepad extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.axes]() {
      return this.axes;
    }
    get [dartx.connected]() {
      return this.connected;
    }
    get [dartx.id]() {
      return this.id;
    }
    get [dartx.index]() {
      return this.index;
    }
    get [dartx.mapping]() {
      return this.mapping;
    }
    get [dartx.timestamp]() {
      return this.timestamp;
    }
  }
  dart.setSignature(Gamepad, {
    constructors: () => ({_: [Gamepad, []]})
  });
  Gamepad[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('Gamepad')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("Gamepad"))];
  dart.registerExtension(dart.global.Gamepad, Gamepad);
  dart.defineExtensionNames([
    'pressed',
    'value'
  ]);
  class GamepadButton extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.pressed]() {
      return this.pressed;
    }
    get [dartx.value]() {
      return this.value;
    }
  }
  dart.setSignature(GamepadButton, {
    constructors: () => ({_: [GamepadButton, []]})
  });
  GamepadButton[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('GamepadButton')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("GamepadButton"))];
  dart.registerExtension(dart.global.GamepadButton, GamepadButton);
  dart.defineExtensionNames([
    'gamepad'
  ]);
  class GamepadEvent extends Event {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.gamepad]() {
      return this.gamepad;
    }
  }
  dart.setSignature(GamepadEvent, {
    constructors: () => ({_: [GamepadEvent, []]})
  });
  GamepadEvent[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('GamepadEvent')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("GamepadEvent"))];
  dart.registerExtension(dart.global.GamepadEvent, GamepadEvent);
  dart.defineExtensionNames([
    'getRegisteredRegions',
    'registerRegion',
    'unregisterRegion'
  ]);
  class Geofencing extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    [dartx.getRegisteredRegions]() {
      return this.getRegisteredRegions();
    }
    [dartx.registerRegion](region) {
      return this.registerRegion(region);
    }
    [dartx.unregisterRegion](regionId) {
      return this.unregisterRegion(regionId);
    }
  }
  dart.setSignature(Geofencing, {
    constructors: () => ({_: [Geofencing, []]}),
    methods: () => ({
      [dartx.getRegisteredRegions]: [async.Future, []],
      [dartx.registerRegion]: [async.Future, [GeofencingRegion]],
      [dartx.unregisterRegion]: [async.Future, [core.String]]
    })
  });
  Geofencing[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('Geofencing')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("Geofencing"))];
  dart.registerExtension(dart.global.Geofencing, Geofencing);
  const _getCurrentPosition = Symbol('_getCurrentPosition');
  const _ensurePosition = Symbol('_ensurePosition');
  const _watchPosition = Symbol('_watchPosition');
  const _clearWatch = Symbol('_clearWatch');
  const _getCurrentPosition_1 = Symbol('_getCurrentPosition_1');
  const _getCurrentPosition_2 = Symbol('_getCurrentPosition_2');
  const _getCurrentPosition_3 = Symbol('_getCurrentPosition_3');
  const _watchPosition_1 = Symbol('_watchPosition_1');
  const _watchPosition_2 = Symbol('_watchPosition_2');
  const _watchPosition_3 = Symbol('_watchPosition_3');
  dart.defineExtensionNames([
    'getCurrentPosition',
    'watchPosition'
  ]);
  class Geolocation extends _interceptors.Interceptor {
    [dartx.getCurrentPosition](opts) {
      let enableHighAccuracy = opts && 'enableHighAccuracy' in opts ? opts.enableHighAccuracy : null;
      let timeout = opts && 'timeout' in opts ? opts.timeout : null;
      let maximumAge = opts && 'maximumAge' in opts ? opts.maximumAge : null;
      let options = dart.map();
      if (enableHighAccuracy != null) {
        options[dartx.set]('enableHighAccuracy', enableHighAccuracy);
      }
      if (timeout != null) {
        options[dartx.set]('timeout', timeout.inMilliseconds);
      }
      if (maximumAge != null) {
        options[dartx.set]('maximumAge', maximumAge.inMilliseconds);
      }
      let completer = async.Completer$(Geoposition).new();
      try {
        this[_getCurrentPosition](dart.fn(position => {
          completer.complete(this[_ensurePosition](position));
        }, dart.void, [Geoposition]), dart.fn(error => {
          completer.completeError(error);
        }, dart.void, [PositionError]), options);
      } catch (e) {
        let stacktrace = dart.stackTrace(e);
        completer.completeError(e, stacktrace);
      }

      return completer.future;
    }
    [dartx.watchPosition](opts) {
      let enableHighAccuracy = opts && 'enableHighAccuracy' in opts ? opts.enableHighAccuracy : null;
      let timeout = opts && 'timeout' in opts ? opts.timeout : null;
      let maximumAge = opts && 'maximumAge' in opts ? opts.maximumAge : null;
      let options = dart.map();
      if (enableHighAccuracy != null) {
        options[dartx.set]('enableHighAccuracy', enableHighAccuracy);
      }
      if (timeout != null) {
        options[dartx.set]('timeout', timeout.inMilliseconds);
      }
      if (maximumAge != null) {
        options[dartx.set]('maximumAge', maximumAge.inMilliseconds);
      }
      let watchId = null;
      let controller = null;
      controller = async.StreamController$(Geoposition).new({sync: true, onListen: dart.fn(() => {
          dart.assert(watchId == null);
          watchId = this[_watchPosition](dart.fn(position => {
            dart.dsend(controller, 'add', this[_ensurePosition](position));
          }, dart.void, [Geoposition]), dart.fn(error => {
            dart.dsend(controller, 'addError', error);
          }, dart.void, [PositionError]), options);
        }, dart.void, []), onCancel: dart.fn(() => {
          dart.assert(watchId != null);
          this[_clearWatch](watchId);
        })});
      return dart.as(dart.dload(controller, 'stream'), async.Stream$(Geoposition));
    }
    [_ensurePosition](domPosition) {
      try {
        if (dart.is(domPosition, Geoposition)) {
          return domPosition;
        }
      } catch (e) {
      }

      return new _GeopositionWrapper(domPosition);
    }
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    [_clearWatch](watchID) {
      return this.clearWatch(watchID);
    }
    [_getCurrentPosition](successCallback, errorCallback, options) {
      if (errorCallback === void 0) errorCallback = null;
      if (options === void 0) options = null;
      if (options != null) {
        let options_1 = html_common.convertDartToNative_Dictionary(options);
        this[_getCurrentPosition_1](successCallback, errorCallback, options_1);
        return;
      }
      if (errorCallback != null) {
        this[_getCurrentPosition_2](successCallback, errorCallback);
        return;
      }
      this[_getCurrentPosition_3](successCallback);
      return;
    }
    [_getCurrentPosition_1](successCallback, errorCallback, options) {
      return this.getCurrentPosition(successCallback, errorCallback, options);
    }
    [_getCurrentPosition_2](successCallback, errorCallback) {
      return this.getCurrentPosition(successCallback, errorCallback);
    }
    [_getCurrentPosition_3](successCallback) {
      return this.getCurrentPosition(successCallback);
    }
    [_watchPosition](successCallback, errorCallback, options) {
      if (errorCallback === void 0) errorCallback = null;
      if (options === void 0) options = null;
      if (options != null) {
        let options_1 = html_common.convertDartToNative_Dictionary(options);
        return this[_watchPosition_1](successCallback, errorCallback, options_1);
      }
      if (errorCallback != null) {
        return this[_watchPosition_2](successCallback, errorCallback);
      }
      return this[_watchPosition_3](successCallback);
    }
    [_watchPosition_1](successCallback, errorCallback, options) {
      return this.watchPosition(successCallback, errorCallback, options);
    }
    [_watchPosition_2](successCallback, errorCallback) {
      return this.watchPosition(successCallback, errorCallback);
    }
    [_watchPosition_3](successCallback) {
      return this.watchPosition(successCallback);
    }
  }
  dart.setSignature(Geolocation, {
    constructors: () => ({_: [Geolocation, []]}),
    methods: () => ({
      [dartx.getCurrentPosition]: [async.Future$(Geoposition), [], {enableHighAccuracy: core.bool, timeout: core.Duration, maximumAge: core.Duration}],
      [dartx.watchPosition]: [async.Stream$(Geoposition), [], {enableHighAccuracy: core.bool, timeout: core.Duration, maximumAge: core.Duration}],
      [_ensurePosition]: [Geoposition, [dart.dynamic]],
      [_clearWatch]: [dart.void, [core.int]],
      [_getCurrentPosition]: [dart.void, [_PositionCallback], [_PositionErrorCallback, core.Map]],
      [_getCurrentPosition_1]: [dart.void, [_PositionCallback, _PositionErrorCallback, dart.dynamic]],
      [_getCurrentPosition_2]: [dart.void, [_PositionCallback, _PositionErrorCallback]],
      [_getCurrentPosition_3]: [dart.void, [_PositionCallback]],
      [_watchPosition]: [core.int, [_PositionCallback], [_PositionErrorCallback, core.Map]],
      [_watchPosition_1]: [core.int, [_PositionCallback, _PositionErrorCallback, dart.dynamic]],
      [_watchPosition_2]: [core.int, [_PositionCallback, _PositionErrorCallback]],
      [_watchPosition_3]: [core.int, [_PositionCallback]]
    })
  });
  Geolocation[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('Geolocation')), dart.const(new _metadata.Unstable()), dart.const(new _js_helper.Native("Geolocation"))];
  dart.registerExtension(dart.global.Geolocation, Geolocation);
  class _GeopositionWrapper extends core.Object {
    _GeopositionWrapper(ptr) {
      this[_ptr] = ptr;
    }
    get coords() {
      return dart.as(this[_ptr].coords, Coordinates);
    }
    get timestamp() {
      return this[_ptr].timestamp;
    }
  }
  _GeopositionWrapper[dart.implements] = () => [Geoposition];
  dart.setSignature(_GeopositionWrapper, {
    constructors: () => ({_GeopositionWrapper: [_GeopositionWrapper, [dart.dynamic]]})
  });
  dart.defineExtensionMembers(_GeopositionWrapper, ['coords', 'timestamp']);
  dart.defineExtensionNames([
    'coords',
    'timestamp'
  ]);
  class Geoposition extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.coords]() {
      return this.coords;
    }
    get [dartx.timestamp]() {
      return this.timestamp;
    }
  }
  dart.setSignature(Geoposition, {
    constructors: () => ({_: [Geoposition, []]})
  });
  Geoposition[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('Geoposition')), dart.const(new _metadata.Unstable()), dart.const(new _js_helper.Native("Geoposition"))];
  dart.registerExtension(dart.global.Geoposition, Geoposition);
  dart.defineExtensionNames([
    'onAbort',
    'onBlur',
    'onCanPlay',
    'onCanPlayThrough',
    'onChange',
    'onClick',
    'onContextMenu',
    'onDoubleClick',
    'onDrag',
    'onDragEnd',
    'onDragEnter',
    'onDragLeave',
    'onDragOver',
    'onDragStart',
    'onDrop',
    'onDurationChange',
    'onEmptied',
    'onEnded',
    'onError',
    'onFocus',
    'onInput',
    'onInvalid',
    'onKeyDown',
    'onKeyPress',
    'onKeyUp',
    'onLoad',
    'onLoadedData',
    'onLoadedMetadata',
    'onMouseDown',
    'onMouseEnter',
    'onMouseLeave',
    'onMouseMove',
    'onMouseOut',
    'onMouseOver',
    'onMouseUp',
    'onMouseWheel',
    'onPause',
    'onPlay',
    'onPlaying',
    'onRateChange',
    'onReset',
    'onResize',
    'onScroll',
    'onSeeked',
    'onSeeking',
    'onSelect',
    'onStalled',
    'onSubmit',
    'onSuspend',
    'onTimeUpdate',
    'onVolumeChange',
    'onWaiting'
  ]);
  class GlobalEventHandlers extends core.Object {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.onAbort]() {
      return GlobalEventHandlers.abortEvent.forTarget(this);
    }
    get [dartx.onBlur]() {
      return GlobalEventHandlers.blurEvent.forTarget(this);
    }
    get [dartx.onCanPlay]() {
      return GlobalEventHandlers.canPlayEvent.forTarget(this);
    }
    get [dartx.onCanPlayThrough]() {
      return GlobalEventHandlers.canPlayThroughEvent.forTarget(this);
    }
    get [dartx.onChange]() {
      return GlobalEventHandlers.changeEvent.forTarget(this);
    }
    get [dartx.onClick]() {
      return GlobalEventHandlers.clickEvent.forTarget(this);
    }
    get [dartx.onContextMenu]() {
      return GlobalEventHandlers.contextMenuEvent.forTarget(this);
    }
    get [dartx.onDoubleClick]() {
      return GlobalEventHandlers.doubleClickEvent.forTarget(this);
    }
    get [dartx.onDrag]() {
      return GlobalEventHandlers.dragEvent.forTarget(this);
    }
    get [dartx.onDragEnd]() {
      return GlobalEventHandlers.dragEndEvent.forTarget(this);
    }
    get [dartx.onDragEnter]() {
      return GlobalEventHandlers.dragEnterEvent.forTarget(this);
    }
    get [dartx.onDragLeave]() {
      return GlobalEventHandlers.dragLeaveEvent.forTarget(this);
    }
    get [dartx.onDragOver]() {
      return GlobalEventHandlers.dragOverEvent.forTarget(this);
    }
    get [dartx.onDragStart]() {
      return GlobalEventHandlers.dragStartEvent.forTarget(this);
    }
    get [dartx.onDrop]() {
      return GlobalEventHandlers.dropEvent.forTarget(this);
    }
    get [dartx.onDurationChange]() {
      return GlobalEventHandlers.durationChangeEvent.forTarget(this);
    }
    get [dartx.onEmptied]() {
      return GlobalEventHandlers.emptiedEvent.forTarget(this);
    }
    get [dartx.onEnded]() {
      return GlobalEventHandlers.endedEvent.forTarget(this);
    }
    get [dartx.onError]() {
      return GlobalEventHandlers.errorEvent.forTarget(this);
    }
    get [dartx.onFocus]() {
      return GlobalEventHandlers.focusEvent.forTarget(this);
    }
    get [dartx.onInput]() {
      return GlobalEventHandlers.inputEvent.forTarget(this);
    }
    get [dartx.onInvalid]() {
      return GlobalEventHandlers.invalidEvent.forTarget(this);
    }
    get [dartx.onKeyDown]() {
      return GlobalEventHandlers.keyDownEvent.forTarget(this);
    }
    get [dartx.onKeyPress]() {
      return GlobalEventHandlers.keyPressEvent.forTarget(this);
    }
    get [dartx.onKeyUp]() {
      return GlobalEventHandlers.keyUpEvent.forTarget(this);
    }
    get [dartx.onLoad]() {
      return GlobalEventHandlers.loadEvent.forTarget(this);
    }
    get [dartx.onLoadedData]() {
      return GlobalEventHandlers.loadedDataEvent.forTarget(this);
    }
    get [dartx.onLoadedMetadata]() {
      return GlobalEventHandlers.loadedMetadataEvent.forTarget(this);
    }
    get [dartx.onMouseDown]() {
      return GlobalEventHandlers.mouseDownEvent.forTarget(this);
    }
    get [dartx.onMouseEnter]() {
      return GlobalEventHandlers.mouseEnterEvent.forTarget(this);
    }
    get [dartx.onMouseLeave]() {
      return GlobalEventHandlers.mouseLeaveEvent.forTarget(this);
    }
    get [dartx.onMouseMove]() {
      return GlobalEventHandlers.mouseMoveEvent.forTarget(this);
    }
    get [dartx.onMouseOut]() {
      return GlobalEventHandlers.mouseOutEvent.forTarget(this);
    }
    get [dartx.onMouseOver]() {
      return GlobalEventHandlers.mouseOverEvent.forTarget(this);
    }
    get [dartx.onMouseUp]() {
      return GlobalEventHandlers.mouseUpEvent.forTarget(this);
    }
    get [dartx.onMouseWheel]() {
      return GlobalEventHandlers.mouseWheelEvent.forTarget(this);
    }
    get [dartx.onPause]() {
      return GlobalEventHandlers.pauseEvent.forTarget(this);
    }
    get [dartx.onPlay]() {
      return GlobalEventHandlers.playEvent.forTarget(this);
    }
    get [dartx.onPlaying]() {
      return GlobalEventHandlers.playingEvent.forTarget(this);
    }
    get [dartx.onRateChange]() {
      return GlobalEventHandlers.rateChangeEvent.forTarget(this);
    }
    get [dartx.onReset]() {
      return GlobalEventHandlers.resetEvent.forTarget(this);
    }
    get [dartx.onResize]() {
      return GlobalEventHandlers.resizeEvent.forTarget(this);
    }
    get [dartx.onScroll]() {
      return GlobalEventHandlers.scrollEvent.forTarget(this);
    }
    get [dartx.onSeeked]() {
      return GlobalEventHandlers.seekedEvent.forTarget(this);
    }
    get [dartx.onSeeking]() {
      return GlobalEventHandlers.seekingEvent.forTarget(this);
    }
    get [dartx.onSelect]() {
      return GlobalEventHandlers.selectEvent.forTarget(this);
    }
    get [dartx.onStalled]() {
      return GlobalEventHandlers.stalledEvent.forTarget(this);
    }
    get [dartx.onSubmit]() {
      return GlobalEventHandlers.submitEvent.forTarget(this);
    }
    get [dartx.onSuspend]() {
      return GlobalEventHandlers.suspendEvent.forTarget(this);
    }
    get [dartx.onTimeUpdate]() {
      return GlobalEventHandlers.timeUpdateEvent.forTarget(this);
    }
    get [dartx.onVolumeChange]() {
      return GlobalEventHandlers.volumeChangeEvent.forTarget(this);
    }
    get [dartx.onWaiting]() {
      return GlobalEventHandlers.waitingEvent.forTarget(this);
    }
  }
  GlobalEventHandlers[dart.implements] = () => [EventTarget];
  dart.setSignature(GlobalEventHandlers, {
    constructors: () => ({_: [GlobalEventHandlers, []]})
  });
  GlobalEventHandlers[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('GlobalEventHandlers')), dart.const(new _metadata.Experimental())];
  dart.defineLazyProperties(GlobalEventHandlers, {
    get abortEvent() {
      return dart.const(new (EventStreamProvider$(Event))('abort'));
    },
    get blurEvent() {
      return dart.const(new (EventStreamProvider$(Event))('blur'));
    },
    get canPlayEvent() {
      return dart.const(new (EventStreamProvider$(Event))('canplay'));
    },
    get canPlayThroughEvent() {
      return dart.const(new (EventStreamProvider$(Event))('canplaythrough'));
    },
    get changeEvent() {
      return dart.const(new (EventStreamProvider$(Event))('change'));
    },
    get clickEvent() {
      return dart.const(new (EventStreamProvider$(MouseEvent))('click'));
    },
    get contextMenuEvent() {
      return dart.const(new (EventStreamProvider$(MouseEvent))('contextmenu'));
    },
    get doubleClickEvent() {
      return dart.const(new (EventStreamProvider$(Event))('dblclick'));
    },
    get dragEvent() {
      return dart.const(new (EventStreamProvider$(MouseEvent))('drag'));
    },
    get dragEndEvent() {
      return dart.const(new (EventStreamProvider$(MouseEvent))('dragend'));
    },
    get dragEnterEvent() {
      return dart.const(new (EventStreamProvider$(MouseEvent))('dragenter'));
    },
    get dragLeaveEvent() {
      return dart.const(new (EventStreamProvider$(MouseEvent))('dragleave'));
    },
    get dragOverEvent() {
      return dart.const(new (EventStreamProvider$(MouseEvent))('dragover'));
    },
    get dragStartEvent() {
      return dart.const(new (EventStreamProvider$(MouseEvent))('dragstart'));
    },
    get dropEvent() {
      return dart.const(new (EventStreamProvider$(MouseEvent))('drop'));
    },
    get durationChangeEvent() {
      return dart.const(new (EventStreamProvider$(Event))('durationchange'));
    },
    get emptiedEvent() {
      return dart.const(new (EventStreamProvider$(Event))('emptied'));
    },
    get endedEvent() {
      return dart.const(new (EventStreamProvider$(Event))('ended'));
    },
    get errorEvent() {
      return dart.const(new (EventStreamProvider$(Event))('error'));
    },
    get focusEvent() {
      return dart.const(new (EventStreamProvider$(Event))('focus'));
    },
    get inputEvent() {
      return dart.const(new (EventStreamProvider$(Event))('input'));
    },
    get invalidEvent() {
      return dart.const(new (EventStreamProvider$(Event))('invalid'));
    },
    get keyDownEvent() {
      return dart.const(new (EventStreamProvider$(KeyboardEvent))('keydown'));
    },
    get keyPressEvent() {
      return dart.const(new (EventStreamProvider$(KeyboardEvent))('keypress'));
    },
    get keyUpEvent() {
      return dart.const(new (EventStreamProvider$(KeyboardEvent))('keyup'));
    },
    get loadEvent() {
      return dart.const(new (EventStreamProvider$(Event))('load'));
    },
    get loadedDataEvent() {
      return dart.const(new (EventStreamProvider$(Event))('loadeddata'));
    },
    get loadedMetadataEvent() {
      return dart.const(new (EventStreamProvider$(Event))('loadedmetadata'));
    },
    get mouseDownEvent() {
      return dart.const(new (EventStreamProvider$(MouseEvent))('mousedown'));
    },
    get mouseEnterEvent() {
      return dart.const(new (EventStreamProvider$(MouseEvent))('mouseenter'));
    },
    get mouseLeaveEvent() {
      return dart.const(new (EventStreamProvider$(MouseEvent))('mouseleave'));
    },
    get mouseMoveEvent() {
      return dart.const(new (EventStreamProvider$(MouseEvent))('mousemove'));
    },
    get mouseOutEvent() {
      return dart.const(new (EventStreamProvider$(MouseEvent))('mouseout'));
    },
    get mouseOverEvent() {
      return dart.const(new (EventStreamProvider$(MouseEvent))('mouseover'));
    },
    get mouseUpEvent() {
      return dart.const(new (EventStreamProvider$(MouseEvent))('mouseup'));
    },
    get mouseWheelEvent() {
      return dart.const(new (EventStreamProvider$(WheelEvent))('mousewheel'));
    },
    get pauseEvent() {
      return dart.const(new (EventStreamProvider$(Event))('pause'));
    },
    get playEvent() {
      return dart.const(new (EventStreamProvider$(Event))('play'));
    },
    get playingEvent() {
      return dart.const(new (EventStreamProvider$(Event))('playing'));
    },
    get rateChangeEvent() {
      return dart.const(new (EventStreamProvider$(Event))('ratechange'));
    },
    get resetEvent() {
      return dart.const(new (EventStreamProvider$(Event))('reset'));
    },
    get resizeEvent() {
      return dart.const(new (EventStreamProvider$(Event))('resize'));
    },
    get scrollEvent() {
      return dart.const(new (EventStreamProvider$(Event))('scroll'));
    },
    get seekedEvent() {
      return dart.const(new (EventStreamProvider$(Event))('seeked'));
    },
    get seekingEvent() {
      return dart.const(new (EventStreamProvider$(Event))('seeking'));
    },
    get selectEvent() {
      return dart.const(new (EventStreamProvider$(Event))('select'));
    },
    get stalledEvent() {
      return dart.const(new (EventStreamProvider$(Event))('stalled'));
    },
    get submitEvent() {
      return dart.const(new (EventStreamProvider$(Event))('submit'));
    },
    get suspendEvent() {
      return dart.const(new (EventStreamProvider$(Event))('suspend'));
    },
    get timeUpdateEvent() {
      return dart.const(new (EventStreamProvider$(Event))('timeupdate'));
    },
    get volumeChangeEvent() {
      return dart.const(new (EventStreamProvider$(Event))('volumechange'));
    },
    get waitingEvent() {
      return dart.const(new (EventStreamProvider$(Event))('waiting'));
    }
  });
  dart.defineExtensionNames([
    'color'
  ]);
  class HRElement extends HtmlElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return dart.as(exports.document[dartx.createElement]("hr"), HRElement);
    }
    created() {
      this[dartx.color] = null;
      super.created();
    }
    get [dartx.color]() {
      return this.color;
    }
    set [dartx.color](value) {
      this.color = value;
    }
  }
  dart.defineNamedConstructor(HRElement, 'created');
  dart.setSignature(HRElement, {
    constructors: () => ({
      _: [HRElement, []],
      new: [HRElement, []],
      created: [HRElement, []]
    })
  });
  HRElement[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('HTMLHRElement')), dart.const(new _js_helper.Native("HTMLHRElement"))];
  dart.registerExtension(dart.global.HTMLHRElement, HRElement);
  const _initHashChangeEvent = Symbol('_initHashChangeEvent');
  dart.defineExtensionNames([
    'newUrl',
    'oldUrl'
  ]);
  class HashChangeEvent extends Event {
    static new(type, opts) {
      let canBubble = opts && 'canBubble' in opts ? opts.canBubble : true;
      let cancelable = opts && 'cancelable' in opts ? opts.cancelable : true;
      let oldUrl = opts && 'oldUrl' in opts ? opts.oldUrl : null;
      let newUrl = opts && 'newUrl' in opts ? opts.newUrl : null;
      let options = dart.map({canBubble: canBubble, cancelable: cancelable, oldURL: oldUrl, newURL: newUrl});
      return dart.as(new HashChangeEvent(type, html_common.convertDartToNative_Dictionary(options)), HashChangeEvent);
    }
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static get supported() {
      return html_common.Device.isEventTypeSupported('HashChangeEvent');
    }
    get [dartx.newUrl]() {
      return this.newURL;
    }
    get [dartx.oldUrl]() {
      return this.oldURL;
    }
    [_initHashChangeEvent](type, canBubble, cancelable, oldURL, newURL) {
      return this.initHashChangeEvent(type, canBubble, cancelable, oldURL, newURL);
    }
  }
  dart.setSignature(HashChangeEvent, {
    constructors: () => ({
      new: [HashChangeEvent, [core.String], {canBubble: core.bool, cancelable: core.bool, oldUrl: core.String, newUrl: core.String}],
      _: [HashChangeEvent, []]
    }),
    methods: () => ({[_initHashChangeEvent]: [dart.void, [core.String, core.bool, core.bool, core.String, core.String]]})
  });
  HashChangeEvent[dart.metadata] = () => [dart.const(new _metadata.DomName('HashChangeEvent')), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.CHROME)), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.FIREFOX)), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.SAFARI)), dart.const(new _metadata.Unstable()), dart.const(new _js_helper.Native("HashChangeEvent"))];
  dart.registerExtension(dart.global.HashChangeEvent, HashChangeEvent);
  class HeadElement extends HtmlElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return dart.as(exports.document[dartx.createElement]("head"), HeadElement);
    }
    created() {
      super.created();
    }
  }
  dart.defineNamedConstructor(HeadElement, 'created');
  dart.setSignature(HeadElement, {
    constructors: () => ({
      _: [HeadElement, []],
      new: [HeadElement, []],
      created: [HeadElement, []]
    })
  });
  HeadElement[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('HTMLHeadElement')), dart.const(new _js_helper.Native("HTMLHeadElement"))];
  dart.registerExtension(dart.global.HTMLHeadElement, HeadElement);
  dart.defineExtensionNames([
    'forEach',
    'size'
  ]);
  class Headers extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new(input) {
      if (input === void 0) input = null;
      if (input == null) {
        return Headers._create_1();
      }
      if (dart.is(input, Headers) || input == null) {
        return Headers._create_2(input);
      }
      if (dart.is(input, core.Map) || input == null) {
        let input_1 = html_common.convertDartToNative_Dictionary(dart.as(input, core.Map));
        return Headers._create_3(input_1);
      }
      dart.throw(new core.ArgumentError("Incorrect number or type of arguments"));
    }
    static _create_1() {
      return dart.as(new Headers(), Headers);
    }
    static _create_2(input) {
      return dart.as(new Headers(input), Headers);
    }
    static _create_3(input) {
      return dart.as(new Headers(input), Headers);
    }
    get [dartx.size]() {
      return this.size;
    }
    [dartx.forEach](callback, thisArg) {
      return this.forEach(callback, thisArg);
    }
  }
  dart.setSignature(Headers, {
    constructors: () => ({
      _: [Headers, []],
      new: [Headers, [], [dart.dynamic]]
    }),
    methods: () => ({[dartx.forEach]: [dart.void, [HeadersForEachCallback], [core.Object]]}),
    statics: () => ({
      _create_1: [Headers, []],
      _create_2: [Headers, [dart.dynamic]],
      _create_3: [Headers, [dart.dynamic]]
    }),
    names: ['_create_1', '_create_2', '_create_3']
  });
  Headers[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('Headers')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("Headers"))];
  dart.registerExtension(dart.global.Headers, Headers);
  const HeadersForEachCallback = dart.typedef('HeadersForEachCallback', () => dart.functionType(dart.void, [core.String, core.String, Headers]));
  class HeadingElement extends HtmlElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static h1() {
      return dart.as(exports.document[dartx.createElement]("h1"), HeadingElement);
    }
    static h2() {
      return dart.as(exports.document[dartx.createElement]("h2"), HeadingElement);
    }
    static h3() {
      return dart.as(exports.document[dartx.createElement]("h3"), HeadingElement);
    }
    static h4() {
      return dart.as(exports.document[dartx.createElement]("h4"), HeadingElement);
    }
    static h5() {
      return dart.as(exports.document[dartx.createElement]("h5"), HeadingElement);
    }
    static h6() {
      return dart.as(exports.document[dartx.createElement]("h6"), HeadingElement);
    }
    created() {
      super.created();
    }
  }
  dart.defineNamedConstructor(HeadingElement, 'created');
  dart.setSignature(HeadingElement, {
    constructors: () => ({
      _: [HeadingElement, []],
      h1: [HeadingElement, []],
      h2: [HeadingElement, []],
      h3: [HeadingElement, []],
      h4: [HeadingElement, []],
      h5: [HeadingElement, []],
      h6: [HeadingElement, []],
      created: [HeadingElement, []]
    })
  });
  HeadingElement[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('HTMLHeadingElement')), dart.const(new _js_helper.Native("HTMLHeadingElement"))];
  dart.registerExtension(dart.global.HTMLHeadingElement, HeadingElement);
  const _get_state = Symbol('_get_state');
  const _pushState_1 = Symbol('_pushState_1');
  const _pushState_2 = Symbol('_pushState_2');
  const _replaceState_1 = Symbol('_replaceState_1');
  const _replaceState_2 = Symbol('_replaceState_2');
  dart.defineExtensionNames([
    'state',
    'back',
    'forward',
    'go',
    'pushState',
    'replaceState',
    'length'
  ]);
  class History extends _interceptors.Interceptor {
    static get supportsState() {
      return !!window.history.pushState;
    }
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.length]() {
      return this.length;
    }
    get [dartx.state]() {
      return html_common.convertNativeToDart_SerializedScriptValue(this[_get_state]);
    }
    get [_get_state]() {
      return this.state;
    }
    [dartx.back]() {
      return this.back();
    }
    [dartx.forward]() {
      return this.forward();
    }
    [dartx.go](distance) {
      return this.go(distance);
    }
    [dartx.pushState](data, title, url) {
      if (url === void 0) url = null;
      if (url != null) {
        let data_1 = html_common.convertDartToNative_SerializedScriptValue(data);
        this[_pushState_1](data_1, title, url);
        return;
      }
      let data_1 = html_common.convertDartToNative_SerializedScriptValue(data);
      this[_pushState_2](data_1, title);
      return;
    }
    [_pushState_1](data, title, url) {
      return this.pushState(data, title, url);
    }
    [_pushState_2](data, title) {
      return this.pushState(data, title);
    }
    [dartx.replaceState](data, title, url) {
      if (url === void 0) url = null;
      if (url != null) {
        let data_1 = html_common.convertDartToNative_SerializedScriptValue(data);
        this[_replaceState_1](data_1, title, url);
        return;
      }
      let data_1 = html_common.convertDartToNative_SerializedScriptValue(data);
      this[_replaceState_2](data_1, title);
      return;
    }
    [_replaceState_1](data, title, url) {
      return this.replaceState(data, title, url);
    }
    [_replaceState_2](data, title) {
      return this.replaceState(data, title);
    }
  }
  History[dart.implements] = () => [HistoryBase];
  dart.setSignature(History, {
    constructors: () => ({_: [History, []]}),
    methods: () => ({
      [dartx.back]: [dart.void, []],
      [dartx.forward]: [dart.void, []],
      [dartx.go]: [dart.void, [core.int]],
      [dartx.pushState]: [dart.void, [dart.dynamic, core.String], [core.String]],
      [_pushState_1]: [dart.void, [dart.dynamic, dart.dynamic, dart.dynamic]],
      [_pushState_2]: [dart.void, [dart.dynamic, dart.dynamic]],
      [dartx.replaceState]: [dart.void, [dart.dynamic, core.String], [core.String]],
      [_replaceState_1]: [dart.void, [dart.dynamic, dart.dynamic, dart.dynamic]],
      [_replaceState_2]: [dart.void, [dart.dynamic, dart.dynamic]]
    })
  });
  History[dart.metadata] = () => [dart.const(new _metadata.DomName('History')), dart.const(new _js_helper.Native("History"))];
  dart.registerExtension(dart.global.History, History);
  dart.defineExtensionNames([
    'length',
    'get',
    'set',
    'length',
    'first',
    'last',
    'single',
    'elementAt',
    'item',
    'namedItem'
  ]);
  class HtmlCollection extends dart.mixin(_interceptors.Interceptor, collection.ListMixin$(Node), ImmutableListMixin$(Node)) {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.length]() {
      return this.length;
    }
    [dartx.get](index) {
      if (index >>> 0 !== index || index >= this[dartx.length]) dart.throw(core.RangeError.index(index, this));
      return dart.as(this[index], Node);
    }
    [dartx.set](index, value) {
      dart.throw(new core.UnsupportedError("Cannot assign element of immutable List."));
      return value;
    }
    set [dartx.length](value) {
      dart.throw(new core.UnsupportedError("Cannot resize immutable List."));
    }
    get [dartx.first]() {
      if (dart.notNull(this[dartx.length]) > 0) {
        return dart.as(this[0], Node);
      }
      dart.throw(new core.StateError("No elements"));
    }
    get [dartx.last]() {
      let len = this[dartx.length];
      if (dart.notNull(len) > 0) {
        return dart.as(this[dart.notNull(len) - 1], Node);
      }
      dart.throw(new core.StateError("No elements"));
    }
    get [dartx.single]() {
      let len = this[dartx.length];
      if (len == 1) {
        return dart.as(this[0], Node);
      }
      if (len == 0) dart.throw(new core.StateError("No elements"));
      dart.throw(new core.StateError("More than one element"));
    }
    [dartx.elementAt](index) {
      return this[dartx.get](index);
    }
    [dartx.item](index) {
      return this.item(index);
    }
    [dartx.namedItem](name) {
      return this.namedItem(name);
    }
  }
  HtmlCollection[dart.implements] = () => [_js_helper.JavaScriptIndexingBehavior, core.List$(Node)];
  dart.setSignature(HtmlCollection, {
    constructors: () => ({_: [HtmlCollection, []]}),
    methods: () => ({
      [dartx.get]: [Node, [core.int]],
      [dartx.set]: [dart.void, [core.int, Node]],
      [dartx.elementAt]: [Node, [core.int]],
      [dartx.item]: [Element, [core.int]],
      [dartx.namedItem]: [Element, [core.String]]
    })
  });
  HtmlCollection[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('HTMLCollection')), dart.const(new _js_helper.Native("HTMLCollection"))];
  dart.registerExtension(dart.global.HTMLCollection, HtmlCollection);
  dart.defineExtensionNames([
    'caretRangeFromPoint',
    'elementFromPoint',
    'getCssCanvasContext',
    'head',
    'lastModified',
    'preferredStylesheetSet',
    'referrer',
    'selectedStylesheetSet',
    'selectedStylesheetSet',
    'styleSheets',
    'title',
    'title',
    'exitFullscreen',
    'fullscreenElement',
    'fullscreenEnabled',
    'hidden',
    'visibilityState',
    'registerElement',
    'register',
    'onVisibilityChange',
    'createElementUpgrader',
    'body'
  ]);
  class HtmlDocument extends Document {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.body]() {
      return this.body;
    }
    set [dartx.body](value) {
      this.body = value;
    }
    [dartx.caretRangeFromPoint](x, y) {
      return this[_caretRangeFromPoint](x, y);
    }
    [dartx.elementFromPoint](x, y) {
      return this[_elementFromPoint](x, y);
    }
    static get supportsCssCanvasContext() {
      return !!document.getCSSCanvasContext;
    }
    [dartx.getCssCanvasContext](contextId, name, width, height) {
      return dart.as(this[_getCssCanvasContext](contextId, name, width, height), CanvasRenderingContext);
    }
    get [dartx.head]() {
      return this[_head];
    }
    get [dartx.lastModified]() {
      return this[_lastModified];
    }
    get [dartx.preferredStylesheetSet]() {
      return this[_preferredStylesheetSet];
    }
    get [dartx.referrer]() {
      return this[_referrer];
    }
    get [dartx.selectedStylesheetSet]() {
      return this[_selectedStylesheetSet];
    }
    set [dartx.selectedStylesheetSet](value) {
      this[_selectedStylesheetSet] = value;
    }
    get [dartx.styleSheets]() {
      return this[_styleSheets];
    }
    get [dartx.title]() {
      return this[_title];
    }
    set [dartx.title](value) {
      this[_title] = value;
    }
    [dartx.exitFullscreen]() {
      this[_webkitExitFullscreen]();
    }
    get [dartx.fullscreenElement]() {
      return this[_webkitFullscreenElement];
    }
    get [dartx.fullscreenEnabled]() {
      return this[_webkitFullscreenEnabled];
    }
    get [dartx.hidden]() {
      return this[_webkitHidden];
    }
    get [dartx.visibilityState]() {
      return this.visibilityState || this.mozVisibilityState || this.msVisibilityState || this.webkitVisibilityState;
    }
    [dartx.registerElement](tag, customElementClass, opts) {
      let extendsTag = opts && 'extendsTag' in opts ? opts.extendsTag : null;
      _registerCustomElement(window, this, tag, customElementClass, extendsTag);
    }
    [dartx.register](tag, customElementClass, opts) {
      let extendsTag = opts && 'extendsTag' in opts ? opts.extendsTag : null;
      return this[dartx.registerElement](tag, customElementClass, {extendsTag: extendsTag});
    }
    static _determineVisibilityChangeEventType(e) {
      if (typeof e.hidden !== "undefined") {
        return 'visibilitychange';
      } else if (typeof e.mozHidden !== "undefined") {
        return 'mozvisibilitychange';
      } else if (typeof e.msHidden !== "undefined") {
        return 'msvisibilitychange';
      } else if (typeof e.webkitHidden !== "undefined") {
        return 'webkitvisibilitychange';
      }
      return 'visibilitychange';
    }
    get [dartx.onVisibilityChange]() {
      return HtmlDocument.visibilityChangeEvent.forTarget(this);
    }
    [dartx.createElementUpgrader](type, opts) {
      let extendsTag = opts && 'extendsTag' in opts ? opts.extendsTag : null;
      return new _JSElementUpgrader(this, type, extendsTag);
    }
  }
  dart.setSignature(HtmlDocument, {
    constructors: () => ({_: [HtmlDocument, []]}),
    methods: () => ({
      [dartx.caretRangeFromPoint]: [Range, [core.int, core.int]],
      [dartx.elementFromPoint]: [Element, [core.int, core.int]],
      [dartx.getCssCanvasContext]: [CanvasRenderingContext, [core.String, core.String, core.int, core.int]],
      [dartx.registerElement]: [dart.void, [core.String, core.Type], {extendsTag: core.String}],
      [dartx.register]: [dart.void, [core.String, core.Type], {extendsTag: core.String}],
      [dartx.createElementUpgrader]: [ElementUpgrader, [core.Type], {extendsTag: core.String}]
    }),
    statics: () => ({_determineVisibilityChangeEventType: [core.String, [EventTarget]]}),
    names: ['_determineVisibilityChangeEventType']
  });
  HtmlDocument[dart.metadata] = () => [dart.const(new _metadata.DomName('HTMLDocument')), dart.const(new _js_helper.Native("HTMLDocument"))];
  dart.defineLazyProperties(HtmlDocument, {
    get visibilityChangeEvent() {
      return dart.const(new (_CustomEventStreamProvider$(Event))(HtmlDocument._determineVisibilityChangeEventType));
    }
  });
  dart.registerExtension(dart.global.HTMLDocument, HtmlDocument);
  dart.defineExtensionNames([
    'namedItem'
  ]);
  class HtmlFormControlsCollection extends HtmlCollection {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    [dartx.namedItem](name) {
      return this.namedItem(name);
    }
  }
  dart.setSignature(HtmlFormControlsCollection, {
    constructors: () => ({_: [HtmlFormControlsCollection, []]}),
    methods: () => ({[dartx.namedItem]: [core.Object, [core.String]]})
  });
  HtmlFormControlsCollection[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('HTMLFormControlsCollection')), dart.const(new _js_helper.Native("HTMLFormControlsCollection"))];
  dart.registerExtension(dart.global.HTMLFormControlsCollection, HtmlFormControlsCollection);
  class HtmlHtmlElement extends HtmlElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return dart.as(exports.document[dartx.createElement]("html"), HtmlHtmlElement);
    }
    created() {
      super.created();
    }
  }
  dart.defineNamedConstructor(HtmlHtmlElement, 'created');
  dart.setSignature(HtmlHtmlElement, {
    constructors: () => ({
      _: [HtmlHtmlElement, []],
      new: [HtmlHtmlElement, []],
      created: [HtmlHtmlElement, []]
    })
  });
  HtmlHtmlElement[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('HTMLHtmlElement')), dart.const(new _js_helper.Native("HTMLHtmlElement"))];
  dart.registerExtension(dart.global.HTMLHtmlElement, HtmlHtmlElement);
  class HtmlOptionsCollection extends HtmlCollection {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
  }
  dart.setSignature(HtmlOptionsCollection, {
    constructors: () => ({_: [HtmlOptionsCollection, []]})
  });
  HtmlOptionsCollection[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('HTMLOptionsCollection')), dart.const(new _js_helper.Native("HTMLOptionsCollection"))];
  dart.registerExtension(dart.global.HTMLOptionsCollection, HtmlOptionsCollection);
  dart.defineExtensionNames([
    'onAbort',
    'onError',
    'onLoad',
    'onLoadEnd',
    'onLoadStart',
    'onProgress',
    'onTimeout'
  ]);
  class HttpRequestEventTarget extends EventTarget {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.onAbort]() {
      return HttpRequestEventTarget.abortEvent.forTarget(this);
    }
    get [dartx.onError]() {
      return HttpRequestEventTarget.errorEvent.forTarget(this);
    }
    get [dartx.onLoad]() {
      return HttpRequestEventTarget.loadEvent.forTarget(this);
    }
    get [dartx.onLoadEnd]() {
      return HttpRequestEventTarget.loadEndEvent.forTarget(this);
    }
    get [dartx.onLoadStart]() {
      return HttpRequestEventTarget.loadStartEvent.forTarget(this);
    }
    get [dartx.onProgress]() {
      return HttpRequestEventTarget.progressEvent.forTarget(this);
    }
    get [dartx.onTimeout]() {
      return HttpRequestEventTarget.timeoutEvent.forTarget(this);
    }
  }
  dart.setSignature(HttpRequestEventTarget, {
    constructors: () => ({_: [HttpRequestEventTarget, []]})
  });
  HttpRequestEventTarget[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('XMLHttpRequestEventTarget')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("XMLHttpRequestEventTarget"))];
  dart.defineLazyProperties(HttpRequestEventTarget, {
    get abortEvent() {
      return dart.const(new (EventStreamProvider$(ProgressEvent))('abort'));
    },
    get errorEvent() {
      return dart.const(new (EventStreamProvider$(ProgressEvent))('error'));
    },
    get loadEvent() {
      return dart.const(new (EventStreamProvider$(ProgressEvent))('load'));
    },
    get loadEndEvent() {
      return dart.const(new (EventStreamProvider$(ProgressEvent))('loadend'));
    },
    get loadStartEvent() {
      return dart.const(new (EventStreamProvider$(ProgressEvent))('loadstart'));
    },
    get progressEvent() {
      return dart.const(new (EventStreamProvider$(ProgressEvent))('progress'));
    },
    get timeoutEvent() {
      return dart.const(new (EventStreamProvider$(ProgressEvent))('timeout'));
    }
  });
  dart.registerExtension(dart.global.XMLHttpRequestEventTarget, HttpRequestEventTarget);
  const _get_response = Symbol('_get_response');
  dart.defineExtensionNames([
    'responseHeaders',
    'open',
    'response',
    'abort',
    'getAllResponseHeaders',
    'getResponseHeader',
    'overrideMimeType',
    'send',
    'setRequestHeader',
    'onReadyStateChange',
    'readyState',
    'responseText',
    'responseType',
    'responseUrl',
    'responseXml',
    'status',
    'statusText',
    'timeout',
    'upload',
    'withCredentials'
  ]);
  class HttpRequest extends HttpRequestEventTarget {
    static getString(url, opts) {
      let withCredentials = opts && 'withCredentials' in opts ? opts.withCredentials : null;
      let onProgress = opts && 'onProgress' in opts ? opts.onProgress : null;
      return HttpRequest.request(url, {withCredentials: withCredentials, onProgress: onProgress}).then(dart.fn(xhr => xhr[dartx.responseText], core.String, [HttpRequest]));
    }
    static postFormData(url, data, opts) {
      let withCredentials = opts && 'withCredentials' in opts ? opts.withCredentials : null;
      let responseType = opts && 'responseType' in opts ? opts.responseType : null;
      let requestHeaders = opts && 'requestHeaders' in opts ? opts.requestHeaders : null;
      let onProgress = opts && 'onProgress' in opts ? opts.onProgress : null;
      let parts = [];
      data[dartx.forEach](dart.fn((key, value) => {
        parts[dartx.add](`${core.Uri.encodeQueryComponent(key)}=` + `${core.Uri.encodeQueryComponent(value)}`);
      }, dart.void, [core.String, core.String]));
      let formData = parts[dartx.join]('&');
      if (requestHeaders == null) {
        requestHeaders = dart.map({}, core.String, core.String);
      }
      requestHeaders[dartx.putIfAbsent]('Content-Type', dart.fn(() => 'application/x-www-form-urlencoded; charset=UTF-8', core.String, []));
      return HttpRequest.request(url, {method: 'POST', withCredentials: withCredentials, responseType: responseType, requestHeaders: requestHeaders, sendData: formData, onProgress: onProgress});
    }
    static request(url, opts) {
      let method = opts && 'method' in opts ? opts.method : null;
      let withCredentials = opts && 'withCredentials' in opts ? opts.withCredentials : null;
      let responseType = opts && 'responseType' in opts ? opts.responseType : null;
      let mimeType = opts && 'mimeType' in opts ? opts.mimeType : null;
      let requestHeaders = opts && 'requestHeaders' in opts ? opts.requestHeaders : null;
      let sendData = opts && 'sendData' in opts ? opts.sendData : null;
      let onProgress = opts && 'onProgress' in opts ? opts.onProgress : null;
      let completer = async.Completer$(HttpRequest).new();
      let xhr = HttpRequest.new();
      if (method == null) {
        method = 'GET';
      }
      xhr[dartx.open](method, url, {async: true});
      if (withCredentials != null) {
        xhr[dartx.withCredentials] = withCredentials;
      }
      if (responseType != null) {
        xhr[dartx.responseType] = responseType;
      }
      if (mimeType != null) {
        xhr[dartx.overrideMimeType](mimeType);
      }
      if (requestHeaders != null) {
        requestHeaders[dartx.forEach](dart.fn((header, value) => {
          xhr[dartx.setRequestHeader](header, value);
        }, dart.void, [core.String, core.String]));
      }
      if (onProgress != null) {
        xhr[dartx.onProgress].listen(onProgress);
      }
      xhr[dartx.onLoad].listen(dart.fn(e => {
        let accepted = dart.notNull(xhr[dartx.status]) >= 200 && dart.notNull(xhr[dartx.status]) < 300;
        let fileUri = xhr[dartx.status] == 0;
        let notModified = xhr[dartx.status] == 304;
        let unknownRedirect = dart.notNull(xhr[dartx.status]) > 307 && dart.notNull(xhr[dartx.status]) < 400;
        if (accepted || fileUri || notModified || unknownRedirect) {
          completer.complete(xhr);
        } else {
          completer.completeError(e);
        }
      }, dart.void, [ProgressEvent]));
      xhr[dartx.onError].listen(dart.bind(completer, 'completeError'));
      if (sendData != null) {
        xhr[dartx.send](sendData);
      } else {
        xhr[dartx.send]();
      }
      return completer.future;
    }
    static get supportsProgressEvent() {
      let xhr = HttpRequest.new();
      return "onprogress" in xhr;
    }
    static get supportsCrossOrigin() {
      let xhr = HttpRequest.new();
      return "withCredentials" in xhr;
    }
    static get supportsLoadEndEvent() {
      let xhr = HttpRequest.new();
      return "onloadend" in xhr;
    }
    static get supportsOverrideMimeType() {
      let xhr = HttpRequest.new();
      return "overrideMimeType" in xhr;
    }
    static requestCrossOrigin(url, opts) {
      let method = opts && 'method' in opts ? opts.method : null;
      let sendData = opts && 'sendData' in opts ? opts.sendData : null;
      if (dart.notNull(HttpRequest.supportsCrossOrigin)) {
        return HttpRequest.request(url, {method: method, sendData: sendData}).then(dart.fn(xhr => xhr[dartx.responseText], core.String, [HttpRequest]));
      }
      let completer = async.Completer$(core.String).new();
      if (method == null) {
        method = 'GET';
      }
      let xhr = new XDomainRequest();
      xhr.open(method, url);
      xhr.onload = dart.dcall(/* Unimplemented unknown name */convertDartClosureToJS, dart.fn(e => {
        let response = xhr.responseText;
        completer.complete(response);
      }), 1);
      xhr.onerror = dart.dcall(/* Unimplemented unknown name */convertDartClosureToJS, dart.fn(e => {
        completer.completeError(e);
      }), 1);
      xhr.onprogress = {};
      xhr.ontimeout = {};
      xhr.timeout = Number.MAX_VALUE;
      if (sendData != null) {
        xhr.send(sendData);
      } else {
        xhr.send();
      }
      return completer.future;
    }
    get [dartx.responseHeaders]() {
      let headers = dart.map({}, core.String, core.String);
      let headersString = this[dartx.getAllResponseHeaders]();
      if (headersString == null) {
        return headers;
      }
      let headersList = headersString[dartx.split]('\r\n');
      for (let header of headersList) {
        if (dart.notNull(header[dartx.isEmpty])) {
          continue;
        }
        let splitIdx = header[dartx.indexOf](': ');
        if (splitIdx == -1) {
          continue;
        }
        let key = header[dartx.substring](0, splitIdx)[dartx.toLowerCase]();
        let value = header[dartx.substring](dart.notNull(splitIdx) + 2);
        if (dart.notNull(headers[dartx.containsKey](key))) {
          headers[dartx.set](key, `${headers[dartx.get](key)}, ${value}`);
        } else {
          headers[dartx.set](key, value);
        }
      }
      return headers;
    }
    [dartx.open](method, url, opts) {
      return this.open(method, url, opts);
    }
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return HttpRequest._create_1();
    }
    static _create_1() {
      return dart.as(new XMLHttpRequest(), HttpRequest);
    }
    get [dartx.readyState]() {
      return this.readyState;
    }
    get [dartx.response]() {
      return _convertNativeToDart_XHR_Response(this[_get_response]);
    }
    get [_get_response]() {
      return this.response;
    }
    get [dartx.responseText]() {
      return this.responseText;
    }
    get [dartx.responseType]() {
      return this.responseType;
    }
    set [dartx.responseType](value) {
      this.responseType = value;
    }
    get [dartx.responseUrl]() {
      return this.responseURL;
    }
    get [dartx.responseXml]() {
      return this.responseXML;
    }
    get [dartx.status]() {
      return this.status;
    }
    get [dartx.statusText]() {
      return this.statusText;
    }
    get [dartx.timeout]() {
      return this.timeout;
    }
    set [dartx.timeout](value) {
      this.timeout = value;
    }
    get [dartx.upload]() {
      return this.upload;
    }
    get [dartx.withCredentials]() {
      return this.withCredentials;
    }
    set [dartx.withCredentials](value) {
      this.withCredentials = value;
    }
    [dartx.abort]() {
      return this.abort();
    }
    [dartx.getAllResponseHeaders]() {
      return this.getAllResponseHeaders();
    }
    [dartx.getResponseHeader](header) {
      return this.getResponseHeader(header);
    }
    [dartx.overrideMimeType](override) {
      return this.overrideMimeType(override);
    }
    [dartx.send](data) {
      return this.send(data);
    }
    [dartx.setRequestHeader](header, value) {
      return this.setRequestHeader(header, value);
    }
    get [dartx.onReadyStateChange]() {
      return HttpRequest.readyStateChangeEvent.forTarget(this);
    }
  }
  dart.setSignature(HttpRequest, {
    constructors: () => ({
      _: [HttpRequest, []],
      new: [HttpRequest, []]
    }),
    methods: () => ({
      [dartx.open]: [dart.void, [core.String, core.String], {async: core.bool, user: core.String, password: core.String}],
      [dartx.abort]: [dart.void, []],
      [dartx.getAllResponseHeaders]: [core.String, []],
      [dartx.getResponseHeader]: [core.String, [core.String]],
      [dartx.overrideMimeType]: [dart.void, [core.String]],
      [dartx.send]: [dart.void, [], [dart.dynamic]],
      [dartx.setRequestHeader]: [dart.void, [core.String, core.String]]
    }),
    statics: () => ({
      getString: [async.Future$(core.String), [core.String], {withCredentials: core.bool, onProgress: dart.functionType(dart.void, [ProgressEvent])}],
      postFormData: [async.Future$(HttpRequest), [core.String, core.Map$(core.String, core.String)], {withCredentials: core.bool, responseType: core.String, requestHeaders: core.Map$(core.String, core.String), onProgress: dart.functionType(dart.void, [ProgressEvent])}],
      request: [async.Future$(HttpRequest), [core.String], {method: core.String, withCredentials: core.bool, responseType: core.String, mimeType: core.String, requestHeaders: core.Map$(core.String, core.String), sendData: dart.dynamic, onProgress: dart.functionType(dart.void, [ProgressEvent])}],
      requestCrossOrigin: [async.Future$(core.String), [core.String], {method: core.String, sendData: core.String}],
      _create_1: [HttpRequest, []]
    }),
    names: ['getString', 'postFormData', 'request', 'requestCrossOrigin', '_create_1']
  });
  HttpRequest[dart.metadata] = () => [dart.const(new _metadata.DomName('XMLHttpRequest')), dart.const(new _js_helper.Native("XMLHttpRequest"))];
  HttpRequest.DONE = 4;
  HttpRequest.HEADERS_RECEIVED = 2;
  HttpRequest.LOADING = 3;
  HttpRequest.OPENED = 1;
  HttpRequest.UNSENT = 0;
  dart.defineLazyProperties(HttpRequest, {
    get readyStateChangeEvent() {
      return dart.const(new (EventStreamProvider$(ProgressEvent))('readystatechange'));
    }
  });
  dart.registerExtension(dart.global.XMLHttpRequest, HttpRequest);
  class HttpRequestUpload extends HttpRequestEventTarget {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
  }
  dart.setSignature(HttpRequestUpload, {
    constructors: () => ({_: [HttpRequestUpload, []]})
  });
  HttpRequestUpload[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('XMLHttpRequestUpload')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("XMLHttpRequestUpload"))];
  dart.registerExtension(dart.global.XMLHttpRequestUpload, HttpRequestUpload);
  const _get_contentWindow = Symbol('_get_contentWindow');
  dart.defineExtensionNames([
    'contentWindow',
    'allowFullscreen',
    'height',
    'integrity',
    'name',
    'sandbox',
    'src',
    'srcdoc',
    'width'
  ]);
  class IFrameElement extends HtmlElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return dart.as(exports.document[dartx.createElement]("iframe"), IFrameElement);
    }
    created() {
      this[dartx.allowFullscreen] = null;
      this[_get_contentWindow] = null;
      this[dartx.height] = null;
      this[dartx.integrity] = null;
      this[dartx.name] = null;
      this[dartx.sandbox] = null;
      this[dartx.src] = null;
      this[dartx.srcdoc] = null;
      this[dartx.width] = null;
      super.created();
    }
    get [dartx.allowFullscreen]() {
      return this.allowFullscreen;
    }
    set [dartx.allowFullscreen](value) {
      this.allowFullscreen = value;
    }
    get [dartx.contentWindow]() {
      return _convertNativeToDart_Window(this[_get_contentWindow]);
    }
    get [_get_contentWindow]() {
      return this.contentWindow;
    }
    get [dartx.height]() {
      return this.height;
    }
    set [dartx.height](value) {
      this.height = value;
    }
    get [dartx.integrity]() {
      return this.integrity;
    }
    set [dartx.integrity](value) {
      this.integrity = value;
    }
    get [dartx.name]() {
      return this.name;
    }
    set [dartx.name](value) {
      this.name = value;
    }
    get [dartx.sandbox]() {
      return this.sandbox;
    }
    set [dartx.sandbox](value) {
      this.sandbox = value;
    }
    get [dartx.src]() {
      return this.src;
    }
    set [dartx.src](value) {
      this.src = value;
    }
    get [dartx.srcdoc]() {
      return this.srcdoc;
    }
    set [dartx.srcdoc](value) {
      this.srcdoc = value;
    }
    get [dartx.width]() {
      return this.width;
    }
    set [dartx.width](value) {
      this.width = value;
    }
  }
  dart.defineNamedConstructor(IFrameElement, 'created');
  dart.setSignature(IFrameElement, {
    constructors: () => ({
      _: [IFrameElement, []],
      new: [IFrameElement, []],
      created: [IFrameElement, []]
    })
  });
  IFrameElement[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('HTMLIFrameElement')), dart.const(new _js_helper.Native("HTMLIFrameElement"))];
  dart.registerExtension(dart.global.HTMLIFrameElement, IFrameElement);
  dart.defineExtensionNames([
    'height',
    'width'
  ]);
  class ImageBitmap extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.height]() {
      return this.height;
    }
    get [dartx.width]() {
      return this.width;
    }
  }
  dart.setSignature(ImageBitmap, {
    constructors: () => ({_: [ImageBitmap, []]})
  });
  ImageBitmap[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('ImageBitmap')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("ImageBitmap"))];
  dart.registerExtension(dart.global.ImageBitmap, ImageBitmap);
  dart.defineExtensionNames([
    'data',
    'height',
    'width'
  ]);
  class ImageData extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new(data_OR_width, height_OR_width, height) {
      if (height === void 0) height = null;
      if ((typeof height_OR_width == 'number' || height_OR_width == null) && (typeof data_OR_width == 'number' || data_OR_width == null) && height == null) {
        return ImageData._create_1(data_OR_width, height_OR_width);
      }
      if ((typeof height_OR_width == 'number' || height_OR_width == null) && (dart.is(data_OR_width, typed_data.Uint8ClampedList) || data_OR_width == null) && height == null) {
        return ImageData._create_2(data_OR_width, height_OR_width);
      }
      if ((typeof height == 'number' || height == null) && (typeof height_OR_width == 'number' || height_OR_width == null) && (dart.is(data_OR_width, typed_data.Uint8ClampedList) || data_OR_width == null)) {
        return ImageData._create_3(data_OR_width, height_OR_width, height);
      }
      dart.throw(new core.ArgumentError("Incorrect number or type of arguments"));
    }
    static _create_1(data_OR_width, height_OR_width) {
      return dart.as(new ImageData(data_OR_width, height_OR_width), ImageData);
    }
    static _create_2(data_OR_width, height_OR_width) {
      return dart.as(new ImageData(data_OR_width, height_OR_width), ImageData);
    }
    static _create_3(data_OR_width, height_OR_width, height) {
      return dart.as(new ImageData(data_OR_width, height_OR_width, height), ImageData);
    }
    get [dartx.data]() {
      return this.data;
    }
    get [dartx.height]() {
      return this.height;
    }
    get [dartx.width]() {
      return this.width;
    }
  }
  dart.setSignature(ImageData, {
    constructors: () => ({
      _: [ImageData, []],
      new: [ImageData, [dart.dynamic, core.int], [core.int]]
    }),
    statics: () => ({
      _create_1: [ImageData, [dart.dynamic, dart.dynamic]],
      _create_2: [ImageData, [dart.dynamic, dart.dynamic]],
      _create_3: [ImageData, [dart.dynamic, dart.dynamic, dart.dynamic]]
    }),
    names: ['_create_1', '_create_2', '_create_3']
  });
  ImageData[dart.metadata] = () => [dart.const(new _metadata.DomName('ImageData')), dart.const(new _js_helper.Native("ImageData"))];
  dart.registerExtension(dart.global.ImageData, ImageData);
  dart.defineExtensionNames([
    'alt',
    'complete',
    'crossOrigin',
    'currentSrc',
    'height',
    'integrity',
    'isMap',
    'naturalHeight',
    'naturalWidth',
    'sizes',
    'src',
    'srcset',
    'useMap',
    'width'
  ]);
  class ImageElement extends HtmlElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new(opts) {
      let src = opts && 'src' in opts ? opts.src : null;
      let width = opts && 'width' in opts ? opts.width : null;
      let height = opts && 'height' in opts ? opts.height : null;
      let e = exports.document[dartx.createElement]("img");
      if (src != null) dart.dput(e, 'src', src);
      if (width != null) dart.dput(e, 'width', width);
      if (height != null) dart.dput(e, 'height', height);
      return dart.as(e, ImageElement);
    }
    created() {
      this[dartx.alt] = null;
      this[dartx.complete] = null;
      this[dartx.crossOrigin] = null;
      this[dartx.currentSrc] = null;
      this[dartx.height] = null;
      this[dartx.integrity] = null;
      this[dartx.isMap] = null;
      this[dartx.naturalHeight] = null;
      this[dartx.naturalWidth] = null;
      this[dartx.sizes] = null;
      this[dartx.src] = null;
      this[dartx.srcset] = null;
      this[dartx.useMap] = null;
      this[dartx.width] = null;
      super.created();
    }
    get [dartx.alt]() {
      return this.alt;
    }
    set [dartx.alt](value) {
      this.alt = value;
    }
    get [dartx.complete]() {
      return this.complete;
    }
    get [dartx.crossOrigin]() {
      return this.crossOrigin;
    }
    set [dartx.crossOrigin](value) {
      this.crossOrigin = value;
    }
    get [dartx.currentSrc]() {
      return this.currentSrc;
    }
    get [dartx.height]() {
      return this.height;
    }
    set [dartx.height](value) {
      this.height = value;
    }
    get [dartx.integrity]() {
      return this.integrity;
    }
    set [dartx.integrity](value) {
      this.integrity = value;
    }
    get [dartx.isMap]() {
      return this.isMap;
    }
    set [dartx.isMap](value) {
      this.isMap = value;
    }
    get [dartx.naturalHeight]() {
      return this.naturalHeight;
    }
    get [dartx.naturalWidth]() {
      return this.naturalWidth;
    }
    get [dartx.sizes]() {
      return this.sizes;
    }
    set [dartx.sizes](value) {
      this.sizes = value;
    }
    get [dartx.src]() {
      return this.src;
    }
    set [dartx.src](value) {
      this.src = value;
    }
    get [dartx.srcset]() {
      return this.srcset;
    }
    set [dartx.srcset](value) {
      this.srcset = value;
    }
    get [dartx.useMap]() {
      return this.useMap;
    }
    set [dartx.useMap](value) {
      this.useMap = value;
    }
    get [dartx.width]() {
      return this.width;
    }
    set [dartx.width](value) {
      this.width = value;
    }
  }
  ImageElement[dart.implements] = () => [CanvasImageSource];
  dart.defineNamedConstructor(ImageElement, 'created');
  dart.setSignature(ImageElement, {
    constructors: () => ({
      _: [ImageElement, []],
      new: [ImageElement, [], {src: core.String, width: core.int, height: core.int}],
      created: [ImageElement, []]
    })
  });
  ImageElement[dart.metadata] = () => [dart.const(new _metadata.DomName('HTMLImageElement')), dart.const(new _js_helper.Native("HTMLImageElement"))];
  dart.registerExtension(dart.global.HTMLImageElement, ImageElement);
  dart.defineExtensionNames([
    'inspect'
  ]);
  class InjectedScriptHost extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    [dartx.inspect](objectId, hints) {
      return this.inspect(objectId, hints);
    }
  }
  dart.setSignature(InjectedScriptHost, {
    constructors: () => ({_: [InjectedScriptHost, []]}),
    methods: () => ({[dartx.inspect]: [dart.void, [core.Object, core.Object]]})
  });
  InjectedScriptHost[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('InjectedScriptHost')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("InjectedScriptHost"))];
  dart.registerExtension(dart.global.InjectedScriptHost, InjectedScriptHost);
  const _get_valueAsDate = Symbol('_get_valueAsDate');
  const _set_valueAsDate = Symbol('_set_valueAsDate');
  dart.defineExtensionNames([
    'valueAsDate',
    'valueAsDate',
    'checkValidity',
    'select',
    'setCustomValidity',
    'setRangeText',
    'setSelectionRange',
    'stepDown',
    'stepUp',
    'accept',
    'alt',
    'autocomplete',
    'autofocus',
    'capture',
    'checked',
    'defaultChecked',
    'defaultValue',
    'dirName',
    'disabled',
    'files',
    'form',
    'formAction',
    'formEnctype',
    'formMethod',
    'formNoValidate',
    'formTarget',
    'height',
    'incremental',
    'indeterminate',
    'inputMode',
    'labels',
    'list',
    'max',
    'maxLength',
    'min',
    'multiple',
    'name',
    'pattern',
    'placeholder',
    'readOnly',
    'required',
    'selectionDirection',
    'selectionEnd',
    'selectionStart',
    'size',
    'src',
    'step',
    'type',
    'validationMessage',
    'validity',
    'value',
    'valueAsNumber',
    'entries',
    'directory',
    'width',
    'willValidate'
  ]);
  class InputElement extends HtmlElement {
    static new(opts) {
      let type = opts && 'type' in opts ? opts.type : null;
      let e = exports.document[dartx.createElement]("input");
      if (type != null) {
        try {
          dart.dput(e, 'type', type);
        } catch (_) {
        }

      }
      return dart.as(e, InputElement);
    }
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    created() {
      this[dartx.accept] = null;
      this[dartx.alt] = null;
      this[dartx.autocomplete] = null;
      this[dartx.autofocus] = null;
      this[dartx.capture] = null;
      this[dartx.checked] = null;
      this[dartx.defaultChecked] = null;
      this[dartx.defaultValue] = null;
      this[dartx.dirName] = null;
      this[dartx.disabled] = null;
      this[dartx.files] = null;
      this[dartx.form] = null;
      this[dartx.formAction] = null;
      this[dartx.formEnctype] = null;
      this[dartx.formMethod] = null;
      this[dartx.formNoValidate] = null;
      this[dartx.formTarget] = null;
      this[dartx.height] = null;
      this[dartx.incremental] = null;
      this[dartx.indeterminate] = null;
      this[dartx.inputMode] = null;
      this[dartx.labels] = null;
      this[dartx.list] = null;
      this[dartx.max] = null;
      this[dartx.maxLength] = null;
      this[dartx.min] = null;
      this[dartx.multiple] = null;
      this[dartx.name] = null;
      this[dartx.pattern] = null;
      this[dartx.placeholder] = null;
      this[dartx.readOnly] = null;
      this[dartx.required] = null;
      this[dartx.selectionDirection] = null;
      this[dartx.selectionEnd] = null;
      this[dartx.selectionStart] = null;
      this[dartx.size] = null;
      this[dartx.src] = null;
      this[dartx.step] = null;
      this[dartx.type] = null;
      this[dartx.validationMessage] = null;
      this[dartx.validity] = null;
      this[dartx.value] = null;
      this[_get_valueAsDate] = null;
      this[dartx.valueAsNumber] = null;
      this[dartx.entries] = null;
      this[dartx.directory] = null;
      this[dartx.width] = null;
      this[dartx.willValidate] = null;
      super.created();
    }
    get [dartx.accept]() {
      return this.accept;
    }
    set [dartx.accept](value) {
      this.accept = value;
    }
    get [dartx.alt]() {
      return this.alt;
    }
    set [dartx.alt](value) {
      this.alt = value;
    }
    get [dartx.autocomplete]() {
      return this.autocomplete;
    }
    set [dartx.autocomplete](value) {
      this.autocomplete = value;
    }
    get [dartx.autofocus]() {
      return this.autofocus;
    }
    set [dartx.autofocus](value) {
      this.autofocus = value;
    }
    get [dartx.capture]() {
      return this.capture;
    }
    set [dartx.capture](value) {
      this.capture = value;
    }
    get [dartx.checked]() {
      return this.checked;
    }
    set [dartx.checked](value) {
      this.checked = value;
    }
    get [dartx.defaultChecked]() {
      return this.defaultChecked;
    }
    set [dartx.defaultChecked](value) {
      this.defaultChecked = value;
    }
    get [dartx.defaultValue]() {
      return this.defaultValue;
    }
    set [dartx.defaultValue](value) {
      this.defaultValue = value;
    }
    get [dartx.dirName]() {
      return this.dirName;
    }
    set [dartx.dirName](value) {
      this.dirName = value;
    }
    get [dartx.disabled]() {
      return this.disabled;
    }
    set [dartx.disabled](value) {
      this.disabled = value;
    }
    get [dartx.files]() {
      return this.files;
    }
    set [dartx.files](value) {
      this.files = value;
    }
    get [dartx.form]() {
      return this.form;
    }
    get [dartx.formAction]() {
      return this.formAction;
    }
    set [dartx.formAction](value) {
      this.formAction = value;
    }
    get [dartx.formEnctype]() {
      return this.formEnctype;
    }
    set [dartx.formEnctype](value) {
      this.formEnctype = value;
    }
    get [dartx.formMethod]() {
      return this.formMethod;
    }
    set [dartx.formMethod](value) {
      this.formMethod = value;
    }
    get [dartx.formNoValidate]() {
      return this.formNoValidate;
    }
    set [dartx.formNoValidate](value) {
      this.formNoValidate = value;
    }
    get [dartx.formTarget]() {
      return this.formTarget;
    }
    set [dartx.formTarget](value) {
      this.formTarget = value;
    }
    get [dartx.height]() {
      return this.height;
    }
    set [dartx.height](value) {
      this.height = value;
    }
    get [dartx.incremental]() {
      return this.incremental;
    }
    set [dartx.incremental](value) {
      this.incremental = value;
    }
    get [dartx.indeterminate]() {
      return this.indeterminate;
    }
    set [dartx.indeterminate](value) {
      this.indeterminate = value;
    }
    get [dartx.inputMode]() {
      return this.inputMode;
    }
    set [dartx.inputMode](value) {
      this.inputMode = value;
    }
    get [dartx.labels]() {
      return this.labels;
    }
    get [dartx.list]() {
      return this.list;
    }
    get [dartx.max]() {
      return this.max;
    }
    set [dartx.max](value) {
      this.max = value;
    }
    get [dartx.maxLength]() {
      return this.maxLength;
    }
    set [dartx.maxLength](value) {
      this.maxLength = value;
    }
    get [dartx.min]() {
      return this.min;
    }
    set [dartx.min](value) {
      this.min = value;
    }
    get [dartx.multiple]() {
      return this.multiple;
    }
    set [dartx.multiple](value) {
      this.multiple = value;
    }
    get [dartx.name]() {
      return this.name;
    }
    set [dartx.name](value) {
      this.name = value;
    }
    get [dartx.pattern]() {
      return this.pattern;
    }
    set [dartx.pattern](value) {
      this.pattern = value;
    }
    get [dartx.placeholder]() {
      return this.placeholder;
    }
    set [dartx.placeholder](value) {
      this.placeholder = value;
    }
    get [dartx.readOnly]() {
      return this.readOnly;
    }
    set [dartx.readOnly](value) {
      this.readOnly = value;
    }
    get [dartx.required]() {
      return this.required;
    }
    set [dartx.required](value) {
      this.required = value;
    }
    get [dartx.selectionDirection]() {
      return this.selectionDirection;
    }
    set [dartx.selectionDirection](value) {
      this.selectionDirection = value;
    }
    get [dartx.selectionEnd]() {
      return this.selectionEnd;
    }
    set [dartx.selectionEnd](value) {
      this.selectionEnd = value;
    }
    get [dartx.selectionStart]() {
      return this.selectionStart;
    }
    set [dartx.selectionStart](value) {
      this.selectionStart = value;
    }
    get [dartx.size]() {
      return this.size;
    }
    set [dartx.size](value) {
      this.size = value;
    }
    get [dartx.src]() {
      return this.src;
    }
    set [dartx.src](value) {
      this.src = value;
    }
    get [dartx.step]() {
      return this.step;
    }
    set [dartx.step](value) {
      this.step = value;
    }
    get [dartx.type]() {
      return this.type;
    }
    set [dartx.type](value) {
      this.type = value;
    }
    get [dartx.validationMessage]() {
      return this.validationMessage;
    }
    get [dartx.validity]() {
      return this.validity;
    }
    get [dartx.value]() {
      return this.value;
    }
    set [dartx.value](value) {
      this.value = value;
    }
    get [dartx.valueAsDate]() {
      return html_common.convertNativeToDart_DateTime(this[_get_valueAsDate]);
    }
    get [_get_valueAsDate]() {
      return this.valueAsDate;
    }
    set [dartx.valueAsDate](value) {
      this[_set_valueAsDate] = html_common.convertDartToNative_DateTime(value);
    }
    set [_set_valueAsDate](value) {
      this.valueAsDate = value;
    }
    get [dartx.valueAsNumber]() {
      return this.valueAsNumber;
    }
    set [dartx.valueAsNumber](value) {
      this.valueAsNumber = value;
    }
    get [dartx.entries]() {
      return this.webkitEntries;
    }
    get [dartx.directory]() {
      return this.webkitdirectory;
    }
    set [dartx.directory](value) {
      this.webkitdirectory = value;
    }
    get [dartx.width]() {
      return this.width;
    }
    set [dartx.width](value) {
      this.width = value;
    }
    get [dartx.willValidate]() {
      return this.willValidate;
    }
    [dartx.checkValidity]() {
      return this.checkValidity();
    }
    [dartx.select]() {
      return this.select();
    }
    [dartx.setCustomValidity](error) {
      return this.setCustomValidity(error);
    }
    [dartx.setRangeText](replacement, opts) {
      return this.setRangeText(replacement, opts);
    }
    [dartx.setSelectionRange](start, end, direction) {
      return this.setSelectionRange(start, end, direction);
    }
    [dartx.stepDown](n) {
      return this.stepDown(n);
    }
    [dartx.stepUp](n) {
      return this.stepUp(n);
    }
  }
  InputElement[dart.implements] = () => [HiddenInputElement, SearchInputElement, TextInputElement, UrlInputElement, TelephoneInputElement, EmailInputElement, PasswordInputElement, DateInputElement, MonthInputElement, WeekInputElement, TimeInputElement, LocalDateTimeInputElement, NumberInputElement, RangeInputElement, CheckboxInputElement, RadioButtonInputElement, FileUploadInputElement, SubmitButtonInputElement, ImageButtonInputElement, ResetButtonInputElement, ButtonInputElement];
  dart.defineNamedConstructor(InputElement, 'created');
  dart.setSignature(InputElement, {
    constructors: () => ({
      new: [InputElement, [], {type: core.String}],
      _: [InputElement, []],
      created: [InputElement, []]
    }),
    methods: () => ({
      [dartx.checkValidity]: [core.bool, []],
      [dartx.select]: [dart.void, []],
      [dartx.setCustomValidity]: [dart.void, [core.String]],
      [dartx.setRangeText]: [dart.void, [core.String], {start: core.int, end: core.int, selectionMode: core.String}],
      [dartx.setSelectionRange]: [dart.void, [core.int, core.int], [core.String]],
      [dartx.stepDown]: [dart.void, [], [core.int]],
      [dartx.stepUp]: [dart.void, [], [core.int]]
    })
  });
  InputElement[dart.metadata] = () => [dart.const(new _metadata.DomName('HTMLInputElement')), dart.const(new _js_helper.Native("HTMLInputElement"))];
  dart.registerExtension(dart.global.HTMLInputElement, InputElement);
  dart.defineExtensionNames([
    'autofocus',
    'disabled',
    'incremental',
    'indeterminate',
    'name',
    'value'
  ]);
  class InputElementBase extends core.Object {
    InputElementBase() {
      this[dartx.autofocus] = null;
      this[dartx.disabled] = null;
      this[dartx.incremental] = null;
      this[dartx.indeterminate] = null;
      this[dartx.name] = null;
      this[dartx.value] = null;
    }
    get [dartx.autofocus]() {
      return this.autofocus;
    }
    set [dartx.autofocus](value) {
      this.autofocus = value;
    }
    get [dartx.disabled]() {
      return this.disabled;
    }
    set [dartx.disabled](value) {
      this.disabled = value;
    }
    get [dartx.incremental]() {
      return this.incremental;
    }
    set [dartx.incremental](value) {
      this.incremental = value;
    }
    get [dartx.indeterminate]() {
      return this.indeterminate;
    }
    set [dartx.indeterminate](value) {
      this.indeterminate = value;
    }
    get [dartx.name]() {
      return this.name;
    }
    set [dartx.name](value) {
      this.name = value;
    }
    get [dartx.value]() {
      return this.value;
    }
    set [dartx.value](value) {
      this.value = value;
    }
  }
  InputElementBase[dart.implements] = () => [Element];
  class HiddenInputElement extends core.Object {
    static new() {
      return InputElement.new({type: 'hidden'});
    }
  }
  HiddenInputElement[dart.implements] = () => [InputElementBase];
  dart.setSignature(HiddenInputElement, {
    constructors: () => ({new: [HiddenInputElement, []]})
  });
  dart.defineExtensionNames([
    'autocomplete',
    'maxLength',
    'pattern',
    'placeholder',
    'readOnly',
    'required',
    'size',
    'selectionDirection',
    'selectionEnd',
    'selectionStart'
  ]);
  class TextInputElementBase extends core.Object {
    TextInputElementBase() {
      this[dartx.autocomplete] = null;
      this[dartx.maxLength] = null;
      this[dartx.pattern] = null;
      this[dartx.placeholder] = null;
      this[dartx.readOnly] = null;
      this[dartx.required] = null;
      this[dartx.size] = null;
      this[dartx.selectionDirection] = null;
      this[dartx.selectionEnd] = null;
      this[dartx.selectionStart] = null;
    }
    get [dartx.autocomplete]() {
      return this.autocomplete;
    }
    set [dartx.autocomplete](value) {
      this.autocomplete = value;
    }
    get [dartx.maxLength]() {
      return this.maxLength;
    }
    set [dartx.maxLength](value) {
      this.maxLength = value;
    }
    get [dartx.pattern]() {
      return this.pattern;
    }
    set [dartx.pattern](value) {
      this.pattern = value;
    }
    get [dartx.placeholder]() {
      return this.placeholder;
    }
    set [dartx.placeholder](value) {
      this.placeholder = value;
    }
    get [dartx.readOnly]() {
      return this.readOnly;
    }
    set [dartx.readOnly](value) {
      this.readOnly = value;
    }
    get [dartx.required]() {
      return this.required;
    }
    set [dartx.required](value) {
      this.required = value;
    }
    get [dartx.size]() {
      return this.size;
    }
    set [dartx.size](value) {
      this.size = value;
    }
    get [dartx.selectionDirection]() {
      return this.selectionDirection;
    }
    set [dartx.selectionDirection](value) {
      this.selectionDirection = value;
    }
    get [dartx.selectionEnd]() {
      return this.selectionEnd;
    }
    set [dartx.selectionEnd](value) {
      this.selectionEnd = value;
    }
    get [dartx.selectionStart]() {
      return this.selectionStart;
    }
    set [dartx.selectionStart](value) {
      this.selectionStart = value;
    }
  }
  TextInputElementBase[dart.implements] = () => [InputElementBase];
  dart.defineExtensionNames([
    'dirName'
  ]);
  class SearchInputElement extends core.Object {
    static new() {
      return InputElement.new({type: 'search'});
    }
    get [dartx.dirName]() {
      return this.dirName;
    }
    set [dartx.dirName](value) {
      this.dirName = value;
    }
    static get supported() {
      return InputElement.new({type: 'search'})[dartx.type] == 'search';
    }
  }
  SearchInputElement[dart.implements] = () => [TextInputElementBase];
  dart.setSignature(SearchInputElement, {
    constructors: () => ({new: [SearchInputElement, []]})
  });
  SearchInputElement[dart.metadata] = () => [dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.CHROME)), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.FIREFOX)), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.IE, '10')), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.SAFARI))];
  dart.defineExtensionNames([
    'dirName'
  ]);
  class TextInputElement extends core.Object {
    static new() {
      return InputElement.new({type: 'text'});
    }
    get [dartx.dirName]() {
      return this.dirName;
    }
    set [dartx.dirName](value) {
      this.dirName = value;
    }
  }
  TextInputElement[dart.implements] = () => [TextInputElementBase];
  dart.setSignature(TextInputElement, {
    constructors: () => ({new: [TextInputElement, []]})
  });
  class UrlInputElement extends core.Object {
    static new() {
      return InputElement.new({type: 'url'});
    }
    static get supported() {
      return InputElement.new({type: 'url'})[dartx.type] == 'url';
    }
  }
  UrlInputElement[dart.implements] = () => [TextInputElementBase];
  dart.setSignature(UrlInputElement, {
    constructors: () => ({new: [UrlInputElement, []]})
  });
  UrlInputElement[dart.metadata] = () => [dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.CHROME)), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.FIREFOX)), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.IE, '10')), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.SAFARI))];
  class TelephoneInputElement extends core.Object {
    static new() {
      return InputElement.new({type: 'tel'});
    }
    static get supported() {
      return InputElement.new({type: 'tel'})[dartx.type] == 'tel';
    }
  }
  TelephoneInputElement[dart.implements] = () => [TextInputElementBase];
  dart.setSignature(TelephoneInputElement, {
    constructors: () => ({new: [TelephoneInputElement, []]})
  });
  TelephoneInputElement[dart.metadata] = () => [dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.CHROME)), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.FIREFOX)), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.IE, '10')), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.SAFARI))];
  dart.defineExtensionNames([
    'autocomplete',
    'autofocus',
    'maxLength',
    'multiple',
    'pattern',
    'placeholder',
    'readOnly',
    'required',
    'size'
  ]);
  class EmailInputElement extends core.Object {
    static new() {
      return InputElement.new({type: 'email'});
    }
    get [dartx.autocomplete]() {
      return this.autocomplete;
    }
    set [dartx.autocomplete](value) {
      this.autocomplete = value;
    }
    get [dartx.autofocus]() {
      return this.autofocus;
    }
    set [dartx.autofocus](value) {
      this.autofocus = value;
    }
    get [dartx.maxLength]() {
      return this.maxLength;
    }
    set [dartx.maxLength](value) {
      this.maxLength = value;
    }
    get [dartx.multiple]() {
      return this.multiple;
    }
    set [dartx.multiple](value) {
      this.multiple = value;
    }
    get [dartx.pattern]() {
      return this.pattern;
    }
    set [dartx.pattern](value) {
      this.pattern = value;
    }
    get [dartx.placeholder]() {
      return this.placeholder;
    }
    set [dartx.placeholder](value) {
      this.placeholder = value;
    }
    get [dartx.readOnly]() {
      return this.readOnly;
    }
    set [dartx.readOnly](value) {
      this.readOnly = value;
    }
    get [dartx.required]() {
      return this.required;
    }
    set [dartx.required](value) {
      this.required = value;
    }
    get [dartx.size]() {
      return this.size;
    }
    set [dartx.size](value) {
      this.size = value;
    }
    static get supported() {
      return InputElement.new({type: 'email'})[dartx.type] == 'email';
    }
  }
  EmailInputElement[dart.implements] = () => [TextInputElementBase];
  dart.setSignature(EmailInputElement, {
    constructors: () => ({new: [EmailInputElement, []]})
  });
  EmailInputElement[dart.metadata] = () => [dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.CHROME)), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.FIREFOX)), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.IE, '10')), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.SAFARI))];
  class PasswordInputElement extends core.Object {
    static new() {
      return InputElement.new({type: 'password'});
    }
  }
  PasswordInputElement[dart.implements] = () => [TextInputElementBase];
  dart.setSignature(PasswordInputElement, {
    constructors: () => ({new: [PasswordInputElement, []]})
  });
  dart.defineExtensionNames([
    'max',
    'min',
    'step',
    'valueAsNumber'
  ]);
  class RangeInputElementBase extends core.Object {
    RangeInputElementBase() {
      this[dartx.max] = null;
      this[dartx.min] = null;
      this[dartx.step] = null;
      this[dartx.valueAsNumber] = null;
    }
    get [dartx.max]() {
      return this.max;
    }
    set [dartx.max](value) {
      this.max = value;
    }
    get [dartx.min]() {
      return this.min;
    }
    set [dartx.min](value) {
      this.min = value;
    }
    get [dartx.step]() {
      return this.step;
    }
    set [dartx.step](value) {
      this.step = value;
    }
    get [dartx.valueAsNumber]() {
      return this.valueAsNumber;
    }
    set [dartx.valueAsNumber](value) {
      this.valueAsNumber = value;
    }
  }
  RangeInputElementBase[dart.implements] = () => [InputElementBase];
  dart.defineExtensionNames([
    'valueAsDate',
    'readOnly',
    'required'
  ]);
  class DateInputElement extends core.Object {
    static new() {
      return InputElement.new({type: 'date'});
    }
    get [dartx.valueAsDate]() {
      return this.valueAsDate;
    }
    set [dartx.valueAsDate](value) {
      this.valueAsDate = value;
    }
    get [dartx.readOnly]() {
      return this.readOnly;
    }
    set [dartx.readOnly](value) {
      this.readOnly = value;
    }
    get [dartx.required]() {
      return this.required;
    }
    set [dartx.required](value) {
      this.required = value;
    }
    static get supported() {
      return InputElement.new({type: 'date'})[dartx.type] == 'date';
    }
  }
  DateInputElement[dart.implements] = () => [RangeInputElementBase];
  dart.setSignature(DateInputElement, {
    constructors: () => ({new: [DateInputElement, []]})
  });
  DateInputElement[dart.metadata] = () => [dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.CHROME, '25')), dart.const(new _metadata.Experimental())];
  dart.defineExtensionNames([
    'valueAsDate',
    'readOnly',
    'required'
  ]);
  class MonthInputElement extends core.Object {
    static new() {
      return InputElement.new({type: 'month'});
    }
    get [dartx.valueAsDate]() {
      return this.valueAsDate;
    }
    set [dartx.valueAsDate](value) {
      this.valueAsDate = value;
    }
    get [dartx.readOnly]() {
      return this.readOnly;
    }
    set [dartx.readOnly](value) {
      this.readOnly = value;
    }
    get [dartx.required]() {
      return this.required;
    }
    set [dartx.required](value) {
      this.required = value;
    }
    static get supported() {
      return InputElement.new({type: 'month'})[dartx.type] == 'month';
    }
  }
  MonthInputElement[dart.implements] = () => [RangeInputElementBase];
  dart.setSignature(MonthInputElement, {
    constructors: () => ({new: [MonthInputElement, []]})
  });
  MonthInputElement[dart.metadata] = () => [dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.CHROME, '25')), dart.const(new _metadata.Experimental())];
  dart.defineExtensionNames([
    'valueAsDate',
    'readOnly',
    'required'
  ]);
  class WeekInputElement extends core.Object {
    static new() {
      return InputElement.new({type: 'week'});
    }
    get [dartx.valueAsDate]() {
      return this.valueAsDate;
    }
    set [dartx.valueAsDate](value) {
      this.valueAsDate = value;
    }
    get [dartx.readOnly]() {
      return this.readOnly;
    }
    set [dartx.readOnly](value) {
      this.readOnly = value;
    }
    get [dartx.required]() {
      return this.required;
    }
    set [dartx.required](value) {
      this.required = value;
    }
    static get supported() {
      return InputElement.new({type: 'week'})[dartx.type] == 'week';
    }
  }
  WeekInputElement[dart.implements] = () => [RangeInputElementBase];
  dart.setSignature(WeekInputElement, {
    constructors: () => ({new: [WeekInputElement, []]})
  });
  WeekInputElement[dart.metadata] = () => [dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.CHROME, '25')), dart.const(new _metadata.Experimental())];
  dart.defineExtensionNames([
    'valueAsDate',
    'readOnly',
    'required'
  ]);
  class TimeInputElement extends core.Object {
    static new() {
      return InputElement.new({type: 'time'});
    }
    get [dartx.valueAsDate]() {
      return this.valueAsDate;
    }
    set [dartx.valueAsDate](value) {
      this.valueAsDate = value;
    }
    get [dartx.readOnly]() {
      return this.readOnly;
    }
    set [dartx.readOnly](value) {
      this.readOnly = value;
    }
    get [dartx.required]() {
      return this.required;
    }
    set [dartx.required](value) {
      this.required = value;
    }
    static get supported() {
      return InputElement.new({type: 'time'})[dartx.type] == 'time';
    }
  }
  TimeInputElement[dart.implements] = () => [RangeInputElementBase];
  dart.setSignature(TimeInputElement, {
    constructors: () => ({new: [TimeInputElement, []]})
  });
  TimeInputElement[dart.metadata] = () => [dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.CHROME)), dart.const(new _metadata.Experimental())];
  dart.defineExtensionNames([
    'readOnly',
    'required'
  ]);
  class LocalDateTimeInputElement extends core.Object {
    static new() {
      return InputElement.new({type: 'datetime-local'});
    }
    get [dartx.readOnly]() {
      return this.readOnly;
    }
    set [dartx.readOnly](value) {
      this.readOnly = value;
    }
    get [dartx.required]() {
      return this.required;
    }
    set [dartx.required](value) {
      this.required = value;
    }
    static get supported() {
      return InputElement.new({type: 'datetime-local'})[dartx.type] == 'datetime-local';
    }
  }
  LocalDateTimeInputElement[dart.implements] = () => [RangeInputElementBase];
  dart.setSignature(LocalDateTimeInputElement, {
    constructors: () => ({new: [LocalDateTimeInputElement, []]})
  });
  LocalDateTimeInputElement[dart.metadata] = () => [dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.CHROME, '25')), dart.const(new _metadata.Experimental())];
  dart.defineExtensionNames([
    'placeholder',
    'readOnly',
    'required'
  ]);
  class NumberInputElement extends core.Object {
    static new() {
      return InputElement.new({type: 'number'});
    }
    get [dartx.placeholder]() {
      return this.placeholder;
    }
    set [dartx.placeholder](value) {
      this.placeholder = value;
    }
    get [dartx.readOnly]() {
      return this.readOnly;
    }
    set [dartx.readOnly](value) {
      this.readOnly = value;
    }
    get [dartx.required]() {
      return this.required;
    }
    set [dartx.required](value) {
      this.required = value;
    }
    static get supported() {
      return InputElement.new({type: 'number'})[dartx.type] == 'number';
    }
  }
  NumberInputElement[dart.implements] = () => [RangeInputElementBase];
  dart.setSignature(NumberInputElement, {
    constructors: () => ({new: [NumberInputElement, []]})
  });
  NumberInputElement[dart.metadata] = () => [dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.CHROME)), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.IE)), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.SAFARI)), dart.const(new _metadata.Experimental())];
  class RangeInputElement extends core.Object {
    static new() {
      return InputElement.new({type: 'range'});
    }
    static get supported() {
      return InputElement.new({type: 'range'})[dartx.type] == 'range';
    }
  }
  RangeInputElement[dart.implements] = () => [RangeInputElementBase];
  dart.setSignature(RangeInputElement, {
    constructors: () => ({new: [RangeInputElement, []]})
  });
  RangeInputElement[dart.metadata] = () => [dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.CHROME)), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.IE, '10')), dart.const(new _metadata.Experimental())];
  dart.defineExtensionNames([
    'checked',
    'required'
  ]);
  class CheckboxInputElement extends core.Object {
    static new() {
      return InputElement.new({type: 'checkbox'});
    }
    get [dartx.checked]() {
      return this.checked;
    }
    set [dartx.checked](value) {
      this.checked = value;
    }
    get [dartx.required]() {
      return this.required;
    }
    set [dartx.required](value) {
      this.required = value;
    }
  }
  CheckboxInputElement[dart.implements] = () => [InputElementBase];
  dart.setSignature(CheckboxInputElement, {
    constructors: () => ({new: [CheckboxInputElement, []]})
  });
  dart.defineExtensionNames([
    'checked',
    'required'
  ]);
  class RadioButtonInputElement extends core.Object {
    static new() {
      return InputElement.new({type: 'radio'});
    }
    get [dartx.checked]() {
      return this.checked;
    }
    set [dartx.checked](value) {
      this.checked = value;
    }
    get [dartx.required]() {
      return this.required;
    }
    set [dartx.required](value) {
      this.required = value;
    }
  }
  RadioButtonInputElement[dart.implements] = () => [InputElementBase];
  dart.setSignature(RadioButtonInputElement, {
    constructors: () => ({new: [RadioButtonInputElement, []]})
  });
  dart.defineExtensionNames([
    'accept',
    'multiple',
    'required',
    'files'
  ]);
  class FileUploadInputElement extends core.Object {
    static new() {
      return InputElement.new({type: 'file'});
    }
    get [dartx.accept]() {
      return this.accept;
    }
    set [dartx.accept](value) {
      this.accept = value;
    }
    get [dartx.multiple]() {
      return this.multiple;
    }
    set [dartx.multiple](value) {
      this.multiple = value;
    }
    get [dartx.required]() {
      return this.required;
    }
    set [dartx.required](value) {
      this.required = value;
    }
    get [dartx.files]() {
      return this.files;
    }
    set [dartx.files](value) {
      this.files = value;
    }
  }
  FileUploadInputElement[dart.implements] = () => [InputElementBase];
  dart.setSignature(FileUploadInputElement, {
    constructors: () => ({new: [FileUploadInputElement, []]})
  });
  dart.defineExtensionNames([
    'formAction',
    'formEnctype',
    'formMethod',
    'formNoValidate',
    'formTarget'
  ]);
  class SubmitButtonInputElement extends core.Object {
    static new() {
      return InputElement.new({type: 'submit'});
    }
    get [dartx.formAction]() {
      return this.formAction;
    }
    set [dartx.formAction](value) {
      this.formAction = value;
    }
    get [dartx.formEnctype]() {
      return this.formEnctype;
    }
    set [dartx.formEnctype](value) {
      this.formEnctype = value;
    }
    get [dartx.formMethod]() {
      return this.formMethod;
    }
    set [dartx.formMethod](value) {
      this.formMethod = value;
    }
    get [dartx.formNoValidate]() {
      return this.formNoValidate;
    }
    set [dartx.formNoValidate](value) {
      this.formNoValidate = value;
    }
    get [dartx.formTarget]() {
      return this.formTarget;
    }
    set [dartx.formTarget](value) {
      this.formTarget = value;
    }
  }
  SubmitButtonInputElement[dart.implements] = () => [InputElementBase];
  dart.setSignature(SubmitButtonInputElement, {
    constructors: () => ({new: [SubmitButtonInputElement, []]})
  });
  dart.defineExtensionNames([
    'alt',
    'formAction',
    'formEnctype',
    'formMethod',
    'formNoValidate',
    'formTarget',
    'height',
    'src',
    'width'
  ]);
  class ImageButtonInputElement extends core.Object {
    static new() {
      return InputElement.new({type: 'image'});
    }
    get [dartx.alt]() {
      return this.alt;
    }
    set [dartx.alt](value) {
      this.alt = value;
    }
    get [dartx.formAction]() {
      return this.formAction;
    }
    set [dartx.formAction](value) {
      this.formAction = value;
    }
    get [dartx.formEnctype]() {
      return this.formEnctype;
    }
    set [dartx.formEnctype](value) {
      this.formEnctype = value;
    }
    get [dartx.formMethod]() {
      return this.formMethod;
    }
    set [dartx.formMethod](value) {
      this.formMethod = value;
    }
    get [dartx.formNoValidate]() {
      return this.formNoValidate;
    }
    set [dartx.formNoValidate](value) {
      this.formNoValidate = value;
    }
    get [dartx.formTarget]() {
      return this.formTarget;
    }
    set [dartx.formTarget](value) {
      this.formTarget = value;
    }
    get [dartx.height]() {
      return this.height;
    }
    set [dartx.height](value) {
      this.height = value;
    }
    get [dartx.src]() {
      return this.src;
    }
    set [dartx.src](value) {
      this.src = value;
    }
    get [dartx.width]() {
      return this.width;
    }
    set [dartx.width](value) {
      this.width = value;
    }
  }
  ImageButtonInputElement[dart.implements] = () => [InputElementBase];
  dart.setSignature(ImageButtonInputElement, {
    constructors: () => ({new: [ImageButtonInputElement, []]})
  });
  class ResetButtonInputElement extends core.Object {
    static new() {
      return InputElement.new({type: 'reset'});
    }
  }
  ResetButtonInputElement[dart.implements] = () => [InputElementBase];
  dart.setSignature(ResetButtonInputElement, {
    constructors: () => ({new: [ResetButtonInputElement, []]})
  });
  class ButtonInputElement extends core.Object {
    static new() {
      return InputElement.new({type: 'button'});
    }
  }
  ButtonInputElement[dart.implements] = () => [InputElementBase];
  dart.setSignature(ButtonInputElement, {
    constructors: () => ({new: [ButtonInputElement, []]})
  });
  dart.defineExtensionNames([
    'confirmComposition',
    'compositionEndOffset',
    'compositionStartOffset',
    'locale',
    'target'
  ]);
  class InputMethodContext extends EventTarget {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.compositionEndOffset]() {
      return this.compositionEndOffset;
    }
    get [dartx.compositionStartOffset]() {
      return this.compositionStartOffset;
    }
    get [dartx.locale]() {
      return this.locale;
    }
    get [dartx.target]() {
      return this.target;
    }
    [dartx.confirmComposition]() {
      return this.confirmComposition();
    }
  }
  dart.setSignature(InputMethodContext, {
    constructors: () => ({_: [InputMethodContext, []]}),
    methods: () => ({[dartx.confirmComposition]: [dart.void, []]})
  });
  InputMethodContext[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('InputMethodContext')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("InputMethodContext"))];
  dart.registerExtension(dart.global.InputMethodContext, InputMethodContext);
  dart.defineExtensionNames([
    'reloadAll',
    'replace'
  ]);
  class InstallEvent extends ExtendableEvent {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    [dartx.reloadAll]() {
      return this.reloadAll();
    }
    [dartx.replace]() {
      return this.replace();
    }
  }
  dart.setSignature(InstallEvent, {
    constructors: () => ({_: [InstallEvent, []]}),
    methods: () => ({
      [dartx.reloadAll]: [async.Future, []],
      [dartx.replace]: [dart.void, []]
    })
  });
  InstallEvent[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('InstallEvent')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("InstallEvent"))];
  dart.registerExtension(dart.global.InstallEvent, InstallEvent);
  const _initKeyboardEvent = Symbol('_initKeyboardEvent');
  const _keyIdentifier = Symbol('_keyIdentifier');
  dart.defineExtensionNames([
    'keyCode',
    'charCode',
    'getModifierState',
    'altKey',
    'ctrlKey',
    'keyLocation',
    'location',
    'metaKey',
    'repeat',
    'shiftKey'
  ]);
  class KeyboardEvent extends UIEvent {
    static new(type, opts) {
      let view = opts && 'view' in opts ? opts.view : null;
      let canBubble = opts && 'canBubble' in opts ? opts.canBubble : true;
      let cancelable = opts && 'cancelable' in opts ? opts.cancelable : true;
      let keyLocation = opts && 'keyLocation' in opts ? opts.keyLocation : 1;
      let ctrlKey = opts && 'ctrlKey' in opts ? opts.ctrlKey : false;
      let altKey = opts && 'altKey' in opts ? opts.altKey : false;
      let shiftKey = opts && 'shiftKey' in opts ? opts.shiftKey : false;
      let metaKey = opts && 'metaKey' in opts ? opts.metaKey : false;
      if (view == null) {
        view = exports.window;
      }
      let e = exports.document[_createEvent]("KeyboardEvent");
      dart.dcall(e[_initKeyboardEvent], type, canBubble, cancelable, view, "", keyLocation, ctrlKey, altKey, shiftKey, metaKey);
      return dart.as(e, KeyboardEvent);
    }
    [_initKeyboardEvent](type, canBubble, cancelable, view, keyIdentifier, keyLocation, ctrlKey, altKey, shiftKey, metaKey) {
      if (typeof this.initKeyEvent == "function") {
        this.initKeyEvent(type, canBubble, cancelable, view, ctrlKey, altKey, shiftKey, metaKey, 0, 0);
      } else {
        this.initKeyboardEvent(type, canBubble, cancelable, view, keyIdentifier, keyLocation, ctrlKey, altKey, shiftKey, metaKey);
      }
    }
    get [dartx.keyCode]() {
      return this[_keyCode];
    }
    get [dartx.charCode]() {
      return this[_charCode];
    }
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.altKey]() {
      return this.altKey;
    }
    get [dartx.ctrlKey]() {
      return this.ctrlKey;
    }
    get [_keyIdentifier]() {
      return this.keyIdentifier;
    }
    get [dartx.keyLocation]() {
      return this.keyLocation;
    }
    get [dartx.location]() {
      return this.location;
    }
    get [dartx.metaKey]() {
      return this.metaKey;
    }
    get [dartx.repeat]() {
      return this.repeat;
    }
    get [dartx.shiftKey]() {
      return this.shiftKey;
    }
    [dartx.getModifierState](keyArgument) {
      return this.getModifierState(keyArgument);
    }
  }
  dart.setSignature(KeyboardEvent, {
    constructors: () => ({
      new: [KeyboardEvent, [core.String], {view: Window, canBubble: core.bool, cancelable: core.bool, keyLocation: core.int, ctrlKey: core.bool, altKey: core.bool, shiftKey: core.bool, metaKey: core.bool}],
      _: [KeyboardEvent, []]
    }),
    methods: () => ({
      [_initKeyboardEvent]: [dart.void, [core.String, core.bool, core.bool, Window, core.String, core.int, core.bool, core.bool, core.bool, core.bool]],
      [dartx.getModifierState]: [core.bool, [core.String]]
    })
  });
  KeyboardEvent[dart.metadata] = () => [dart.const(new _metadata.DomName('KeyboardEvent')), dart.const(new _js_helper.Native("KeyboardEvent"))];
  KeyboardEvent.DOM_KEY_LOCATION_LEFT = 1;
  KeyboardEvent.DOM_KEY_LOCATION_NUMPAD = 3;
  KeyboardEvent.DOM_KEY_LOCATION_RIGHT = 2;
  KeyboardEvent.DOM_KEY_LOCATION_STANDARD = 0;
  dart.registerExtension(dart.global.KeyboardEvent, KeyboardEvent);
  dart.defineExtensionNames([
    'checkValidity',
    'setCustomValidity',
    'autofocus',
    'challenge',
    'disabled',
    'form',
    'keytype',
    'labels',
    'name',
    'type',
    'validationMessage',
    'validity',
    'willValidate'
  ]);
  class KeygenElement extends HtmlElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return dart.as(exports.document[dartx.createElement]("keygen"), KeygenElement);
    }
    created() {
      this[dartx.autofocus] = null;
      this[dartx.challenge] = null;
      this[dartx.disabled] = null;
      this[dartx.form] = null;
      this[dartx.keytype] = null;
      this[dartx.labels] = null;
      this[dartx.name] = null;
      this[dartx.type] = null;
      this[dartx.validationMessage] = null;
      this[dartx.validity] = null;
      this[dartx.willValidate] = null;
      super.created();
    }
    static get supported() {
      return dart.notNull(Element.isTagSupported('keygen')) && dart.is(Element.tag('keygen'), KeygenElement);
    }
    get [dartx.autofocus]() {
      return this.autofocus;
    }
    set [dartx.autofocus](value) {
      this.autofocus = value;
    }
    get [dartx.challenge]() {
      return this.challenge;
    }
    set [dartx.challenge](value) {
      this.challenge = value;
    }
    get [dartx.disabled]() {
      return this.disabled;
    }
    set [dartx.disabled](value) {
      this.disabled = value;
    }
    get [dartx.form]() {
      return this.form;
    }
    get [dartx.keytype]() {
      return this.keytype;
    }
    set [dartx.keytype](value) {
      this.keytype = value;
    }
    get [dartx.labels]() {
      return this.labels;
    }
    get [dartx.name]() {
      return this.name;
    }
    set [dartx.name](value) {
      this.name = value;
    }
    get [dartx.type]() {
      return this.type;
    }
    get [dartx.validationMessage]() {
      return this.validationMessage;
    }
    get [dartx.validity]() {
      return this.validity;
    }
    get [dartx.willValidate]() {
      return this.willValidate;
    }
    [dartx.checkValidity]() {
      return this.checkValidity();
    }
    [dartx.setCustomValidity](error) {
      return this.setCustomValidity(error);
    }
  }
  dart.defineNamedConstructor(KeygenElement, 'created');
  dart.setSignature(KeygenElement, {
    constructors: () => ({
      _: [KeygenElement, []],
      new: [KeygenElement, []],
      created: [KeygenElement, []]
    }),
    methods: () => ({
      [dartx.checkValidity]: [core.bool, []],
      [dartx.setCustomValidity]: [dart.void, [core.String]]
    })
  });
  KeygenElement[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('HTMLKeygenElement')), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.CHROME)), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.SAFARI)), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("HTMLKeygenElement"))];
  dart.registerExtension(dart.global.HTMLKeygenElement, KeygenElement);
  dart.defineExtensionNames([
    'value'
  ]);
  class LIElement extends HtmlElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return dart.as(exports.document[dartx.createElement]("li"), LIElement);
    }
    created() {
      this[dartx.value] = null;
      super.created();
    }
    get [dartx.value]() {
      return this.value;
    }
    set [dartx.value](value) {
      this.value = value;
    }
  }
  dart.defineNamedConstructor(LIElement, 'created');
  dart.setSignature(LIElement, {
    constructors: () => ({
      _: [LIElement, []],
      new: [LIElement, []],
      created: [LIElement, []]
    })
  });
  LIElement[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('HTMLLIElement')), dart.const(new _js_helper.Native("HTMLLIElement"))];
  dart.registerExtension(dart.global.HTMLLIElement, LIElement);
  dart.defineExtensionNames([
    'control',
    'form',
    'htmlFor'
  ]);
  class LabelElement extends HtmlElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return dart.as(exports.document[dartx.createElement]("label"), LabelElement);
    }
    created() {
      this[dartx.control] = null;
      this[dartx.form] = null;
      this[dartx.htmlFor] = null;
      super.created();
    }
    get [dartx.control]() {
      return this.control;
    }
    get [dartx.form]() {
      return this.form;
    }
    get [dartx.htmlFor]() {
      return this.htmlFor;
    }
    set [dartx.htmlFor](value) {
      this.htmlFor = value;
    }
  }
  dart.defineNamedConstructor(LabelElement, 'created');
  dart.setSignature(LabelElement, {
    constructors: () => ({
      _: [LabelElement, []],
      new: [LabelElement, []],
      created: [LabelElement, []]
    })
  });
  LabelElement[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('HTMLLabelElement')), dart.const(new _js_helper.Native("HTMLLabelElement"))];
  dart.registerExtension(dart.global.HTMLLabelElement, LabelElement);
  dart.defineExtensionNames([
    'form'
  ]);
  class LegendElement extends HtmlElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return dart.as(exports.document[dartx.createElement]("legend"), LegendElement);
    }
    created() {
      this[dartx.form] = null;
      super.created();
    }
    get [dartx.form]() {
      return this.form;
    }
  }
  dart.defineNamedConstructor(LegendElement, 'created');
  dart.setSignature(LegendElement, {
    constructors: () => ({
      _: [LegendElement, []],
      new: [LegendElement, []],
      created: [LegendElement, []]
    })
  });
  LegendElement[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('HTMLLegendElement')), dart.const(new _js_helper.Native("HTMLLegendElement"))];
  dart.registerExtension(dart.global.HTMLLegendElement, LegendElement);
  dart.defineExtensionNames([
    'supportsImport',
    'crossOrigin',
    'disabled',
    'href',
    'hreflang',
    'import',
    'integrity',
    'media',
    'rel',
    'sheet',
    'sizes',
    'type'
  ]);
  class LinkElement extends HtmlElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return dart.as(exports.document[dartx.createElement]("link"), LinkElement);
    }
    created() {
      this[dartx.crossOrigin] = null;
      this[dartx.disabled] = null;
      this[dartx.href] = null;
      this[dartx.hreflang] = null;
      this[dartx.import] = null;
      this[dartx.integrity] = null;
      this[dartx.media] = null;
      this[dartx.rel] = null;
      this[dartx.sheet] = null;
      this[dartx.sizes] = null;
      this[dartx.type] = null;
      super.created();
    }
    get [dartx.crossOrigin]() {
      return this.crossOrigin;
    }
    set [dartx.crossOrigin](value) {
      this.crossOrigin = value;
    }
    get [dartx.disabled]() {
      return this.disabled;
    }
    set [dartx.disabled](value) {
      this.disabled = value;
    }
    get [dartx.href]() {
      return this.href;
    }
    set [dartx.href](value) {
      this.href = value;
    }
    get [dartx.hreflang]() {
      return this.hreflang;
    }
    set [dartx.hreflang](value) {
      this.hreflang = value;
    }
    get [dartx.import]() {
      return this.import;
    }
    get [dartx.integrity]() {
      return this.integrity;
    }
    set [dartx.integrity](value) {
      this.integrity = value;
    }
    get [dartx.media]() {
      return this.media;
    }
    set [dartx.media](value) {
      this.media = value;
    }
    get [dartx.rel]() {
      return this.rel;
    }
    set [dartx.rel](value) {
      this.rel = value;
    }
    get [dartx.sheet]() {
      return this.sheet;
    }
    get [dartx.sizes]() {
      return this.sizes;
    }
    get [dartx.type]() {
      return this.type;
    }
    set [dartx.type](value) {
      this.type = value;
    }
    get [dartx.supportsImport]() {
      return "import" in this;
    }
  }
  dart.defineNamedConstructor(LinkElement, 'created');
  dart.setSignature(LinkElement, {
    constructors: () => ({
      _: [LinkElement, []],
      new: [LinkElement, []],
      created: [LinkElement, []]
    })
  });
  LinkElement[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('HTMLLinkElement')), dart.const(new _js_helper.Native("HTMLLinkElement"))];
  dart.registerExtension(dart.global.HTMLLinkElement, LinkElement);
  dart.defineExtensionNames([
    'password'
  ]);
  class LocalCredential extends Credential {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new(id, name, avatarURL, password) {
      return LocalCredential._create_1(id, name, avatarURL, password);
    }
    static _create_1(id, name, avatarURL, password) {
      return dart.as(new LocalCredential(id, name, avatarURL, password), LocalCredential);
    }
    get [dartx.password]() {
      return this.password;
    }
  }
  dart.setSignature(LocalCredential, {
    constructors: () => ({
      _: [LocalCredential, []],
      new: [LocalCredential, [core.String, core.String, core.String, core.String]]
    }),
    statics: () => ({_create_1: [LocalCredential, [dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic]]}),
    names: ['_create_1']
  });
  LocalCredential[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('LocalCredential')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("LocalCredential"))];
  dart.registerExtension(dart.global.LocalCredential, LocalCredential);
  dart.defineExtensionNames([
    'assign',
    'reload',
    'replace',
    'origin',
    'toString',
    'ancestorOrigins',
    'hash',
    'host',
    'hostname',
    'href',
    'pathname',
    'port',
    'protocol',
    'search'
  ]);
  class Location extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.ancestorOrigins]() {
      return this.ancestorOrigins;
    }
    get [dartx.hash]() {
      return this.hash;
    }
    set [dartx.hash](value) {
      this.hash = value;
    }
    get [dartx.host]() {
      return this.host;
    }
    set [dartx.host](value) {
      this.host = value;
    }
    get [dartx.hostname]() {
      return this.hostname;
    }
    set [dartx.hostname](value) {
      this.hostname = value;
    }
    get [dartx.href]() {
      return this.href;
    }
    set [dartx.href](value) {
      this.href = value;
    }
    get [dartx.pathname]() {
      return this.pathname;
    }
    set [dartx.pathname](value) {
      this.pathname = value;
    }
    get [dartx.port]() {
      return this.port;
    }
    set [dartx.port](value) {
      this.port = value;
    }
    get [dartx.protocol]() {
      return this.protocol;
    }
    set [dartx.protocol](value) {
      this.protocol = value;
    }
    get [dartx.search]() {
      return this.search;
    }
    set [dartx.search](value) {
      this.search = value;
    }
    [dartx.assign](url) {
      return this.assign(url);
    }
    [dartx.reload]() {
      return this.reload();
    }
    [dartx.replace](url) {
      return this.replace(url);
    }
    get [dartx.origin]() {
      if ("origin" in this) {
        return this.origin;
      }
      return `${this[dartx.protocol]}//${this[dartx.host]}`;
    }
    toString() {
      return String(this);
    }
  }
  Location[dart.implements] = () => [LocationBase];
  dart.setSignature(Location, {
    constructors: () => ({_: [Location, []]}),
    methods: () => ({
      [dartx.assign]: [dart.void, [], [core.String]],
      [dartx.reload]: [dart.void, []],
      [dartx.replace]: [dart.void, [core.String]]
    })
  });
  Location[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('Location')), dart.const(new _js_helper.Native("Location"))];
  dart.registerExtension(dart.global.Location, Location);
  const MidiErrorCallback = dart.typedef('MidiErrorCallback', () => dart.functionType(dart.void, [DomError]));
  const MidiSuccessCallback = dart.typedef('MidiSuccessCallback', () => dart.functionType(dart.void, [MidiAccess, core.bool]));
  dart.defineExtensionNames([
    'areas',
    'name'
  ]);
  class MapElement extends HtmlElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return dart.as(exports.document[dartx.createElement]("map"), MapElement);
    }
    created() {
      this[dartx.areas] = null;
      this[dartx.name] = null;
      super.created();
    }
    get [dartx.areas]() {
      return this.areas;
    }
    get [dartx.name]() {
      return this.name;
    }
    set [dartx.name](value) {
      this.name = value;
    }
  }
  dart.defineNamedConstructor(MapElement, 'created');
  dart.setSignature(MapElement, {
    constructors: () => ({
      _: [MapElement, []],
      new: [MapElement, []],
      created: [MapElement, []]
    })
  });
  MapElement[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('HTMLMapElement')), dart.const(new _js_helper.Native("HTMLMapElement"))];
  dart.registerExtension(dart.global.HTMLMapElement, MapElement);
  dart.defineExtensionNames([
    'pause',
    'play',
    'unpause',
    'buffered',
    'currentTime',
    'defaultPlaybackRate',
    'duration',
    'muted',
    'paused',
    'playbackRate',
    'playbackState',
    'played',
    'seekable',
    'volume'
  ]);
  class MediaController extends EventTarget {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return MediaController._create_1();
    }
    static _create_1() {
      return dart.as(new MediaController(), MediaController);
    }
    get [dartx.buffered]() {
      return this.buffered;
    }
    get [dartx.currentTime]() {
      return this.currentTime;
    }
    set [dartx.currentTime](value) {
      this.currentTime = value;
    }
    get [dartx.defaultPlaybackRate]() {
      return this.defaultPlaybackRate;
    }
    set [dartx.defaultPlaybackRate](value) {
      this.defaultPlaybackRate = value;
    }
    get [dartx.duration]() {
      return this.duration;
    }
    get [dartx.muted]() {
      return this.muted;
    }
    set [dartx.muted](value) {
      this.muted = value;
    }
    get [dartx.paused]() {
      return this.paused;
    }
    get [dartx.playbackRate]() {
      return this.playbackRate;
    }
    set [dartx.playbackRate](value) {
      this.playbackRate = value;
    }
    get [dartx.playbackState]() {
      return this.playbackState;
    }
    get [dartx.played]() {
      return this.played;
    }
    get [dartx.seekable]() {
      return this.seekable;
    }
    get [dartx.volume]() {
      return this.volume;
    }
    set [dartx.volume](value) {
      this.volume = value;
    }
    [dartx.pause]() {
      return this.pause();
    }
    [dartx.play]() {
      return this.play();
    }
    [dartx.unpause]() {
      return this.unpause();
    }
  }
  dart.setSignature(MediaController, {
    constructors: () => ({
      _: [MediaController, []],
      new: [MediaController, []]
    }),
    methods: () => ({
      [dartx.pause]: [dart.void, []],
      [dartx.play]: [dart.void, []],
      [dartx.unpause]: [dart.void, []]
    }),
    statics: () => ({_create_1: [MediaController, []]}),
    names: ['_create_1']
  });
  MediaController[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('MediaController')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("MediaController"))];
  dart.registerExtension(dart.global.MediaController, MediaController);
  dart.defineExtensionNames([
    'deviceId',
    'groupId',
    'kind',
    'label'
  ]);
  class MediaDeviceInfo extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.deviceId]() {
      return this.deviceId;
    }
    get [dartx.groupId]() {
      return this.groupId;
    }
    get [dartx.kind]() {
      return this.kind;
    }
    get [dartx.label]() {
      return this.label;
    }
  }
  dart.setSignature(MediaDeviceInfo, {
    constructors: () => ({_: [MediaDeviceInfo, []]})
  });
  MediaDeviceInfo[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('MediaDeviceInfo')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("MediaDeviceInfo"))];
  dart.registerExtension(dart.global.MediaDeviceInfo, MediaDeviceInfo);
  const MediaDeviceInfoCallback = dart.typedef('MediaDeviceInfoCallback', () => dart.functionType(dart.void, [core.List$(MediaDeviceInfo)]));
  dart.defineExtensionNames([
    'code'
  ]);
  class MediaError extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.code]() {
      return this.code;
    }
  }
  dart.setSignature(MediaError, {
    constructors: () => ({_: [MediaError, []]})
  });
  MediaError[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('MediaError')), dart.const(new _metadata.Unstable()), dart.const(new _js_helper.Native("MediaError"))];
  MediaError.MEDIA_ERR_ABORTED = 1;
  MediaError.MEDIA_ERR_DECODE = 3;
  MediaError.MEDIA_ERR_ENCRYPTED = 5;
  MediaError.MEDIA_ERR_NETWORK = 2;
  MediaError.MEDIA_ERR_SRC_NOT_SUPPORTED = 4;
  dart.registerExtension(dart.global.MediaError, MediaError);
  dart.defineExtensionNames([
    'code',
    'systemCode'
  ]);
  class MediaKeyError extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.code]() {
      return this.code;
    }
    get [dartx.systemCode]() {
      return this.systemCode;
    }
  }
  dart.setSignature(MediaKeyError, {
    constructors: () => ({_: [MediaKeyError, []]})
  });
  MediaKeyError[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('MediaKeyError')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("MediaKeyError"))];
  MediaKeyError.MEDIA_KEYERR_CLIENT = 2;
  MediaKeyError.MEDIA_KEYERR_DOMAIN = 6;
  MediaKeyError.MEDIA_KEYERR_HARDWARECHANGE = 5;
  MediaKeyError.MEDIA_KEYERR_OUTPUT = 4;
  MediaKeyError.MEDIA_KEYERR_SERVICE = 3;
  MediaKeyError.MEDIA_KEYERR_UNKNOWN = 1;
  dart.registerExtension(dart.global.MediaKeyError, MediaKeyError);
  dart.defineExtensionNames([
    'defaultUrl',
    'errorCode',
    'initData',
    'keySystem',
    'message',
    'sessionId',
    'systemCode'
  ]);
  class MediaKeyEvent extends Event {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.defaultUrl]() {
      return this.defaultURL;
    }
    get [dartx.errorCode]() {
      return this.errorCode;
    }
    get [dartx.initData]() {
      return this.initData;
    }
    get [dartx.keySystem]() {
      return this.keySystem;
    }
    get [dartx.message]() {
      return this.message;
    }
    get [dartx.sessionId]() {
      return this.sessionId;
    }
    get [dartx.systemCode]() {
      return this.systemCode;
    }
  }
  dart.setSignature(MediaKeyEvent, {
    constructors: () => ({_: [MediaKeyEvent, []]})
  });
  MediaKeyEvent[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('MediaKeyEvent')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("MediaKeyEvent"))];
  dart.registerExtension(dart.global.MediaKeyEvent, MediaKeyEvent);
  dart.defineExtensionNames([
    'destinationUrl',
    'message'
  ]);
  class MediaKeyMessageEvent extends Event {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.destinationUrl]() {
      return this.destinationURL;
    }
    get [dartx.message]() {
      return this.message;
    }
  }
  dart.setSignature(MediaKeyMessageEvent, {
    constructors: () => ({_: [MediaKeyMessageEvent, []]})
  });
  MediaKeyMessageEvent[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('MediaKeyMessageEvent')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("MediaKeyMessageEvent"))];
  dart.registerExtension(dart.global.MediaKeyMessageEvent, MediaKeyMessageEvent);
  dart.defineExtensionNames([
    'contentType',
    'initData'
  ]);
  class MediaKeyNeededEvent extends Event {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.contentType]() {
      return this.contentType;
    }
    get [dartx.initData]() {
      return this.initData;
    }
  }
  dart.setSignature(MediaKeyNeededEvent, {
    constructors: () => ({_: [MediaKeyNeededEvent, []]})
  });
  MediaKeyNeededEvent[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('MediaKeyNeededEvent')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("MediaKeyNeededEvent"))];
  dart.registerExtension(dart.global.MediaKeyNeededEvent, MediaKeyNeededEvent);
  const _update = Symbol('_update');
  dart.defineExtensionNames([
    'generateRequest',
    'release',
    'closed',
    'error',
    'keySystem',
    'sessionId'
  ]);
  class MediaKeySession extends EventTarget {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.closed]() {
      return this.closed;
    }
    get [dartx.error]() {
      return this.error;
    }
    get [dartx.keySystem]() {
      return this.keySystem;
    }
    get [dartx.sessionId]() {
      return this.sessionId;
    }
    [dartx.generateRequest](initDataType, initData) {
      return this.generateRequest(initDataType, initData);
    }
    [dartx.release]() {
      return this.release();
    }
    [_update](response) {
      return this.update(response);
    }
  }
  dart.setSignature(MediaKeySession, {
    constructors: () => ({_: [MediaKeySession, []]}),
    methods: () => ({
      [dartx.generateRequest]: [async.Future, [core.String, dart.dynamic]],
      [dartx.release]: [async.Future, []],
      [_update]: [async.Future, [dart.dynamic]]
    })
  });
  MediaKeySession[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('MediaKeySession')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("MediaKeySession"))];
  dart.registerExtension(dart.global.MediaKeySession, MediaKeySession);
  const _createSession = Symbol('_createSession');
  dart.defineExtensionNames([
    'keySystem'
  ]);
  class MediaKeys extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.keySystem]() {
      return this.keySystem;
    }
    [_createSession](sessionType) {
      return this.createSession(sessionType);
    }
  }
  dart.setSignature(MediaKeys, {
    constructors: () => ({_: [MediaKeys, []]}),
    methods: () => ({[_createSession]: [MediaKeySession, [], [core.String]]}),
    statics: () => ({
      create: [async.Future, [core.String]],
      isTypeSupported: [core.bool, [core.String, core.String]]
    }),
    names: ['create', 'isTypeSupported']
  });
  MediaKeys[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('MediaKeys')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("MediaKeys"))];
  dart.registerExtension(dart.global.MediaKeys, MediaKeys);
  dart.defineExtensionNames([
    'appendMedium',
    'deleteMedium',
    'item',
    'length',
    'mediaText'
  ]);
  class MediaList extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.length]() {
      return this.length;
    }
    get [dartx.mediaText]() {
      return this.mediaText;
    }
    set [dartx.mediaText](value) {
      this.mediaText = value;
    }
    [dartx.appendMedium](newMedium) {
      return this.appendMedium(newMedium);
    }
    [dartx.deleteMedium](oldMedium) {
      return this.deleteMedium(oldMedium);
    }
    [dartx.item](index) {
      return this.item(index);
    }
  }
  dart.setSignature(MediaList, {
    constructors: () => ({_: [MediaList, []]}),
    methods: () => ({
      [dartx.appendMedium]: [dart.void, [core.String]],
      [dartx.deleteMedium]: [dart.void, [core.String]],
      [dartx.item]: [core.String, [core.int]]
    })
  });
  MediaList[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('MediaList')), dart.const(new _metadata.Unstable()), dart.const(new _js_helper.Native("MediaList"))];
  dart.registerExtension(dart.global.MediaList, MediaList);
  dart.defineExtensionNames([
    'addListener',
    'removeListener',
    'onChange',
    'matches',
    'media'
  ]);
  class MediaQueryList extends EventTarget {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.matches]() {
      return this.matches;
    }
    get [dartx.media]() {
      return this.media;
    }
    [dartx.addListener](listener) {
      return this.addListener(listener);
    }
    [dartx.removeListener](listener) {
      return this.removeListener(listener);
    }
    get [dartx.onChange]() {
      return MediaQueryList.changeEvent.forTarget(this);
    }
  }
  dart.setSignature(MediaQueryList, {
    constructors: () => ({_: [MediaQueryList, []]}),
    methods: () => ({
      [dartx.addListener]: [dart.void, [EventListener]],
      [dartx.removeListener]: [dart.void, [EventListener]]
    })
  });
  MediaQueryList[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('MediaQueryList')), dart.const(new _metadata.Unstable()), dart.const(new _js_helper.Native("MediaQueryList"))];
  dart.defineLazyProperties(MediaQueryList, {
    get changeEvent() {
      return dart.const(new (EventStreamProvider$(Event))('change'));
    }
  });
  dart.registerExtension(dart.global.MediaQueryList, MediaQueryList);
  dart.defineExtensionNames([
    'matches',
    'media'
  ]);
  class MediaQueryListEvent extends Event {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.matches]() {
      return this.matches;
    }
    get [dartx.media]() {
      return this.media;
    }
  }
  dart.setSignature(MediaQueryListEvent, {
    constructors: () => ({_: [MediaQueryListEvent, []]})
  });
  MediaQueryListEvent[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('MediaQueryListEvent')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("MediaQueryListEvent"))];
  dart.registerExtension(dart.global.MediaQueryListEvent, MediaQueryListEvent);
  dart.defineExtensionNames([
    'addSourceBuffer',
    'endOfStream',
    'removeSourceBuffer',
    'activeSourceBuffers',
    'duration',
    'readyState',
    'sourceBuffers'
  ]);
  class MediaSource extends EventTarget {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return MediaSource._create_1();
    }
    static _create_1() {
      return dart.as(new MediaSource(), MediaSource);
    }
    static get supported() {
      return !!window.MediaSource;
    }
    get [dartx.activeSourceBuffers]() {
      return this.activeSourceBuffers;
    }
    get [dartx.duration]() {
      return this.duration;
    }
    set [dartx.duration](value) {
      this.duration = value;
    }
    get [dartx.readyState]() {
      return this.readyState;
    }
    get [dartx.sourceBuffers]() {
      return this.sourceBuffers;
    }
    [dartx.addSourceBuffer](type) {
      return this.addSourceBuffer(type);
    }
    [dartx.endOfStream](error) {
      return this.endOfStream(error);
    }
    [dartx.removeSourceBuffer](buffer) {
      return this.removeSourceBuffer(buffer);
    }
  }
  dart.setSignature(MediaSource, {
    constructors: () => ({
      _: [MediaSource, []],
      new: [MediaSource, []]
    }),
    methods: () => ({
      [dartx.addSourceBuffer]: [SourceBuffer, [core.String]],
      [dartx.endOfStream]: [dart.void, [], [core.String]],
      [dartx.removeSourceBuffer]: [dart.void, [SourceBuffer]]
    }),
    statics: () => ({
      _create_1: [MediaSource, []],
      isTypeSupported: [core.bool, [core.String]]
    }),
    names: ['_create_1', 'isTypeSupported']
  });
  MediaSource[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('MediaSource')), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.CHROME)), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.IE, '11')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("MediaSource"))];
  dart.registerExtension(dart.global.MediaSource, MediaSource);
  dart.defineExtensionNames([
    'addTrack',
    'clone',
    'getAudioTracks',
    'getTrackById',
    'getTracks',
    'getVideoTracks',
    'removeTrack',
    'stop',
    'onAddTrack',
    'onEnded',
    'onRemoveTrack',
    'ended',
    'id',
    'label'
  ]);
  class MediaStream extends EventTarget {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new(stream_OR_tracks) {
      if (stream_OR_tracks === void 0) stream_OR_tracks = null;
      if (stream_OR_tracks == null) {
        return MediaStream._create_1();
      }
      if (dart.is(stream_OR_tracks, MediaStream) || stream_OR_tracks == null) {
        return MediaStream._create_2(stream_OR_tracks);
      }
      if (dart.is(stream_OR_tracks, core.List$(MediaStreamTrack)) || stream_OR_tracks == null) {
        return MediaStream._create_3(stream_OR_tracks);
      }
      dart.throw(new core.ArgumentError("Incorrect number or type of arguments"));
    }
    static _create_1() {
      return dart.as(new MediaStream(), MediaStream);
    }
    static _create_2(stream_OR_tracks) {
      return dart.as(new MediaStream(stream_OR_tracks), MediaStream);
    }
    static _create_3(stream_OR_tracks) {
      return dart.as(new MediaStream(stream_OR_tracks), MediaStream);
    }
    get [dartx.ended]() {
      return this.ended;
    }
    get [dartx.id]() {
      return this.id;
    }
    get [dartx.label]() {
      return this.label;
    }
    [dartx.addTrack](track) {
      return this.addTrack(track);
    }
    [dartx.clone]() {
      return this.clone();
    }
    [dartx.getAudioTracks]() {
      return this.getAudioTracks();
    }
    [dartx.getTrackById](trackId) {
      return this.getTrackById(trackId);
    }
    [dartx.getTracks]() {
      return this.getTracks();
    }
    [dartx.getVideoTracks]() {
      return this.getVideoTracks();
    }
    [dartx.removeTrack](track) {
      return this.removeTrack(track);
    }
    [dartx.stop]() {
      return this.stop();
    }
    get [dartx.onAddTrack]() {
      return MediaStream.addTrackEvent.forTarget(this);
    }
    get [dartx.onEnded]() {
      return MediaStream.endedEvent.forTarget(this);
    }
    get [dartx.onRemoveTrack]() {
      return MediaStream.removeTrackEvent.forTarget(this);
    }
    static get supported() {
      return !!(exports.window[dartx.navigator].getUserMedia || exports.window[dartx.navigator].webkitGetUserMedia || exports.window[dartx.navigator].mozGetUserMedia || exports.window[dartx.navigator].msGetUserMedia);
    }
  }
  dart.setSignature(MediaStream, {
    constructors: () => ({
      _: [MediaStream, []],
      new: [MediaStream, [], [dart.dynamic]]
    }),
    methods: () => ({
      [dartx.addTrack]: [dart.void, [MediaStreamTrack]],
      [dartx.clone]: [MediaStream, []],
      [dartx.getAudioTracks]: [core.List$(MediaStreamTrack), []],
      [dartx.getTrackById]: [MediaStreamTrack, [core.String]],
      [dartx.getTracks]: [core.List$(MediaStreamTrack), []],
      [dartx.getVideoTracks]: [core.List$(MediaStreamTrack), []],
      [dartx.removeTrack]: [dart.void, [MediaStreamTrack]],
      [dartx.stop]: [dart.void, []]
    }),
    statics: () => ({
      _create_1: [MediaStream, []],
      _create_2: [MediaStream, [dart.dynamic]],
      _create_3: [MediaStream, [dart.dynamic]]
    }),
    names: ['_create_1', '_create_2', '_create_3']
  });
  MediaStream[dart.metadata] = () => [dart.const(new _metadata.DomName('MediaStream')), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.CHROME)), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("MediaStream"))];
  dart.defineLazyProperties(MediaStream, {
    get addTrackEvent() {
      return dart.const(new (EventStreamProvider$(Event))('addtrack'));
    },
    get endedEvent() {
      return dart.const(new (EventStreamProvider$(Event))('ended'));
    },
    get removeTrackEvent() {
      return dart.const(new (EventStreamProvider$(Event))('removetrack'));
    }
  });
  dart.registerExtension(dart.global.MediaStream, MediaStream);
  dart.defineExtensionNames([
    'stream'
  ]);
  class MediaStreamEvent extends Event {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static get supported() {
      return html_common.Device.isEventTypeSupported('MediaStreamEvent');
    }
    get [dartx.stream]() {
      return this.stream;
    }
  }
  dart.setSignature(MediaStreamEvent, {
    constructors: () => ({_: [MediaStreamEvent, []]})
  });
  MediaStreamEvent[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('MediaStreamEvent')), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.CHROME)), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("MediaStreamEvent"))];
  dart.registerExtension(dart.global.MediaStreamEvent, MediaStreamEvent);
  dart.defineExtensionNames([
    'clone',
    'stop',
    'onEnded',
    'onMute',
    'onUnmute',
    'enabled',
    'id',
    'kind',
    'label',
    'muted',
    'readyState'
  ]);
  class MediaStreamTrack extends EventTarget {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.enabled]() {
      return this.enabled;
    }
    set [dartx.enabled](value) {
      this.enabled = value;
    }
    get [dartx.id]() {
      return this.id;
    }
    get [dartx.kind]() {
      return this.kind;
    }
    get [dartx.label]() {
      return this.label;
    }
    get [dartx.muted]() {
      return this.muted;
    }
    get [dartx.readyState]() {
      return this.readyState;
    }
    [dartx.clone]() {
      return this.clone();
    }
    static getSources() {
      let completer = async.Completer$(core.List$(SourceInfo)).new();
      MediaStreamTrack._getSources(dart.fn(value => {
        completer.complete(value);
      }, dart.void, [core.List$(SourceInfo)]));
      return completer.future;
    }
    [dartx.stop]() {
      return this.stop();
    }
    get [dartx.onEnded]() {
      return MediaStreamTrack.endedEvent.forTarget(this);
    }
    get [dartx.onMute]() {
      return MediaStreamTrack.muteEvent.forTarget(this);
    }
    get [dartx.onUnmute]() {
      return MediaStreamTrack.unmuteEvent.forTarget(this);
    }
  }
  dart.setSignature(MediaStreamTrack, {
    constructors: () => ({_: [MediaStreamTrack, []]}),
    methods: () => ({
      [dartx.clone]: [MediaStreamTrack, []],
      [dartx.stop]: [dart.void, []]
    }),
    statics: () => ({
      _getSources: [dart.void, [MediaStreamTrackSourcesCallback]],
      getSources: [async.Future$(core.List$(SourceInfo)), []]
    }),
    names: ['_getSources', 'getSources']
  });
  MediaStreamTrack[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('MediaStreamTrack')), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.CHROME)), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("MediaStreamTrack"))];
  dart.defineLazyProperties(MediaStreamTrack, {
    get endedEvent() {
      return dart.const(new (EventStreamProvider$(Event))('ended'));
    },
    get muteEvent() {
      return dart.const(new (EventStreamProvider$(Event))('mute'));
    },
    get unmuteEvent() {
      return dart.const(new (EventStreamProvider$(Event))('unmute'));
    }
  });
  dart.registerExtension(dart.global.MediaStreamTrack, MediaStreamTrack);
  dart.defineExtensionNames([
    'track'
  ]);
  class MediaStreamTrackEvent extends Event {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static get supported() {
      return html_common.Device.isEventTypeSupported('MediaStreamTrackEvent');
    }
    get [dartx.track]() {
      return this.track;
    }
  }
  dart.setSignature(MediaStreamTrackEvent, {
    constructors: () => ({_: [MediaStreamTrackEvent, []]})
  });
  MediaStreamTrackEvent[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('MediaStreamTrackEvent')), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.CHROME)), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("MediaStreamTrackEvent"))];
  dart.registerExtension(dart.global.MediaStreamTrackEvent, MediaStreamTrackEvent);
  const MediaStreamTrackSourcesCallback = dart.typedef('MediaStreamTrackSourcesCallback', () => dart.functionType(dart.void, [core.List$(SourceInfo)]));
  dart.defineExtensionNames([
    'jsHeapSizeLimit',
    'totalJSHeapSize',
    'usedJSHeapSize'
  ]);
  class MemoryInfo extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.jsHeapSizeLimit]() {
      return this.jsHeapSizeLimit;
    }
    get [dartx.totalJSHeapSize]() {
      return this.totalJSHeapSize;
    }
    get [dartx.usedJSHeapSize]() {
      return this.usedJSHeapSize;
    }
  }
  dart.setSignature(MemoryInfo, {
    constructors: () => ({_: [MemoryInfo, []]})
  });
  MemoryInfo[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('MemoryInfo')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("MemoryInfo"))];
  dart.registerExtension(dart.global.MemoryInfo, MemoryInfo);
  dart.defineExtensionNames([
    'label',
    'type'
  ]);
  class MenuElement extends HtmlElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return dart.as(exports.document[dartx.createElement]("menu"), MenuElement);
    }
    created() {
      this[dartx.label] = null;
      this[dartx.type] = null;
      super.created();
    }
    get [dartx.label]() {
      return this.label;
    }
    set [dartx.label](value) {
      this.label = value;
    }
    get [dartx.type]() {
      return this.type;
    }
    set [dartx.type](value) {
      this.type = value;
    }
  }
  dart.defineNamedConstructor(MenuElement, 'created');
  dart.setSignature(MenuElement, {
    constructors: () => ({
      _: [MenuElement, []],
      new: [MenuElement, []],
      created: [MenuElement, []]
    })
  });
  MenuElement[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('HTMLMenuElement')), dart.const(new _js_helper.Native("HTMLMenuElement"))];
  dart.registerExtension(dart.global.HTMLMenuElement, MenuElement);
  dart.defineExtensionNames([
    'checked',
    'defaultValue',
    'disabled',
    'label',
    'type'
  ]);
  class MenuItemElement extends HtmlElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    created() {
      this[dartx.checked] = null;
      this[dartx.defaultValue] = null;
      this[dartx.disabled] = null;
      this[dartx.label] = null;
      this[dartx.type] = null;
      super.created();
    }
    get [dartx.checked]() {
      return this.checked;
    }
    set [dartx.checked](value) {
      this.checked = value;
    }
    get [dartx.defaultValue]() {
      return this.default;
    }
    set [dartx.defaultValue](value) {
      this.default = value;
    }
    get [dartx.disabled]() {
      return this.disabled;
    }
    set [dartx.disabled](value) {
      this.disabled = value;
    }
    get [dartx.label]() {
      return this.label;
    }
    set [dartx.label](value) {
      this.label = value;
    }
    get [dartx.type]() {
      return this.type;
    }
    set [dartx.type](value) {
      this.type = value;
    }
  }
  dart.defineNamedConstructor(MenuItemElement, 'created');
  dart.setSignature(MenuItemElement, {
    constructors: () => ({
      _: [MenuItemElement, []],
      created: [MenuItemElement, []]
    })
  });
  MenuItemElement[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('HTMLMenuItemElement')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("HTMLMenuItemElement"))];
  dart.registerExtension(dart.global.HTMLMenuItemElement, MenuItemElement);
  dart.defineExtensionNames([
    'port1',
    'port2'
  ]);
  class MessageChannel extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.port1]() {
      return this.port1;
    }
    get [dartx.port2]() {
      return this.port2;
    }
  }
  dart.setSignature(MessageChannel, {
    constructors: () => ({_: [MessageChannel, []]})
  });
  MessageChannel[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('MessageChannel')), dart.const(new _metadata.Unstable()), dart.const(new _js_helper.Native("MessageChannel"))];
  dart.registerExtension(dart.global.MessageChannel, MessageChannel);
  const _initMessageEvent = Symbol('_initMessageEvent');
  const _get_data = Symbol('_get_data');
  const _get_source = Symbol('_get_source');
  dart.defineExtensionNames([
    'data',
    'source',
    'lastEventId',
    'origin'
  ]);
  class MessageEvent extends Event {
    static new(type, opts) {
      let canBubble = opts && 'canBubble' in opts ? opts.canBubble : false;
      let cancelable = opts && 'cancelable' in opts ? opts.cancelable : false;
      let data = opts && 'data' in opts ? opts.data : null;
      let origin = opts && 'origin' in opts ? opts.origin : null;
      let lastEventId = opts && 'lastEventId' in opts ? opts.lastEventId : null;
      let source = opts && 'source' in opts ? opts.source : null;
      let messagePorts = opts && 'messagePorts' in opts ? opts.messagePorts : null;
      if (source == null) {
        source = exports.window;
      }
      if (!dart.notNull(html_common.Device.isIE)) {
        return dart.as(new MessageEvent(type, {bubbles: canBubble, cancelable: cancelable, data: data, origin: origin, lastEventId: lastEventId, source: source, ports: messagePorts}), MessageEvent);
      }
      let event = exports.document[_createEvent]("MessageEvent");
      dart.dcall(event[_initMessageEvent], type, canBubble, cancelable, data, origin, lastEventId, source, messagePorts);
      return dart.as(event, MessageEvent);
    }
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.data]() {
      return html_common.convertNativeToDart_SerializedScriptValue(this[_get_data]);
    }
    get [_get_data]() {
      return this.data;
    }
    get [dartx.lastEventId]() {
      return this.lastEventId;
    }
    get [dartx.origin]() {
      return this.origin;
    }
    get [dartx.source]() {
      return _convertNativeToDart_EventTarget(this[_get_source]);
    }
    get [_get_source]() {
      return this.source;
    }
    [_initMessageEvent](typeArg, canBubbleArg, cancelableArg, dataArg, originArg, lastEventIdArg, sourceArg, messagePorts) {
      return this.initMessageEvent(typeArg, canBubbleArg, cancelableArg, dataArg, originArg, lastEventIdArg, sourceArg, messagePorts);
    }
  }
  dart.setSignature(MessageEvent, {
    constructors: () => ({
      new: [MessageEvent, [core.String], {canBubble: core.bool, cancelable: core.bool, data: core.Object, origin: core.String, lastEventId: core.String, source: Window, messagePorts: core.List}],
      _: [MessageEvent, []]
    }),
    methods: () => ({[_initMessageEvent]: [dart.void, [core.String, core.bool, core.bool, core.Object, core.String, core.String, Window, core.List$(MessagePort)]]})
  });
  MessageEvent[dart.metadata] = () => [dart.const(new _metadata.DomName('MessageEvent')), dart.const(new _js_helper.Native("MessageEvent"))];
  dart.registerExtension(dart.global.MessageEvent, MessageEvent);
  dart.defineExtensionNames([
    'close',
    'postMessage',
    'start',
    'onMessage'
  ]);
  class MessagePort extends EventTarget {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    [dartx.close]() {
      return this.close();
    }
    [dartx.postMessage](message, transfer) {
      if (transfer === void 0) transfer = null;
      if (transfer != null) {
        let message_1 = html_common.convertDartToNative_SerializedScriptValue(message);
        this[_postMessage_1](message_1, transfer);
        return;
      }
      let message_1 = html_common.convertDartToNative_SerializedScriptValue(message);
      this[_postMessage_2](message_1);
      return;
    }
    [_postMessage_1](message, transfer) {
      return this.postMessage(message, transfer);
    }
    [_postMessage_2](message) {
      return this.postMessage(message);
    }
    [dartx.start]() {
      return this.start();
    }
    get [dartx.onMessage]() {
      return MessagePort.messageEvent.forTarget(this);
    }
  }
  dart.setSignature(MessagePort, {
    constructors: () => ({_: [MessagePort, []]}),
    methods: () => ({
      [dartx.close]: [dart.void, []],
      [dartx.postMessage]: [dart.void, [dart.dynamic], [core.List$(MessagePort)]],
      [_postMessage_1]: [dart.void, [dart.dynamic, core.List$(MessagePort)]],
      [_postMessage_2]: [dart.void, [dart.dynamic]],
      [dartx.start]: [dart.void, []]
    })
  });
  MessagePort[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('MessagePort')), dart.const(new _metadata.Unstable()), dart.const(new _js_helper.Native("MessagePort"))];
  dart.defineLazyProperties(MessagePort, {
    get messageEvent() {
      return dart.const(new (EventStreamProvider$(MessageEvent))('message'));
    }
  });
  dart.registerExtension(dart.global.MessagePort, MessagePort);
  dart.defineExtensionNames([
    'content',
    'httpEquiv',
    'name'
  ]);
  class MetaElement extends HtmlElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return dart.as(exports.document[dartx.createElement]("meta"), MetaElement);
    }
    created() {
      this[dartx.content] = null;
      this[dartx.httpEquiv] = null;
      this[dartx.name] = null;
      super.created();
    }
    get [dartx.content]() {
      return this.content;
    }
    set [dartx.content](value) {
      this.content = value;
    }
    get [dartx.httpEquiv]() {
      return this.httpEquiv;
    }
    set [dartx.httpEquiv](value) {
      this.httpEquiv = value;
    }
    get [dartx.name]() {
      return this.name;
    }
    set [dartx.name](value) {
      this.name = value;
    }
  }
  dart.defineNamedConstructor(MetaElement, 'created');
  dart.setSignature(MetaElement, {
    constructors: () => ({
      _: [MetaElement, []],
      new: [MetaElement, []],
      created: [MetaElement, []]
    })
  });
  MetaElement[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('HTMLMetaElement')), dart.const(new _js_helper.Native("HTMLMetaElement"))];
  dart.registerExtension(dart.global.HTMLMetaElement, MetaElement);
  const _get_modificationTime = Symbol('_get_modificationTime');
  dart.defineExtensionNames([
    'modificationTime',
    'size'
  ]);
  class Metadata extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.modificationTime]() {
      return html_common.convertNativeToDart_DateTime(this[_get_modificationTime]);
    }
    get [_get_modificationTime]() {
      return this.modificationTime;
    }
    get [dartx.size]() {
      return this.size;
    }
  }
  dart.setSignature(Metadata, {
    constructors: () => ({_: [Metadata, []]})
  });
  Metadata[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('Metadata')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("Metadata"))];
  dart.registerExtension(dart.global.Metadata, Metadata);
  const MetadataCallback = dart.typedef('MetadataCallback', () => dart.functionType(dart.void, [Metadata]));
  dart.defineExtensionNames([
    'high',
    'labels',
    'low',
    'max',
    'min',
    'optimum',
    'value'
  ]);
  class MeterElement extends HtmlElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return dart.as(exports.document[dartx.createElement]("meter"), MeterElement);
    }
    created() {
      this[dartx.high] = null;
      this[dartx.labels] = null;
      this[dartx.low] = null;
      this[dartx.max] = null;
      this[dartx.min] = null;
      this[dartx.optimum] = null;
      this[dartx.value] = null;
      super.created();
    }
    static get supported() {
      return Element.isTagSupported('meter');
    }
    get [dartx.high]() {
      return this.high;
    }
    set [dartx.high](value) {
      this.high = value;
    }
    get [dartx.labels]() {
      return this.labels;
    }
    get [dartx.low]() {
      return this.low;
    }
    set [dartx.low](value) {
      this.low = value;
    }
    get [dartx.max]() {
      return this.max;
    }
    set [dartx.max](value) {
      this.max = value;
    }
    get [dartx.min]() {
      return this.min;
    }
    set [dartx.min](value) {
      this.min = value;
    }
    get [dartx.optimum]() {
      return this.optimum;
    }
    set [dartx.optimum](value) {
      this.optimum = value;
    }
    get [dartx.value]() {
      return this.value;
    }
    set [dartx.value](value) {
      this.value = value;
    }
  }
  dart.defineNamedConstructor(MeterElement, 'created');
  dart.setSignature(MeterElement, {
    constructors: () => ({
      _: [MeterElement, []],
      new: [MeterElement, []],
      created: [MeterElement, []]
    })
  });
  MeterElement[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('HTMLMeterElement')), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.CHROME)), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.FIREFOX)), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.SAFARI)), dart.const(new _metadata.Unstable()), dart.const(new _js_helper.Native("HTMLMeterElement"))];
  dart.registerExtension(dart.global.HTMLMeterElement, MeterElement);
  dart.defineExtensionNames([
    'onConnect',
    'onDisconnect',
    'inputs',
    'outputs',
    'sysexEnabled'
  ]);
  class MidiAccess extends EventTarget {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.inputs]() {
      return this.inputs;
    }
    get [dartx.outputs]() {
      return this.outputs;
    }
    get [dartx.sysexEnabled]() {
      return this.sysexEnabled;
    }
    get [dartx.onConnect]() {
      return MidiAccess.connectEvent.forTarget(this);
    }
    get [dartx.onDisconnect]() {
      return MidiAccess.disconnectEvent.forTarget(this);
    }
  }
  dart.setSignature(MidiAccess, {
    constructors: () => ({_: [MidiAccess, []]})
  });
  MidiAccess[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('MIDIAccess')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("MIDIAccess"))];
  dart.defineLazyProperties(MidiAccess, {
    get connectEvent() {
      return dart.const(new (EventStreamProvider$(MidiConnectionEvent))('connect'));
    },
    get disconnectEvent() {
      return dart.const(new (EventStreamProvider$(MidiConnectionEvent))('disconnect'));
    }
  });
  dart.registerExtension(dart.global.MIDIAccess, MidiAccess);
  dart.defineExtensionNames([
    'port'
  ]);
  class MidiConnectionEvent extends Event {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.port]() {
      return this.port;
    }
  }
  dart.setSignature(MidiConnectionEvent, {
    constructors: () => ({_: [MidiConnectionEvent, []]})
  });
  MidiConnectionEvent[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('MIDIConnectionEvent')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("MIDIConnectionEvent"))];
  dart.registerExtension(dart.global.MIDIConnectionEvent, MidiConnectionEvent);
  dart.defineExtensionNames([
    'onDisconnect',
    'id',
    'manufacturer',
    'name',
    'type',
    'version'
  ]);
  class MidiPort extends EventTarget {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.id]() {
      return this.id;
    }
    get [dartx.manufacturer]() {
      return this.manufacturer;
    }
    get [dartx.name]() {
      return this.name;
    }
    get [dartx.type]() {
      return this.type;
    }
    get [dartx.version]() {
      return this.version;
    }
    get [dartx.onDisconnect]() {
      return MidiPort.disconnectEvent.forTarget(this);
    }
  }
  dart.setSignature(MidiPort, {
    constructors: () => ({_: [MidiPort, []]})
  });
  MidiPort[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('MIDIPort')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("MIDIPort"))];
  dart.defineLazyProperties(MidiPort, {
    get disconnectEvent() {
      return dart.const(new (EventStreamProvider$(MidiConnectionEvent))('disconnect'));
    }
  });
  dart.registerExtension(dart.global.MIDIPort, MidiPort);
  dart.defineExtensionNames([
    'onMidiMessage'
  ]);
  class MidiInput extends MidiPort {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.onMidiMessage]() {
      return MidiInput.midiMessageEvent.forTarget(this);
    }
  }
  dart.setSignature(MidiInput, {
    constructors: () => ({_: [MidiInput, []]})
  });
  MidiInput[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('MIDIInput')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("MIDIInput"))];
  dart.defineLazyProperties(MidiInput, {
    get midiMessageEvent() {
      return dart.const(new (EventStreamProvider$(MidiMessageEvent))('midimessage'));
    }
  });
  dart.registerExtension(dart.global.MIDIInput, MidiInput);
  dart.defineExtensionNames([
    'entries',
    'get',
    'has',
    'keys',
    'values',
    'size'
  ]);
  class MidiInputMap extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.size]() {
      return this.size;
    }
    [dartx.entries]() {
      return this.entries();
    }
    [dartx.get](id) {
      return this.get(id);
    }
    [dartx.has](key) {
      return this.has(key);
    }
    [dartx.keys]() {
      return this.keys();
    }
    [dartx.values]() {
      return this.values();
    }
  }
  dart.setSignature(MidiInputMap, {
    constructors: () => ({_: [MidiInputMap, []]}),
    methods: () => ({
      [dartx.entries]: [DomIterator, []],
      [dartx.get]: [core.Object, [core.String]],
      [dartx.has]: [core.bool, [core.String]],
      [dartx.keys]: [DomIterator, []],
      [dartx.values]: [DomIterator, []]
    })
  });
  MidiInputMap[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('MIDIInputMap')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("MIDIInputMap"))];
  dart.registerExtension(dart.global.MIDIInputMap, MidiInputMap);
  dart.defineExtensionNames([
    'data',
    'receivedTime'
  ]);
  class MidiMessageEvent extends Event {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.data]() {
      return this.data;
    }
    get [dartx.receivedTime]() {
      return this.receivedTime;
    }
  }
  dart.setSignature(MidiMessageEvent, {
    constructors: () => ({_: [MidiMessageEvent, []]})
  });
  MidiMessageEvent[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('MIDIMessageEvent')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("MIDIMessageEvent"))];
  dart.registerExtension(dart.global.MIDIMessageEvent, MidiMessageEvent);
  dart.defineExtensionNames([
    'send'
  ]);
  class MidiOutput extends MidiPort {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    [dartx.send](data, timestamp) {
      return this.send(data, timestamp);
    }
  }
  dart.setSignature(MidiOutput, {
    constructors: () => ({_: [MidiOutput, []]}),
    methods: () => ({[dartx.send]: [dart.void, [typed_data.Uint8List], [core.num]]})
  });
  MidiOutput[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('MIDIOutput')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("MIDIOutput"))];
  dart.registerExtension(dart.global.MIDIOutput, MidiOutput);
  dart.defineExtensionNames([
    'entries',
    'get',
    'has',
    'keys',
    'values',
    'size'
  ]);
  class MidiOutputMap extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.size]() {
      return this.size;
    }
    [dartx.entries]() {
      return this.entries();
    }
    [dartx.get](id) {
      return this.get(id);
    }
    [dartx.has](key) {
      return this.has(key);
    }
    [dartx.keys]() {
      return this.keys();
    }
    [dartx.values]() {
      return this.values();
    }
  }
  dart.setSignature(MidiOutputMap, {
    constructors: () => ({_: [MidiOutputMap, []]}),
    methods: () => ({
      [dartx.entries]: [DomIterator, []],
      [dartx.get]: [core.Object, [core.String]],
      [dartx.has]: [core.bool, [core.String]],
      [dartx.keys]: [DomIterator, []],
      [dartx.values]: [DomIterator, []]
    })
  });
  MidiOutputMap[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('MIDIOutputMap')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("MIDIOutputMap"))];
  dart.registerExtension(dart.global.MIDIOutputMap, MidiOutputMap);
  dart.defineExtensionNames([
    'description',
    'enabledPlugin',
    'suffixes',
    'type'
  ]);
  class MimeType extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.description]() {
      return this.description;
    }
    get [dartx.enabledPlugin]() {
      return this.enabledPlugin;
    }
    get [dartx.suffixes]() {
      return this.suffixes;
    }
    get [dartx.type]() {
      return this.type;
    }
  }
  dart.setSignature(MimeType, {
    constructors: () => ({_: [MimeType, []]})
  });
  MimeType[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('MimeType')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("MimeType"))];
  dart.registerExtension(dart.global.MimeType, MimeType);
  dart.defineExtensionNames([
    'length',
    'get',
    'set',
    'length',
    'first',
    'last',
    'single',
    'elementAt',
    'item',
    'namedItem'
  ]);
  class MimeTypeArray extends dart.mixin(_interceptors.Interceptor, collection.ListMixin$(MimeType), ImmutableListMixin$(MimeType)) {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.length]() {
      return this.length;
    }
    [dartx.get](index) {
      if (index >>> 0 !== index || index >= this[dartx.length]) dart.throw(core.RangeError.index(index, this));
      return dart.as(this[index], MimeType);
    }
    [dartx.set](index, value) {
      dart.throw(new core.UnsupportedError("Cannot assign element of immutable List."));
      return value;
    }
    set [dartx.length](value) {
      dart.throw(new core.UnsupportedError("Cannot resize immutable List."));
    }
    get [dartx.first]() {
      if (dart.notNull(this[dartx.length]) > 0) {
        return dart.as(this[0], MimeType);
      }
      dart.throw(new core.StateError("No elements"));
    }
    get [dartx.last]() {
      let len = this[dartx.length];
      if (dart.notNull(len) > 0) {
        return dart.as(this[dart.notNull(len) - 1], MimeType);
      }
      dart.throw(new core.StateError("No elements"));
    }
    get [dartx.single]() {
      let len = this[dartx.length];
      if (len == 1) {
        return dart.as(this[0], MimeType);
      }
      if (len == 0) dart.throw(new core.StateError("No elements"));
      dart.throw(new core.StateError("More than one element"));
    }
    [dartx.elementAt](index) {
      return this[dartx.get](index);
    }
    [__getter__](name) {
      return this.__getter__(name);
    }
    [dartx.item](index) {
      return this.item(index);
    }
    [dartx.namedItem](name) {
      return this.namedItem(name);
    }
  }
  MimeTypeArray[dart.implements] = () => [_js_helper.JavaScriptIndexingBehavior, core.List$(MimeType)];
  dart.setSignature(MimeTypeArray, {
    constructors: () => ({_: [MimeTypeArray, []]}),
    methods: () => ({
      [dartx.get]: [MimeType, [core.int]],
      [dartx.set]: [dart.void, [core.int, MimeType]],
      [dartx.elementAt]: [MimeType, [core.int]],
      [__getter__]: [MimeType, [core.String]],
      [dartx.item]: [MimeType, [core.int]],
      [dartx.namedItem]: [MimeType, [core.String]]
    })
  });
  MimeTypeArray[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('MimeTypeArray')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("MimeTypeArray"))];
  dart.registerExtension(dart.global.MimeTypeArray, MimeTypeArray);
  dart.defineExtensionNames([
    'cite',
    'dateTime'
  ]);
  class ModElement extends HtmlElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    created() {
      this[dartx.cite] = null;
      this[dartx.dateTime] = null;
      super.created();
    }
    get [dartx.cite]() {
      return this.cite;
    }
    set [dartx.cite](value) {
      this.cite = value;
    }
    get [dartx.dateTime]() {
      return this.dateTime;
    }
    set [dartx.dateTime](value) {
      this.dateTime = value;
    }
  }
  dart.defineNamedConstructor(ModElement, 'created');
  dart.setSignature(ModElement, {
    constructors: () => ({
      _: [ModElement, []],
      created: [ModElement, []]
    })
  });
  ModElement[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('HTMLModElement')), dart.const(new _metadata.Unstable()), dart.const(new _js_helper.Native("HTMLModElement"))];
  dart.registerExtension(dart.global.HTMLModElement, ModElement);
  const _initMouseEvent = Symbol('_initMouseEvent');
  const _clientX = Symbol('_clientX');
  const _clientY = Symbol('_clientY');
  const _movementX = Symbol('_movementX');
  const _movementY = Symbol('_movementY');
  const _screenX = Symbol('_screenX');
  const _screenY = Symbol('_screenY');
  const _webkitMovementX = Symbol('_webkitMovementX');
  const _webkitMovementY = Symbol('_webkitMovementY');
  const _initMouseEvent_1 = Symbol('_initMouseEvent_1');
  dart.defineExtensionNames([
    'relatedTarget',
    'client',
    'movement',
    'offset',
    'screen',
    'altKey',
    'button',
    'ctrlKey',
    'dataTransfer',
    'fromElement',
    'metaKey',
    'region',
    'shiftKey',
    'toElement'
  ]);
  class MouseEvent extends UIEvent {
    static new(type, opts) {
      let view = opts && 'view' in opts ? opts.view : null;
      let detail = opts && 'detail' in opts ? opts.detail : 0;
      let screenX = opts && 'screenX' in opts ? opts.screenX : 0;
      let screenY = opts && 'screenY' in opts ? opts.screenY : 0;
      let clientX = opts && 'clientX' in opts ? opts.clientX : 0;
      let clientY = opts && 'clientY' in opts ? opts.clientY : 0;
      let button = opts && 'button' in opts ? opts.button : 0;
      let canBubble = opts && 'canBubble' in opts ? opts.canBubble : true;
      let cancelable = opts && 'cancelable' in opts ? opts.cancelable : true;
      let ctrlKey = opts && 'ctrlKey' in opts ? opts.ctrlKey : false;
      let altKey = opts && 'altKey' in opts ? opts.altKey : false;
      let shiftKey = opts && 'shiftKey' in opts ? opts.shiftKey : false;
      let metaKey = opts && 'metaKey' in opts ? opts.metaKey : false;
      let relatedTarget = opts && 'relatedTarget' in opts ? opts.relatedTarget : null;
      if (view == null) {
        view = exports.window;
      }
      let event = exports.document[_createEvent]('MouseEvent');
      dart.dcall(event[_initMouseEvent], type, canBubble, cancelable, view, detail, screenX, screenY, clientX, clientY, ctrlKey, altKey, shiftKey, metaKey, button, relatedTarget);
      return dart.as(event, MouseEvent);
    }
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.altKey]() {
      return this.altKey;
    }
    get [dartx.button]() {
      return this.button;
    }
    get [_clientX]() {
      return this.clientX;
    }
    get [_clientY]() {
      return this.clientY;
    }
    get [dartx.ctrlKey]() {
      return this.ctrlKey;
    }
    get [dartx.dataTransfer]() {
      return this.dataTransfer;
    }
    get [dartx.fromElement]() {
      return this.fromElement;
    }
    get [dartx.metaKey]() {
      return this.metaKey;
    }
    get [_movementX]() {
      return this.movementX;
    }
    get [_movementY]() {
      return this.movementY;
    }
    get [dartx.region]() {
      return this.region;
    }
    get [dartx.relatedTarget]() {
      return _convertNativeToDart_EventTarget(this[_get_relatedTarget]);
    }
    get [_get_relatedTarget]() {
      return this.relatedTarget;
    }
    get [_screenX]() {
      return this.screenX;
    }
    get [_screenY]() {
      return this.screenY;
    }
    get [dartx.shiftKey]() {
      return this.shiftKey;
    }
    get [dartx.toElement]() {
      return this.toElement;
    }
    get [_webkitMovementX]() {
      return this.webkitMovementX;
    }
    get [_webkitMovementY]() {
      return this.webkitMovementY;
    }
    [_initMouseEvent](type, canBubble, cancelable, view, detail, screenX, screenY, clientX, clientY, ctrlKey, altKey, shiftKey, metaKey, button, relatedTarget) {
      let relatedTarget_1 = _convertDartToNative_EventTarget(relatedTarget);
      this[_initMouseEvent_1](type, canBubble, cancelable, view, detail, screenX, screenY, clientX, clientY, ctrlKey, altKey, shiftKey, metaKey, button, relatedTarget_1);
      return;
    }
    [_initMouseEvent_1](type, canBubble, cancelable, view, detail, screenX, screenY, clientX, clientY, ctrlKey, altKey, shiftKey, metaKey, button, relatedTarget) {
      return this.initMouseEvent(type, canBubble, cancelable, view, detail, screenX, screenY, clientX, clientY, ctrlKey, altKey, shiftKey, metaKey, button, relatedTarget);
    }
    get [dartx.client]() {
      return new math.Point(this[_clientX], this[_clientY]);
    }
    get [dartx.movement]() {
      return new math.Point(this[_webkitMovementX], this[_webkitMovementY]);
    }
    get [dartx.offset]() {
      if (!!this.offsetX) {
        let x = this.offsetX;
        let y = this.offsetY;
        return new math.Point(x, y);
      } else {
        if (!dart.is(this[dartx.target], Element)) {
          dart.throw(new core.UnsupportedError('offsetX is only supported on elements'));
        }
        let target = dart.as(this[dartx.target], Element);
        let point = this[dartx.client]['-'](target[dartx.getBoundingClientRect]()[dartx.topLeft]);
        return new math.Point(dart.dsend(point.x, 'toInt'), dart.dsend(point.y, 'toInt'));
      }
    }
    get [dartx.screen]() {
      return new math.Point(this[_screenX], this[_screenY]);
    }
  }
  dart.setSignature(MouseEvent, {
    constructors: () => ({
      new: [MouseEvent, [core.String], {view: Window, detail: core.int, screenX: core.int, screenY: core.int, clientX: core.int, clientY: core.int, button: core.int, canBubble: core.bool, cancelable: core.bool, ctrlKey: core.bool, altKey: core.bool, shiftKey: core.bool, metaKey: core.bool, relatedTarget: EventTarget}],
      _: [MouseEvent, []]
    }),
    methods: () => ({
      [_initMouseEvent]: [dart.void, [core.String, core.bool, core.bool, Window, core.int, core.int, core.int, core.int, core.int, core.bool, core.bool, core.bool, core.bool, core.int, EventTarget]],
      [_initMouseEvent_1]: [dart.void, [dart.dynamic, dart.dynamic, dart.dynamic, Window, dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic]]
    })
  });
  MouseEvent[dart.metadata] = () => [dart.const(new _metadata.DomName('MouseEvent')), dart.const(new _js_helper.Native("MouseEvent,DragEvent,PointerEvent,MSPointerEvent"))];
  dart.registerExtension(dart.global.MouseEvent, MouseEvent);
  const MutationCallback = dart.typedef('MutationCallback', () => dart.functionType(dart.void, [core.List$(MutationRecord), MutationObserver]));
  const _observe_1 = Symbol('_observe_1');
  const _observe = Symbol('_observe');
  const _call = Symbol('_call');
  dart.defineExtensionNames([
    'disconnect',
    'takeRecords',
    'observe'
  ]);
  class MutationObserver extends _interceptors.Interceptor {
    [dartx.disconnect]() {
      return this.disconnect();
    }
    [_observe](target, options) {
      let options_1 = html_common.convertDartToNative_Dictionary(options);
      this[_observe_1](target, options_1);
      return;
    }
    [_observe_1](target, options) {
      return this.observe(target, options);
    }
    [dartx.takeRecords]() {
      return this.takeRecords();
    }
    static get supported() {
      return !!(window.MutationObserver || window.WebKitMutationObserver);
    }
    [dartx.observe](target, opts) {
      let childList = opts && 'childList' in opts ? opts.childList : null;
      let attributes = opts && 'attributes' in opts ? opts.attributes : null;
      let characterData = opts && 'characterData' in opts ? opts.characterData : null;
      let subtree = opts && 'subtree' in opts ? opts.subtree : null;
      let attributeOldValue = opts && 'attributeOldValue' in opts ? opts.attributeOldValue : null;
      let characterDataOldValue = opts && 'characterDataOldValue' in opts ? opts.characterDataOldValue : null;
      let attributeFilter = opts && 'attributeFilter' in opts ? opts.attributeFilter : null;
      let parsedOptions = MutationObserver._createDict();
      function override(key, value) {
        if (value != null) MutationObserver._add(parsedOptions, dart.as(key, core.String), value);
      }
      dart.fn(override);
      override('childList', childList);
      override('attributes', attributes);
      override('characterData', characterData);
      override('subtree', subtree);
      override('attributeOldValue', attributeOldValue);
      override('characterDataOldValue', characterDataOldValue);
      if (attributeFilter != null) {
        override('attributeFilter', MutationObserver._fixupList(attributeFilter));
      }
      this[_call](target, parsedOptions);
    }
    static _createDict() {
      return {};
    }
    static _add(m, key, value) {
      m[key] = value;
    }
    static _fixupList(list) {
      return list;
    }
    [_call](target, options) {
      return this.observe(target, options);
    }
    static new(callback) {
      0;
      return dart.as(new (window.MutationObserver || window.WebKitMutationObserver || window.MozMutationObserver)(dart.dcall(/* Unimplemented unknown name */convertDartClosureToJS, _wrapBinaryZone(callback), 2)), MutationObserver);
    }
  }
  dart.setSignature(MutationObserver, {
    constructors: () => ({new: [MutationObserver, [MutationCallback]]}),
    methods: () => ({
      [dartx.disconnect]: [dart.void, []],
      [_observe]: [dart.void, [Node, core.Map]],
      [_observe_1]: [dart.void, [Node, dart.dynamic]],
      [dartx.takeRecords]: [core.List$(MutationRecord), []],
      [dartx.observe]: [dart.void, [Node], {childList: core.bool, attributes: core.bool, characterData: core.bool, subtree: core.bool, attributeOldValue: core.bool, characterDataOldValue: core.bool, attributeFilter: core.List$(core.String)}],
      [_call]: [dart.void, [dart.dynamic, dart.dynamic]]
    }),
    statics: () => ({
      _createDict: [dart.dynamic, []],
      _add: [dart.dynamic, [dart.dynamic, core.String, dart.dynamic]],
      _fixupList: [dart.dynamic, [dart.dynamic]]
    }),
    names: ['_createDict', '_add', '_fixupList']
  });
  MutationObserver[dart.metadata] = () => [dart.const(new _metadata.DomName('MutationObserver')), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.CHROME)), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.FIREFOX)), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.SAFARI)), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("MutationObserver,WebKitMutationObserver"))];
  MutationObserver._boolKeys = dart.const(dart.map({childList: true, attributes: true, characterData: true, subtree: true, attributeOldValue: true, characterDataOldValue: true}));
  dart.registerExtension(dart.global.MutationObserver, MutationObserver);
  dart.defineExtensionNames([
    'addedNodes',
    'attributeName',
    'attributeNamespace',
    'nextSibling',
    'oldValue',
    'previousSibling',
    'removedNodes',
    'target',
    'type'
  ]);
  class MutationRecord extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.addedNodes]() {
      return this.addedNodes;
    }
    get [dartx.attributeName]() {
      return this.attributeName;
    }
    get [dartx.attributeNamespace]() {
      return this.attributeNamespace;
    }
    get [dartx.nextSibling]() {
      return this.nextSibling;
    }
    get [dartx.oldValue]() {
      return this.oldValue;
    }
    get [dartx.previousSibling]() {
      return this.previousSibling;
    }
    get [dartx.removedNodes]() {
      return this.removedNodes;
    }
    get [dartx.target]() {
      return this.target;
    }
    get [dartx.type]() {
      return this.type;
    }
  }
  dart.setSignature(MutationRecord, {
    constructors: () => ({_: [MutationRecord, []]})
  });
  MutationRecord[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('MutationRecord')), dart.const(new _js_helper.Native("MutationRecord"))];
  dart.registerExtension(dart.global.MutationRecord, MutationRecord);
  const _ensureGetUserMedia = Symbol('_ensureGetUserMedia');
  const _getUserMedia = Symbol('_getUserMedia');
  dart.defineExtensionNames([
    'language',
    'getUserMedia',
    'getBattery',
    'getGamepads',
    'getStorageUpdates',
    'registerProtocolHandler',
    'sendBeacon',
    'connection',
    'cookieEnabled',
    'credentials',
    'doNotTrack',
    'geofencing',
    'geolocation',
    'maxTouchPoints',
    'mimeTypes',
    'presentation',
    'productSub',
    'push',
    'serviceWorker',
    'storageQuota',
    'vendor',
    'vendorSub',
    'persistentStorage',
    'temporaryStorage',
    'hardwareConcurrency',
    'appCodeName',
    'appName',
    'appVersion',
    'dartEnabled',
    'platform',
    'product',
    'userAgent',
    'languages',
    'onLine'
  ]);
  class Navigator extends _interceptors.Interceptor {
    get [dartx.language]() {
      return this.language || this.userLanguage;
    }
    [dartx.getUserMedia](opts) {
      let audio = opts && 'audio' in opts ? opts.audio : false;
      let video = opts && 'video' in opts ? opts.video : false;
      let completer = async.Completer$(MediaStream).new();
      let options = dart.map({audio: audio, video: video});
      this[_ensureGetUserMedia]();
      this[_getUserMedia](html_common.convertDartToNative_SerializedScriptValue(options), dart.fn(stream => {
        completer.complete(stream);
      }, dart.void, [MediaStream]), dart.fn(error => {
        completer.completeError(error);
      }, dart.void, [NavigatorUserMediaError]));
      return completer.future;
    }
    [_ensureGetUserMedia]() {
      if (!this.getUserMedia) {
        this.getUserMedia = this.getUserMedia || this.webkitGetUserMedia || this.mozGetUserMedia || this.msGetUserMedia;
      }
    }
    [_getUserMedia](options, success, error) {
      return this.getUserMedia(options, success, error);
    }
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.connection]() {
      return this.connection;
    }
    get [dartx.cookieEnabled]() {
      return this.cookieEnabled;
    }
    get [dartx.credentials]() {
      return this.credentials;
    }
    get [dartx.doNotTrack]() {
      return this.doNotTrack;
    }
    get [dartx.geofencing]() {
      return this.geofencing;
    }
    get [dartx.geolocation]() {
      return this.geolocation;
    }
    get [dartx.maxTouchPoints]() {
      return this.maxTouchPoints;
    }
    get [dartx.mimeTypes]() {
      return this.mimeTypes;
    }
    get [dartx.presentation]() {
      return this.presentation;
    }
    get [dartx.productSub]() {
      return this.productSub;
    }
    get [dartx.push]() {
      return this.push;
    }
    get [dartx.serviceWorker]() {
      return this.serviceWorker;
    }
    get [dartx.storageQuota]() {
      return this.storageQuota;
    }
    get [dartx.vendor]() {
      return this.vendor;
    }
    get [dartx.vendorSub]() {
      return this.vendorSub;
    }
    get [dartx.persistentStorage]() {
      return this.webkitPersistentStorage;
    }
    get [dartx.temporaryStorage]() {
      return this.webkitTemporaryStorage;
    }
    [dartx.getBattery]() {
      return this.getBattery();
    }
    [dartx.getGamepads]() {
      return this.getGamepads();
    }
    [dartx.getStorageUpdates]() {
      return this.getStorageUpdates();
    }
    [dartx.registerProtocolHandler](scheme, url, title) {
      return this.registerProtocolHandler(scheme, url, title);
    }
    [dartx.sendBeacon](url, data) {
      return this.sendBeacon(url, data);
    }
    get [dartx.hardwareConcurrency]() {
      return this.hardwareConcurrency;
    }
    get [dartx.appCodeName]() {
      return this.appCodeName;
    }
    get [dartx.appName]() {
      return this.appName;
    }
    get [dartx.appVersion]() {
      return this.appVersion;
    }
    get [dartx.dartEnabled]() {
      return this.dartEnabled;
    }
    get [dartx.platform]() {
      return this.platform;
    }
    get [dartx.product]() {
      return this.product;
    }
    get [dartx.userAgent]() {
      return this.userAgent;
    }
    get [dartx.languages]() {
      return this.languages;
    }
    get [dartx.onLine]() {
      return this.onLine;
    }
  }
  Navigator[dart.implements] = () => [NavigatorCpu, NavigatorLanguage, NavigatorOnLine, NavigatorID];
  dart.setSignature(Navigator, {
    constructors: () => ({_: [Navigator, []]}),
    methods: () => ({
      [dartx.getUserMedia]: [async.Future$(MediaStream), [], {audio: dart.dynamic, video: dart.dynamic}],
      [_ensureGetUserMedia]: [dart.dynamic, []],
      [_getUserMedia]: [dart.void, [dart.dynamic, _NavigatorUserMediaSuccessCallback, _NavigatorUserMediaErrorCallback]],
      [dartx.getBattery]: [async.Future, []],
      [dartx.getGamepads]: [core.List$(Gamepad), []],
      [dartx.getStorageUpdates]: [dart.void, []],
      [dartx.registerProtocolHandler]: [dart.void, [core.String, core.String, core.String]],
      [dartx.sendBeacon]: [core.bool, [core.String, dart.dynamic]]
    })
  });
  Navigator[dart.metadata] = () => [dart.const(new _metadata.DomName('Navigator')), dart.const(new _js_helper.Native("Navigator"))];
  dart.registerExtension(dart.global.Navigator, Navigator);
  dart.defineExtensionNames([
    'hardwareConcurrency'
  ]);
  class NavigatorCpu extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.hardwareConcurrency]() {
      return this.hardwareConcurrency;
    }
  }
  dart.setSignature(NavigatorCpu, {
    constructors: () => ({_: [NavigatorCpu, []]})
  });
  NavigatorCpu[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('NavigatorCPU')), dart.const(new _metadata.Experimental())];
  dart.defineExtensionNames([
    'appCodeName',
    'appName',
    'appVersion',
    'dartEnabled',
    'platform',
    'product',
    'userAgent'
  ]);
  class NavigatorID extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.appCodeName]() {
      return this.appCodeName;
    }
    get [dartx.appName]() {
      return this.appName;
    }
    get [dartx.appVersion]() {
      return this.appVersion;
    }
    get [dartx.dartEnabled]() {
      return this.dartEnabled;
    }
    get [dartx.platform]() {
      return this.platform;
    }
    get [dartx.product]() {
      return this.product;
    }
    get [dartx.userAgent]() {
      return this.userAgent;
    }
  }
  dart.setSignature(NavigatorID, {
    constructors: () => ({_: [NavigatorID, []]})
  });
  NavigatorID[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('NavigatorID')), dart.const(new _metadata.Experimental())];
  dart.defineExtensionNames([
    'language',
    'languages'
  ]);
  class NavigatorLanguage extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.language]() {
      return this.language;
    }
    get [dartx.languages]() {
      return this.languages;
    }
  }
  dart.setSignature(NavigatorLanguage, {
    constructors: () => ({_: [NavigatorLanguage, []]})
  });
  NavigatorLanguage[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('NavigatorLanguage')), dart.const(new _metadata.Experimental())];
  dart.defineExtensionNames([
    'onLine'
  ]);
  class NavigatorOnLine extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.onLine]() {
      return this.onLine;
    }
  }
  dart.setSignature(NavigatorOnLine, {
    constructors: () => ({_: [NavigatorOnLine, []]})
  });
  NavigatorOnLine[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('NavigatorOnLine')), dart.const(new _metadata.Experimental())];
  dart.defineExtensionNames([
    'constraintName',
    'message',
    'name'
  ]);
  class NavigatorUserMediaError extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.constraintName]() {
      return this.constraintName;
    }
    get [dartx.message]() {
      return this.message;
    }
    get [dartx.name]() {
      return this.name;
    }
  }
  dart.setSignature(NavigatorUserMediaError, {
    constructors: () => ({_: [NavigatorUserMediaError, []]})
  });
  NavigatorUserMediaError[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('NavigatorUserMediaError')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("NavigatorUserMediaError"))];
  dart.registerExtension(dart.global.NavigatorUserMediaError, NavigatorUserMediaError);
  const _NavigatorUserMediaErrorCallback = dart.typedef('_NavigatorUserMediaErrorCallback', () => dart.functionType(dart.void, [NavigatorUserMediaError]));
  const _NavigatorUserMediaSuccessCallback = dart.typedef('_NavigatorUserMediaSuccessCallback', () => dart.functionType(dart.void, [MediaStream]));
  dart.defineExtensionNames([
    'type'
  ]);
  class NetworkInformation extends EventTarget {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.type]() {
      return this.type;
    }
  }
  dart.setSignature(NetworkInformation, {
    constructors: () => ({_: [NetworkInformation, []]})
  });
  NetworkInformation[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('NetworkInformation')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("NetworkInformation"))];
  dart.registerExtension(dart.global.NetworkInformation, NetworkInformation);
  class _ChildNodeListLazy extends collection.ListBase$(Node) {
    _ChildNodeListLazy(this$) {
      this[_this] = this$;
    }
    get first() {
      let result = dart.as(this[_this].firstChild, Node);
      if (result == null) dart.throw(new core.StateError("No elements"));
      return result;
    }
    get last() {
      let result = dart.as(this[_this].lastChild, Node);
      if (result == null) dart.throw(new core.StateError("No elements"));
      return result;
    }
    get single() {
      let l = this.length;
      if (l == 0) dart.throw(new core.StateError("No elements"));
      if (dart.notNull(l) > 1) dart.throw(new core.StateError("More than one element"));
      return dart.as(this[_this].firstChild, Node);
    }
    add(value) {
      this[_this][dartx.append](value);
    }
    addAll(iterable) {
      if (dart.is(iterable, _ChildNodeListLazy)) {
        let otherList = iterable;
        if (!core.identical(otherList[_this], this[_this])) {
          for (let i = 0, len = otherList.length; i < dart.notNull(len); ++i) {
            this[_this][dartx.append](otherList[_this][dartx.firstChild]);
          }
        }
        return;
      }
      for (let node of iterable) {
        this[_this][dartx.append](node);
      }
    }
    insert(index, node) {
      if (dart.notNull(index) < 0 || dart.notNull(index) > dart.notNull(this.length)) {
        dart.throw(new core.RangeError.range(index, 0, this.length));
      }
      if (index == this.length) {
        this[_this][dartx.append](node);
      } else {
        this[_this][dartx.insertBefore](node, this.get(index));
      }
    }
    insertAll(index, iterable) {
      if (index == this.length) {
        this.addAll(iterable);
      } else {
        let item = this.get(index);
        this[_this][dartx.insertAllBefore](iterable, item);
      }
    }
    setAll(index, iterable) {
      dart.throw(new core.UnsupportedError("Cannot setAll on Node list"));
    }
    removeLast() {
      let result = this.last;
      if (result != null) {
        this[_this][_removeChild](result);
      }
      return result;
    }
    removeAt(index) {
      let result = this.get(index);
      if (result != null) {
        this[_this][_removeChild](result);
      }
      return result;
    }
    remove(object) {
      if (!dart.is(object, Node)) return false;
      let node = dart.as(object, Node);
      if (!core.identical(this[_this], node[dartx.parentNode])) return false;
      this[_this][_removeChild](node);
      return true;
    }
    [_filter](test, removeMatching) {
      let child = this[_this][dartx.firstChild];
      while (child != null) {
        let nextChild = child[dartx.nextNode];
        if (test(child) == removeMatching) {
          this[_this][_removeChild](child);
        }
        child = nextChild;
      }
    }
    removeWhere(test) {
      this[_filter](test, true);
    }
    retainWhere(test) {
      this[_filter](test, false);
    }
    clear() {
      this[_this][_clearChildren]();
    }
    set(index, value) {
      this[_this][_replaceChild](value, this.get(index));
      return value;
    }
    get iterator() {
      return this[_this][dartx.childNodes][dartx.iterator];
    }
    sort(compare) {
      if (compare === void 0) compare = null;
      dart.throw(new core.UnsupportedError("Cannot sort Node list"));
    }
    shuffle(random) {
      if (random === void 0) random = null;
      dart.throw(new core.UnsupportedError("Cannot shuffle Node list"));
    }
    setRange(start, end, iterable, skipCount) {
      if (skipCount === void 0) skipCount = 0;
      dart.throw(new core.UnsupportedError("Cannot setRange on Node list"));
    }
    fillRange(start, end, fill) {
      if (fill === void 0) fill = null;
      dart.throw(new core.UnsupportedError("Cannot fillRange on Node list"));
    }
    get length() {
      return this[_this][dartx.childNodes][dartx.length];
    }
    set length(value) {
      dart.throw(new core.UnsupportedError("Cannot set length on immutable List."));
    }
    get(index) {
      return this[_this][dartx.childNodes][dartx.get](index);
    }
    get rawList() {
      return this[_this][dartx.childNodes];
    }
  }
  _ChildNodeListLazy[dart.implements] = () => [html_common.NodeListWrapper];
  dart.setSignature(_ChildNodeListLazy, {
    constructors: () => ({_ChildNodeListLazy: [_ChildNodeListLazy, [Node]]}),
    methods: () => ({
      add: [dart.void, [Node]],
      addAll: [dart.void, [core.Iterable$(Node)]],
      insert: [dart.void, [core.int, Node]],
      insertAll: [dart.void, [core.int, core.Iterable$(Node)]],
      setAll: [dart.void, [core.int, core.Iterable$(Node)]],
      removeLast: [Node, []],
      removeAt: [Node, [core.int]],
      [_filter]: [dart.void, [dart.functionType(core.bool, [Node]), core.bool]],
      removeWhere: [dart.void, [dart.functionType(core.bool, [Node])]],
      retainWhere: [dart.void, [dart.functionType(core.bool, [Node])]],
      set: [dart.void, [core.int, Node]],
      sort: [dart.void, [], [core.Comparator$(Node)]],
      setRange: [dart.void, [core.int, core.int, core.Iterable$(Node)], [core.int]],
      fillRange: [dart.void, [core.int, core.int], [Node]],
      get: [Node, [core.int]]
    })
  });
  dart.defineExtensionMembers(_ChildNodeListLazy, [
    'add',
    'addAll',
    'insert',
    'insertAll',
    'setAll',
    'removeLast',
    'removeAt',
    'remove',
    'removeWhere',
    'retainWhere',
    'clear',
    'set',
    'sort',
    'shuffle',
    'setRange',
    'fillRange',
    'get',
    'first',
    'last',
    'single',
    'iterator',
    'length',
    'length'
  ]);
  class NodeFilter extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
  }
  dart.setSignature(NodeFilter, {
    constructors: () => ({_: [NodeFilter, []]})
  });
  NodeFilter[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('NodeFilter')), dart.const(new _metadata.Unstable()), dart.const(new _js_helper.Native("NodeFilter"))];
  NodeFilter.FILTER_ACCEPT = 1;
  NodeFilter.FILTER_REJECT = 2;
  NodeFilter.FILTER_SKIP = 3;
  NodeFilter.SHOW_ALL = 4294967295;
  NodeFilter.SHOW_COMMENT = 128;
  NodeFilter.SHOW_DOCUMENT = 256;
  NodeFilter.SHOW_DOCUMENT_FRAGMENT = 1024;
  NodeFilter.SHOW_DOCUMENT_TYPE = 512;
  NodeFilter.SHOW_ELEMENT = 1;
  NodeFilter.SHOW_PROCESSING_INSTRUCTION = 64;
  NodeFilter.SHOW_TEXT = 4;
  dart.registerExtension(dart.global.NodeFilter, NodeFilter);
  dart.defineExtensionNames([
    'detach',
    'nextNode',
    'previousNode',
    'pointerBeforeReferenceNode',
    'referenceNode',
    'root',
    'whatToShow'
  ]);
  class NodeIterator extends _interceptors.Interceptor {
    static new(root, whatToShow) {
      return exports.document[_createNodeIterator](root, whatToShow, null);
    }
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.pointerBeforeReferenceNode]() {
      return this.pointerBeforeReferenceNode;
    }
    get [dartx.referenceNode]() {
      return this.referenceNode;
    }
    get [dartx.root]() {
      return this.root;
    }
    get [dartx.whatToShow]() {
      return this.whatToShow;
    }
    [dartx.detach]() {
      return this.detach();
    }
    [dartx.nextNode]() {
      return this.nextNode();
    }
    [dartx.previousNode]() {
      return this.previousNode();
    }
  }
  dart.setSignature(NodeIterator, {
    constructors: () => ({
      new: [NodeIterator, [Node, core.int]],
      _: [NodeIterator, []]
    }),
    methods: () => ({
      [dartx.detach]: [dart.void, []],
      [dartx.nextNode]: [Node, []],
      [dartx.previousNode]: [Node, []]
    })
  });
  NodeIterator[dart.metadata] = () => [dart.const(new _metadata.DomName('NodeIterator')), dart.const(new _metadata.Unstable()), dart.const(new _js_helper.Native("NodeIterator"))];
  dart.registerExtension(dart.global.NodeIterator, NodeIterator);
  const _item = Symbol('_item');
  dart.defineExtensionNames([
    'length',
    'get',
    'set',
    'length',
    'first',
    'last',
    'single',
    'elementAt'
  ]);
  class NodeList extends dart.mixin(_interceptors.Interceptor, collection.ListMixin$(Node), ImmutableListMixin$(Node)) {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.length]() {
      return this.length;
    }
    [dartx.get](index) {
      if (index >>> 0 !== index || index >= this[dartx.length]) dart.throw(core.RangeError.index(index, this));
      return dart.as(this[index], Node);
    }
    [dartx.set](index, value) {
      dart.throw(new core.UnsupportedError("Cannot assign element of immutable List."));
      return value;
    }
    set [dartx.length](value) {
      dart.throw(new core.UnsupportedError("Cannot resize immutable List."));
    }
    get [dartx.first]() {
      if (dart.notNull(this[dartx.length]) > 0) {
        return dart.as(this[0], Node);
      }
      dart.throw(new core.StateError("No elements"));
    }
    get [dartx.last]() {
      let len = this[dartx.length];
      if (dart.notNull(len) > 0) {
        return dart.as(this[dart.notNull(len) - 1], Node);
      }
      dart.throw(new core.StateError("No elements"));
    }
    get [dartx.single]() {
      let len = this[dartx.length];
      if (len == 1) {
        return dart.as(this[0], Node);
      }
      if (len == 0) dart.throw(new core.StateError("No elements"));
      dart.throw(new core.StateError("More than one element"));
    }
    [dartx.elementAt](index) {
      return this[dartx.get](index);
    }
    [_item](index) {
      return this.item(index);
    }
  }
  NodeList[dart.implements] = () => [_js_helper.JavaScriptIndexingBehavior, core.List$(Node)];
  dart.setSignature(NodeList, {
    constructors: () => ({_: [NodeList, []]}),
    methods: () => ({
      [dartx.get]: [Node, [core.int]],
      [dartx.set]: [dart.void, [core.int, Node]],
      [dartx.elementAt]: [Node, [core.int]],
      [_item]: [Node, [core.int]]
    })
  });
  NodeList[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('NodeList')), dart.const(new _js_helper.Native("NodeList,RadioNodeList"))];
  dart.registerExtension(dart.global.NodeList, NodeList);
  dart.defineExtensionNames([
    'close',
    'onClick',
    'onClose',
    'onError',
    'onShow',
    'body',
    'dir',
    'icon',
    'lang',
    'permission',
    'tag',
    'title'
  ]);
  class Notification extends EventTarget {
    static new(title, opts) {
      let dir = opts && 'dir' in opts ? opts.dir : null;
      let body = opts && 'body' in opts ? opts.body : null;
      let lang = opts && 'lang' in opts ? opts.lang : null;
      let tag = opts && 'tag' in opts ? opts.tag : null;
      let icon = opts && 'icon' in opts ? opts.icon : null;
      let parsedOptions = dart.map();
      if (dir != null) parsedOptions[dartx.set]('dir', dir);
      if (body != null) parsedOptions[dartx.set]('body', body);
      if (lang != null) parsedOptions[dartx.set]('lang', lang);
      if (tag != null) parsedOptions[dartx.set]('tag', tag);
      if (icon != null) parsedOptions[dartx.set]('icon', icon);
      return Notification._factoryNotification(title, parsedOptions);
    }
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static _factoryNotification(title, options) {
      if (options === void 0) options = null;
      if (options != null) {
        let options_1 = html_common.convertDartToNative_Dictionary(options);
        return Notification._create_1(title, options_1);
      }
      return Notification._create_2(title);
    }
    static _create_1(title, options) {
      return dart.as(new Notification(title, options), Notification);
    }
    static _create_2(title) {
      return dart.as(new Notification(title), Notification);
    }
    static get supported() {
      return !!window.Notification;
    }
    get [dartx.body]() {
      return this.body;
    }
    get [dartx.dir]() {
      return this.dir;
    }
    get [dartx.icon]() {
      return this.icon;
    }
    get [dartx.lang]() {
      return this.lang;
    }
    get [dartx.permission]() {
      return this.permission;
    }
    get [dartx.tag]() {
      return this.tag;
    }
    get [dartx.title]() {
      return this.title;
    }
    [dartx.close]() {
      return this.close();
    }
    static requestPermission() {
      let completer = async.Completer$(core.String).new();
      Notification._requestPermission(dart.fn(value => {
        completer.complete(value);
      }, dart.void, [core.String]));
      return completer.future;
    }
    get [dartx.onClick]() {
      return Notification.clickEvent.forTarget(this);
    }
    get [dartx.onClose]() {
      return Notification.closeEvent.forTarget(this);
    }
    get [dartx.onError]() {
      return Notification.errorEvent.forTarget(this);
    }
    get [dartx.onShow]() {
      return Notification.showEvent.forTarget(this);
    }
  }
  dart.setSignature(Notification, {
    constructors: () => ({
      new: [Notification, [core.String], {dir: core.String, body: core.String, lang: core.String, tag: core.String, icon: core.String}],
      _: [Notification, []]
    }),
    methods: () => ({[dartx.close]: [dart.void, []]}),
    statics: () => ({
      _factoryNotification: [Notification, [core.String], [core.Map]],
      _create_1: [Notification, [dart.dynamic, dart.dynamic]],
      _create_2: [Notification, [dart.dynamic]],
      _requestPermission: [dart.void, [], [_NotificationPermissionCallback]],
      requestPermission: [async.Future$(core.String), []]
    }),
    names: ['_factoryNotification', '_create_1', '_create_2', '_requestPermission', 'requestPermission']
  });
  Notification[dart.metadata] = () => [dart.const(new _metadata.DomName('Notification')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("Notification"))];
  dart.defineLazyProperties(Notification, {
    get clickEvent() {
      return dart.const(new (EventStreamProvider$(Event))('click'));
    },
    get closeEvent() {
      return dart.const(new (EventStreamProvider$(Event))('close'));
    },
    get errorEvent() {
      return dart.const(new (EventStreamProvider$(Event))('error'));
    },
    get showEvent() {
      return dart.const(new (EventStreamProvider$(Event))('show'));
    }
  });
  dart.registerExtension(dart.global.Notification, Notification);
  const _NotificationPermissionCallback = dart.typedef('_NotificationPermissionCallback', () => dart.functionType(dart.void, [core.String]));
  dart.defineExtensionNames([
    'reversed',
    'start',
    'type'
  ]);
  class OListElement extends HtmlElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return dart.as(exports.document[dartx.createElement]("ol"), OListElement);
    }
    created() {
      this[dartx.reversed] = null;
      this[dartx.start] = null;
      this[dartx.type] = null;
      super.created();
    }
    get [dartx.reversed]() {
      return this.reversed;
    }
    set [dartx.reversed](value) {
      this.reversed = value;
    }
    get [dartx.start]() {
      return this.start;
    }
    set [dartx.start](value) {
      this.start = value;
    }
    get [dartx.type]() {
      return this.type;
    }
    set [dartx.type](value) {
      this.type = value;
    }
  }
  dart.defineNamedConstructor(OListElement, 'created');
  dart.setSignature(OListElement, {
    constructors: () => ({
      _: [OListElement, []],
      new: [OListElement, []],
      created: [OListElement, []]
    })
  });
  OListElement[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('HTMLOListElement')), dart.const(new _js_helper.Native("HTMLOListElement"))];
  dart.registerExtension(dart.global.HTMLOListElement, OListElement);
  dart.defineExtensionNames([
    'checkValidity',
    'setCustomValidity',
    'data',
    'form',
    'height',
    'integrity',
    'name',
    'type',
    'useMap',
    'validationMessage',
    'validity',
    'width',
    'willValidate'
  ]);
  class ObjectElement extends HtmlElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return dart.as(exports.document[dartx.createElement]("object"), ObjectElement);
    }
    created() {
      this[dartx.data] = null;
      this[dartx.form] = null;
      this[dartx.height] = null;
      this[dartx.integrity] = null;
      this[dartx.name] = null;
      this[dartx.type] = null;
      this[dartx.useMap] = null;
      this[dartx.validationMessage] = null;
      this[dartx.validity] = null;
      this[dartx.width] = null;
      this[dartx.willValidate] = null;
      super.created();
    }
    static get supported() {
      return Element.isTagSupported('object');
    }
    get [dartx.data]() {
      return this.data;
    }
    set [dartx.data](value) {
      this.data = value;
    }
    get [dartx.form]() {
      return this.form;
    }
    get [dartx.height]() {
      return this.height;
    }
    set [dartx.height](value) {
      this.height = value;
    }
    get [dartx.integrity]() {
      return this.integrity;
    }
    set [dartx.integrity](value) {
      this.integrity = value;
    }
    get [dartx.name]() {
      return this.name;
    }
    set [dartx.name](value) {
      this.name = value;
    }
    get [dartx.type]() {
      return this.type;
    }
    set [dartx.type](value) {
      this.type = value;
    }
    get [dartx.useMap]() {
      return this.useMap;
    }
    set [dartx.useMap](value) {
      this.useMap = value;
    }
    get [dartx.validationMessage]() {
      return this.validationMessage;
    }
    get [dartx.validity]() {
      return this.validity;
    }
    get [dartx.width]() {
      return this.width;
    }
    set [dartx.width](value) {
      this.width = value;
    }
    get [dartx.willValidate]() {
      return this.willValidate;
    }
    [__getter__](index_OR_name) {
      return this.__getter__(index_OR_name);
    }
    [__setter__](index_OR_name, value) {
      return this.__setter__(index_OR_name, value);
    }
    [dartx.checkValidity]() {
      return this.checkValidity();
    }
    [dartx.setCustomValidity](error) {
      return this.setCustomValidity(error);
    }
  }
  dart.defineNamedConstructor(ObjectElement, 'created');
  dart.setSignature(ObjectElement, {
    constructors: () => ({
      _: [ObjectElement, []],
      new: [ObjectElement, []],
      created: [ObjectElement, []]
    }),
    methods: () => ({
      [__getter__]: [core.bool, [dart.dynamic]],
      [__setter__]: [dart.void, [dart.dynamic, Node]],
      [dartx.checkValidity]: [core.bool, []],
      [dartx.setCustomValidity]: [dart.void, [core.String]]
    })
  });
  ObjectElement[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('HTMLObjectElement')), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.CHROME)), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.IE)), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.SAFARI)), dart.const(new _metadata.Unstable()), dart.const(new _js_helper.Native("HTMLObjectElement"))];
  dart.registerExtension(dart.global.HTMLObjectElement, ObjectElement);
  dart.defineExtensionNames([
    'disabled',
    'label'
  ]);
  class OptGroupElement extends HtmlElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return dart.as(exports.document[dartx.createElement]("optgroup"), OptGroupElement);
    }
    created() {
      this[dartx.disabled] = null;
      this[dartx.label] = null;
      super.created();
    }
    get [dartx.disabled]() {
      return this.disabled;
    }
    set [dartx.disabled](value) {
      this.disabled = value;
    }
    get [dartx.label]() {
      return this.label;
    }
    set [dartx.label](value) {
      this.label = value;
    }
  }
  dart.defineNamedConstructor(OptGroupElement, 'created');
  dart.setSignature(OptGroupElement, {
    constructors: () => ({
      _: [OptGroupElement, []],
      new: [OptGroupElement, []],
      created: [OptGroupElement, []]
    })
  });
  OptGroupElement[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('HTMLOptGroupElement')), dart.const(new _js_helper.Native("HTMLOptGroupElement"))];
  dart.registerExtension(dart.global.HTMLOptGroupElement, OptGroupElement);
  dart.defineExtensionNames([
    'defaultSelected',
    'disabled',
    'form',
    'index',
    'label',
    'selected',
    'value'
  ]);
  class OptionElement extends HtmlElement {
    static new(opts) {
      let data = opts && 'data' in opts ? opts.data : '';
      let value = opts && 'value' in opts ? opts.value : '';
      let selected = opts && 'selected' in opts ? opts.selected : false;
      return OptionElement._(data, value, null, selected);
    }
    static _(data, value, defaultSelected, selected) {
      if (data === void 0) data = null;
      if (value === void 0) value = null;
      if (defaultSelected === void 0) defaultSelected = null;
      if (selected === void 0) selected = null;
      if (selected != null) {
        return OptionElement._create_1(data, value, defaultSelected, selected);
      }
      if (defaultSelected != null) {
        return OptionElement._create_2(data, value, defaultSelected);
      }
      if (value != null) {
        return OptionElement._create_3(data, value);
      }
      if (data != null) {
        return OptionElement._create_4(data);
      }
      return OptionElement._create_5();
    }
    static _create_1(data, value, defaultSelected, selected) {
      return dart.as(new Option(data, value, defaultSelected, selected), OptionElement);
    }
    static _create_2(data, value, defaultSelected) {
      return dart.as(new Option(data, value, defaultSelected), OptionElement);
    }
    static _create_3(data, value) {
      return dart.as(new Option(data, value), OptionElement);
    }
    static _create_4(data) {
      return dart.as(new Option(data), OptionElement);
    }
    static _create_5() {
      return dart.as(new Option(), OptionElement);
    }
    created() {
      this[dartx.defaultSelected] = null;
      this[dartx.disabled] = null;
      this[dartx.form] = null;
      this[dartx.index] = null;
      this[dartx.label] = null;
      this[dartx.selected] = null;
      this[dartx.value] = null;
      super.created();
    }
    get [dartx.defaultSelected]() {
      return this.defaultSelected;
    }
    set [dartx.defaultSelected](value) {
      this.defaultSelected = value;
    }
    get [dartx.disabled]() {
      return this.disabled;
    }
    set [dartx.disabled](value) {
      this.disabled = value;
    }
    get [dartx.form]() {
      return this.form;
    }
    get [dartx.index]() {
      return this.index;
    }
    get [dartx.label]() {
      return this.label;
    }
    set [dartx.label](value) {
      this.label = value;
    }
    get [dartx.selected]() {
      return this.selected;
    }
    set [dartx.selected](value) {
      this.selected = value;
    }
    get [dartx.value]() {
      return this.value;
    }
    set [dartx.value](value) {
      this.value = value;
    }
  }
  dart.defineNamedConstructor(OptionElement, 'created');
  dart.setSignature(OptionElement, {
    constructors: () => ({
      new: [OptionElement, [], {data: core.String, value: core.String, selected: core.bool}],
      _: [OptionElement, [], [core.String, core.String, core.bool, core.bool]],
      created: [OptionElement, []]
    }),
    statics: () => ({
      _create_1: [OptionElement, [dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic]],
      _create_2: [OptionElement, [dart.dynamic, dart.dynamic, dart.dynamic]],
      _create_3: [OptionElement, [dart.dynamic, dart.dynamic]],
      _create_4: [OptionElement, [dart.dynamic]],
      _create_5: [OptionElement, []]
    }),
    names: ['_create_1', '_create_2', '_create_3', '_create_4', '_create_5']
  });
  OptionElement[dart.metadata] = () => [dart.const(new _metadata.DomName('HTMLOptionElement')), dart.const(new _js_helper.Native("HTMLOptionElement"))];
  dart.registerExtension(dart.global.HTMLOptionElement, OptionElement);
  dart.defineExtensionNames([
    'checkValidity',
    'setCustomValidity',
    'defaultValue',
    'form',
    'htmlFor',
    'labels',
    'name',
    'type',
    'validationMessage',
    'validity',
    'value',
    'willValidate'
  ]);
  class OutputElement extends HtmlElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return dart.as(exports.document[dartx.createElement]("output"), OutputElement);
    }
    created() {
      this[dartx.defaultValue] = null;
      this[dartx.form] = null;
      this[dartx.htmlFor] = null;
      this[dartx.labels] = null;
      this[dartx.name] = null;
      this[dartx.type] = null;
      this[dartx.validationMessage] = null;
      this[dartx.validity] = null;
      this[dartx.value] = null;
      this[dartx.willValidate] = null;
      super.created();
    }
    static get supported() {
      return Element.isTagSupported('output');
    }
    get [dartx.defaultValue]() {
      return this.defaultValue;
    }
    set [dartx.defaultValue](value) {
      this.defaultValue = value;
    }
    get [dartx.form]() {
      return this.form;
    }
    get [dartx.htmlFor]() {
      return this.htmlFor;
    }
    get [dartx.labels]() {
      return this.labels;
    }
    get [dartx.name]() {
      return this.name;
    }
    set [dartx.name](value) {
      this.name = value;
    }
    get [dartx.type]() {
      return this.type;
    }
    get [dartx.validationMessage]() {
      return this.validationMessage;
    }
    get [dartx.validity]() {
      return this.validity;
    }
    get [dartx.value]() {
      return this.value;
    }
    set [dartx.value](value) {
      this.value = value;
    }
    get [dartx.willValidate]() {
      return this.willValidate;
    }
    [dartx.checkValidity]() {
      return this.checkValidity();
    }
    [dartx.setCustomValidity](error) {
      return this.setCustomValidity(error);
    }
  }
  dart.defineNamedConstructor(OutputElement, 'created');
  dart.setSignature(OutputElement, {
    constructors: () => ({
      _: [OutputElement, []],
      new: [OutputElement, []],
      created: [OutputElement, []]
    }),
    methods: () => ({
      [dartx.checkValidity]: [core.bool, []],
      [dartx.setCustomValidity]: [dart.void, [core.String]]
    })
  });
  OutputElement[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('HTMLOutputElement')), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.CHROME)), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.FIREFOX)), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.SAFARI)), dart.const(new _js_helper.Native("HTMLOutputElement"))];
  dart.registerExtension(dart.global.HTMLOutputElement, OutputElement);
  dart.defineExtensionNames([
    'horizontalOverflow',
    'orient',
    'verticalOverflow'
  ]);
  class OverflowEvent extends Event {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.horizontalOverflow]() {
      return this.horizontalOverflow;
    }
    get [dartx.orient]() {
      return this.orient;
    }
    get [dartx.verticalOverflow]() {
      return this.verticalOverflow;
    }
  }
  dart.setSignature(OverflowEvent, {
    constructors: () => ({_: [OverflowEvent, []]})
  });
  OverflowEvent[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('OverflowEvent')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("OverflowEvent"))];
  OverflowEvent.BOTH = 2;
  OverflowEvent.HORIZONTAL = 0;
  OverflowEvent.VERTICAL = 1;
  dart.registerExtension(dart.global.OverflowEvent, OverflowEvent);
  dart.defineExtensionNames([
    'persisted'
  ]);
  class PageTransitionEvent extends Event {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.persisted]() {
      return this.persisted;
    }
  }
  dart.setSignature(PageTransitionEvent, {
    constructors: () => ({_: [PageTransitionEvent, []]})
  });
  PageTransitionEvent[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('PageTransitionEvent')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("PageTransitionEvent"))];
  dart.registerExtension(dart.global.PageTransitionEvent, PageTransitionEvent);
  class ParagraphElement extends HtmlElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return dart.as(exports.document[dartx.createElement]("p"), ParagraphElement);
    }
    created() {
      super.created();
    }
  }
  dart.defineNamedConstructor(ParagraphElement, 'created');
  dart.setSignature(ParagraphElement, {
    constructors: () => ({
      _: [ParagraphElement, []],
      new: [ParagraphElement, []],
      created: [ParagraphElement, []]
    })
  });
  ParagraphElement[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('HTMLParagraphElement')), dart.const(new _js_helper.Native("HTMLParagraphElement"))];
  dart.registerExtension(dart.global.HTMLParagraphElement, ParagraphElement);
  dart.defineExtensionNames([
    'name',
    'value'
  ]);
  class ParamElement extends HtmlElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return dart.as(exports.document[dartx.createElement]("param"), ParamElement);
    }
    created() {
      this[dartx.name] = null;
      this[dartx.value] = null;
      super.created();
    }
    get [dartx.name]() {
      return this.name;
    }
    set [dartx.name](value) {
      this.name = value;
    }
    get [dartx.value]() {
      return this.value;
    }
    set [dartx.value](value) {
      this.value = value;
    }
  }
  dart.defineNamedConstructor(ParamElement, 'created');
  dart.setSignature(ParamElement, {
    constructors: () => ({
      _: [ParamElement, []],
      new: [ParamElement, []],
      created: [ParamElement, []]
    })
  });
  ParamElement[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('HTMLParamElement')), dart.const(new _metadata.Unstable()), dart.const(new _js_helper.Native("HTMLParamElement"))];
  dart.registerExtension(dart.global.HTMLParamElement, ParamElement);
  class ParentNode extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [_childElementCount]() {
      return this._childElementCount;
    }
    get [_children]() {
      return this._children;
    }
    get [_firstElementChild]() {
      return this._firstElementChild;
    }
    get [_lastElementChild]() {
      return this._lastElementChild;
    }
  }
  dart.setSignature(ParentNode, {
    constructors: () => ({_: [ParentNode, []]})
  });
  ParentNode[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('ParentNode')), dart.const(new _metadata.Experimental())];
  dart.defineExtensionNames([
    'addPath',
    'arc',
    'arcTo',
    'bezierCurveTo',
    'closePath',
    'ellipse',
    'lineTo',
    'moveTo',
    'quadraticCurveTo',
    'rect'
  ]);
  class Path2D extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new(path_OR_text) {
      if (path_OR_text === void 0) path_OR_text = null;
      if (path_OR_text == null) {
        return Path2D._create_1();
      }
      if (dart.is(path_OR_text, Path2D) || path_OR_text == null) {
        return Path2D._create_2(path_OR_text);
      }
      if (typeof path_OR_text == 'string' || path_OR_text == null) {
        return Path2D._create_3(path_OR_text);
      }
      dart.throw(new core.ArgumentError("Incorrect number or type of arguments"));
    }
    static _create_1() {
      return dart.as(new Path2D(), Path2D);
    }
    static _create_2(path_OR_text) {
      return dart.as(new Path2D(path_OR_text), Path2D);
    }
    static _create_3(path_OR_text) {
      return dart.as(new Path2D(path_OR_text), Path2D);
    }
    [dartx.addPath](path, transform) {
      return this.addPath(path, transform);
    }
    [dartx.arc](x, y, radius, startAngle, endAngle, anticlockwise) {
      return this.arc(x, y, radius, startAngle, endAngle, anticlockwise);
    }
    [dartx.arcTo](x1, y1, x2, y2, radius) {
      return this.arcTo(x1, y1, x2, y2, radius);
    }
    [dartx.bezierCurveTo](cp1x, cp1y, cp2x, cp2y, x, y) {
      return this.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);
    }
    [dartx.closePath]() {
      return this.closePath();
    }
    [dartx.ellipse](x, y, radiusX, radiusY, rotation, startAngle, endAngle, anticlockwise) {
      return this.ellipse(x, y, radiusX, radiusY, rotation, startAngle, endAngle, anticlockwise);
    }
    [dartx.lineTo](x, y) {
      return this.lineTo(x, y);
    }
    [dartx.moveTo](x, y) {
      return this.moveTo(x, y);
    }
    [dartx.quadraticCurveTo](cpx, cpy, x, y) {
      return this.quadraticCurveTo(cpx, cpy, x, y);
    }
    [dartx.rect](x, y, width, height) {
      return this.rect(x, y, width, height);
    }
  }
  Path2D[dart.implements] = () => [_CanvasPathMethods];
  dart.setSignature(Path2D, {
    constructors: () => ({
      _: [Path2D, []],
      new: [Path2D, [], [dart.dynamic]]
    }),
    methods: () => ({
      [dartx.addPath]: [dart.void, [Path2D], [svg.Matrix]],
      [dartx.arc]: [dart.void, [core.num, core.num, core.num, core.num, core.num, core.bool]],
      [dartx.arcTo]: [dart.void, [core.num, core.num, core.num, core.num, core.num]],
      [dartx.bezierCurveTo]: [dart.void, [core.num, core.num, core.num, core.num, core.num, core.num]],
      [dartx.closePath]: [dart.void, []],
      [dartx.ellipse]: [dart.void, [core.num, core.num, core.num, core.num, core.num, core.num, core.num, core.bool]],
      [dartx.lineTo]: [dart.void, [core.num, core.num]],
      [dartx.moveTo]: [dart.void, [core.num, core.num]],
      [dartx.quadraticCurveTo]: [dart.void, [core.num, core.num, core.num, core.num]],
      [dartx.rect]: [dart.void, [core.num, core.num, core.num, core.num]]
    }),
    statics: () => ({
      _create_1: [Path2D, []],
      _create_2: [Path2D, [dart.dynamic]],
      _create_3: [Path2D, [dart.dynamic]]
    }),
    names: ['_create_1', '_create_2', '_create_3']
  });
  Path2D[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('Path2D')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("Path2D"))];
  dart.registerExtension(dart.global.Path2D, Path2D);
  dart.defineExtensionNames([
    'clearMarks',
    'clearMeasures',
    'getEntries',
    'getEntriesByName',
    'getEntriesByType',
    'mark',
    'measure',
    'now',
    'clearResourceTimings',
    'setResourceTimingBufferSize',
    'onResourceTimingBufferFull',
    'memory',
    'navigation',
    'timing'
  ]);
  class Performance extends EventTarget {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static get supported() {
      return !!window.performance;
    }
    get [dartx.memory]() {
      return this.memory;
    }
    get [dartx.navigation]() {
      return this.navigation;
    }
    get [dartx.timing]() {
      return this.timing;
    }
    [dartx.clearMarks](markName) {
      return this.clearMarks(markName);
    }
    [dartx.clearMeasures](measureName) {
      return this.clearMeasures(measureName);
    }
    [dartx.getEntries]() {
      return this.getEntries();
    }
    [dartx.getEntriesByName](name, entryType) {
      return this.getEntriesByName(name, entryType);
    }
    [dartx.getEntriesByType](entryType) {
      return this.getEntriesByType(entryType);
    }
    [dartx.mark](markName) {
      return this.mark(markName);
    }
    [dartx.measure](measureName, startMark, endMark) {
      return this.measure(measureName, startMark, endMark);
    }
    [dartx.now]() {
      return this.now();
    }
    [dartx.clearResourceTimings]() {
      return this.webkitClearResourceTimings();
    }
    [dartx.setResourceTimingBufferSize](maxSize) {
      return this.webkitSetResourceTimingBufferSize(maxSize);
    }
    get [dartx.onResourceTimingBufferFull]() {
      return Performance.resourceTimingBufferFullEvent.forTarget(this);
    }
  }
  dart.setSignature(Performance, {
    constructors: () => ({_: [Performance, []]}),
    methods: () => ({
      [dartx.clearMarks]: [dart.void, [core.String]],
      [dartx.clearMeasures]: [dart.void, [core.String]],
      [dartx.getEntries]: [core.List$(PerformanceEntry), []],
      [dartx.getEntriesByName]: [core.List$(PerformanceEntry), [core.String, core.String]],
      [dartx.getEntriesByType]: [core.List$(PerformanceEntry), [core.String]],
      [dartx.mark]: [dart.void, [core.String]],
      [dartx.measure]: [dart.void, [core.String, core.String, core.String]],
      [dartx.now]: [core.double, []],
      [dartx.clearResourceTimings]: [dart.void, []],
      [dartx.setResourceTimingBufferSize]: [dart.void, [core.int]]
    })
  });
  Performance[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('Performance')), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.CHROME)), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.FIREFOX)), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.IE)), dart.const(new _js_helper.Native("Performance"))];
  dart.defineLazyProperties(Performance, {
    get resourceTimingBufferFullEvent() {
      return dart.const(new (EventStreamProvider$(Event))('webkitresourcetimingbufferfull'));
    }
  });
  dart.registerExtension(dart.global.Performance, Performance);
  dart.defineExtensionNames([
    'duration',
    'entryType',
    'name',
    'startTime'
  ]);
  class PerformanceEntry extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.duration]() {
      return this.duration;
    }
    get [dartx.entryType]() {
      return this.entryType;
    }
    get [dartx.name]() {
      return this.name;
    }
    get [dartx.startTime]() {
      return this.startTime;
    }
  }
  dart.setSignature(PerformanceEntry, {
    constructors: () => ({_: [PerformanceEntry, []]})
  });
  PerformanceEntry[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('PerformanceEntry')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("PerformanceEntry"))];
  dart.registerExtension(dart.global.PerformanceEntry, PerformanceEntry);
  class PerformanceMark extends PerformanceEntry {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
  }
  dart.setSignature(PerformanceMark, {
    constructors: () => ({_: [PerformanceMark, []]})
  });
  PerformanceMark[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('PerformanceMark')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("PerformanceMark"))];
  dart.registerExtension(dart.global.PerformanceMark, PerformanceMark);
  class PerformanceMeasure extends PerformanceEntry {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
  }
  dart.setSignature(PerformanceMeasure, {
    constructors: () => ({_: [PerformanceMeasure, []]})
  });
  PerformanceMeasure[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('PerformanceMeasure')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("PerformanceMeasure"))];
  dart.registerExtension(dart.global.PerformanceMeasure, PerformanceMeasure);
  dart.defineExtensionNames([
    'redirectCount',
    'type'
  ]);
  class PerformanceNavigation extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.redirectCount]() {
      return this.redirectCount;
    }
    get [dartx.type]() {
      return this.type;
    }
  }
  dart.setSignature(PerformanceNavigation, {
    constructors: () => ({_: [PerformanceNavigation, []]})
  });
  PerformanceNavigation[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('PerformanceNavigation')), dart.const(new _metadata.Unstable()), dart.const(new _js_helper.Native("PerformanceNavigation"))];
  PerformanceNavigation.TYPE_BACK_FORWARD = 2;
  PerformanceNavigation.TYPE_NAVIGATE = 0;
  PerformanceNavigation.TYPE_RELOAD = 1;
  PerformanceNavigation.TYPE_RESERVED = 255;
  dart.registerExtension(dart.global.PerformanceNavigation, PerformanceNavigation);
  dart.defineExtensionNames([
    'connectEnd',
    'connectStart',
    'domainLookupEnd',
    'domainLookupStart',
    'fetchStart',
    'initiatorType',
    'redirectEnd',
    'redirectStart',
    'requestStart',
    'responseEnd',
    'responseStart',
    'secureConnectionStart'
  ]);
  class PerformanceResourceTiming extends PerformanceEntry {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.connectEnd]() {
      return this.connectEnd;
    }
    get [dartx.connectStart]() {
      return this.connectStart;
    }
    get [dartx.domainLookupEnd]() {
      return this.domainLookupEnd;
    }
    get [dartx.domainLookupStart]() {
      return this.domainLookupStart;
    }
    get [dartx.fetchStart]() {
      return this.fetchStart;
    }
    get [dartx.initiatorType]() {
      return this.initiatorType;
    }
    get [dartx.redirectEnd]() {
      return this.redirectEnd;
    }
    get [dartx.redirectStart]() {
      return this.redirectStart;
    }
    get [dartx.requestStart]() {
      return this.requestStart;
    }
    get [dartx.responseEnd]() {
      return this.responseEnd;
    }
    get [dartx.responseStart]() {
      return this.responseStart;
    }
    get [dartx.secureConnectionStart]() {
      return this.secureConnectionStart;
    }
  }
  dart.setSignature(PerformanceResourceTiming, {
    constructors: () => ({_: [PerformanceResourceTiming, []]})
  });
  PerformanceResourceTiming[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('PerformanceResourceTiming')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("PerformanceResourceTiming"))];
  dart.registerExtension(dart.global.PerformanceResourceTiming, PerformanceResourceTiming);
  dart.defineExtensionNames([
    'connectEnd',
    'connectStart',
    'domComplete',
    'domContentLoadedEventEnd',
    'domContentLoadedEventStart',
    'domInteractive',
    'domLoading',
    'domainLookupEnd',
    'domainLookupStart',
    'fetchStart',
    'loadEventEnd',
    'loadEventStart',
    'navigationStart',
    'redirectEnd',
    'redirectStart',
    'requestStart',
    'responseEnd',
    'responseStart',
    'secureConnectionStart',
    'unloadEventEnd',
    'unloadEventStart'
  ]);
  class PerformanceTiming extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.connectEnd]() {
      return this.connectEnd;
    }
    get [dartx.connectStart]() {
      return this.connectStart;
    }
    get [dartx.domComplete]() {
      return this.domComplete;
    }
    get [dartx.domContentLoadedEventEnd]() {
      return this.domContentLoadedEventEnd;
    }
    get [dartx.domContentLoadedEventStart]() {
      return this.domContentLoadedEventStart;
    }
    get [dartx.domInteractive]() {
      return this.domInteractive;
    }
    get [dartx.domLoading]() {
      return this.domLoading;
    }
    get [dartx.domainLookupEnd]() {
      return this.domainLookupEnd;
    }
    get [dartx.domainLookupStart]() {
      return this.domainLookupStart;
    }
    get [dartx.fetchStart]() {
      return this.fetchStart;
    }
    get [dartx.loadEventEnd]() {
      return this.loadEventEnd;
    }
    get [dartx.loadEventStart]() {
      return this.loadEventStart;
    }
    get [dartx.navigationStart]() {
      return this.navigationStart;
    }
    get [dartx.redirectEnd]() {
      return this.redirectEnd;
    }
    get [dartx.redirectStart]() {
      return this.redirectStart;
    }
    get [dartx.requestStart]() {
      return this.requestStart;
    }
    get [dartx.responseEnd]() {
      return this.responseEnd;
    }
    get [dartx.responseStart]() {
      return this.responseStart;
    }
    get [dartx.secureConnectionStart]() {
      return this.secureConnectionStart;
    }
    get [dartx.unloadEventEnd]() {
      return this.unloadEventEnd;
    }
    get [dartx.unloadEventStart]() {
      return this.unloadEventStart;
    }
  }
  dart.setSignature(PerformanceTiming, {
    constructors: () => ({_: [PerformanceTiming, []]})
  });
  PerformanceTiming[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('PerformanceTiming')), dart.const(new _metadata.Unstable()), dart.const(new _js_helper.Native("PerformanceTiming"))];
  dart.registerExtension(dart.global.PerformanceTiming, PerformanceTiming);
  class PictureElement extends HtmlElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    created() {
      super.created();
    }
  }
  dart.defineNamedConstructor(PictureElement, 'created');
  dart.setSignature(PictureElement, {
    constructors: () => ({
      _: [PictureElement, []],
      created: [PictureElement, []]
    })
  });
  PictureElement[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('HTMLPictureElement')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("HTMLPictureElement"))];
  dart.registerExtension(dart.global.HTMLPictureElement, PictureElement);
  dart.defineExtensionNames([
    'item',
    'namedItem',
    'description',
    'filename',
    'length',
    'name'
  ]);
  class Plugin extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.description]() {
      return this.description;
    }
    get [dartx.filename]() {
      return this.filename;
    }
    get [dartx.length]() {
      return this.length;
    }
    get [dartx.name]() {
      return this.name;
    }
    [__getter__](name) {
      return this.__getter__(name);
    }
    [dartx.item](index) {
      return this.item(index);
    }
    [dartx.namedItem](name) {
      return this.namedItem(name);
    }
  }
  dart.setSignature(Plugin, {
    constructors: () => ({_: [Plugin, []]}),
    methods: () => ({
      [__getter__]: [MimeType, [core.String]],
      [dartx.item]: [MimeType, [core.int]],
      [dartx.namedItem]: [MimeType, [core.String]]
    })
  });
  Plugin[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('Plugin')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("Plugin"))];
  dart.registerExtension(dart.global.Plugin, Plugin);
  dart.defineExtensionNames([
    'length',
    'get',
    'set',
    'length',
    'first',
    'last',
    'single',
    'elementAt',
    'item',
    'namedItem',
    'refresh'
  ]);
  class PluginArray extends dart.mixin(_interceptors.Interceptor, collection.ListMixin$(Plugin), ImmutableListMixin$(Plugin)) {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.length]() {
      return this.length;
    }
    [dartx.get](index) {
      if (index >>> 0 !== index || index >= this[dartx.length]) dart.throw(core.RangeError.index(index, this));
      return dart.as(this[index], Plugin);
    }
    [dartx.set](index, value) {
      dart.throw(new core.UnsupportedError("Cannot assign element of immutable List."));
      return value;
    }
    set [dartx.length](value) {
      dart.throw(new core.UnsupportedError("Cannot resize immutable List."));
    }
    get [dartx.first]() {
      if (dart.notNull(this[dartx.length]) > 0) {
        return dart.as(this[0], Plugin);
      }
      dart.throw(new core.StateError("No elements"));
    }
    get [dartx.last]() {
      let len = this[dartx.length];
      if (dart.notNull(len) > 0) {
        return dart.as(this[dart.notNull(len) - 1], Plugin);
      }
      dart.throw(new core.StateError("No elements"));
    }
    get [dartx.single]() {
      let len = this[dartx.length];
      if (len == 1) {
        return dart.as(this[0], Plugin);
      }
      if (len == 0) dart.throw(new core.StateError("No elements"));
      dart.throw(new core.StateError("More than one element"));
    }
    [dartx.elementAt](index) {
      return this[dartx.get](index);
    }
    [__getter__](name) {
      return this.__getter__(name);
    }
    [dartx.item](index) {
      return this.item(index);
    }
    [dartx.namedItem](name) {
      return this.namedItem(name);
    }
    [dartx.refresh](reload) {
      return this.refresh(reload);
    }
  }
  PluginArray[dart.implements] = () => [_js_helper.JavaScriptIndexingBehavior, core.List$(Plugin)];
  dart.setSignature(PluginArray, {
    constructors: () => ({_: [PluginArray, []]}),
    methods: () => ({
      [dartx.get]: [Plugin, [core.int]],
      [dartx.set]: [dart.void, [core.int, Plugin]],
      [dartx.elementAt]: [Plugin, [core.int]],
      [__getter__]: [Plugin, [core.String]],
      [dartx.item]: [Plugin, [core.int]],
      [dartx.namedItem]: [Plugin, [core.String]],
      [dartx.refresh]: [dart.void, [core.bool]]
    })
  });
  PluginArray[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('PluginArray')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("PluginArray"))];
  dart.registerExtension(dart.global.PluginArray, PluginArray);
  dart.defineExtensionNames([
    'createdCallback',
    'message'
  ]);
  class PluginPlaceholderElement extends DivElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    created() {
      this[dartx.message] = null;
      super.created();
    }
    get [dartx.message]() {
      return this.message;
    }
    set [dartx.message](value) {
      this.message = value;
    }
    [dartx.createdCallback]() {
      return this.createdCallback();
    }
  }
  dart.defineNamedConstructor(PluginPlaceholderElement, 'created');
  dart.setSignature(PluginPlaceholderElement, {
    constructors: () => ({
      _: [PluginPlaceholderElement, []],
      created: [PluginPlaceholderElement, []]
    }),
    methods: () => ({[dartx.createdCallback]: [dart.void, []]})
  });
  PluginPlaceholderElement[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('PluginPlaceholderElement')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("PluginPlaceholderElement"))];
  dart.registerExtension(dart.global.PluginPlaceholderElement, PluginPlaceholderElement);
  dart.defineExtensionNames([
    'state'
  ]);
  class PopStateEvent extends Event {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.state]() {
      return html_common.convertNativeToDart_SerializedScriptValue(this[_get_state]);
    }
    get [_get_state]() {
      return this.state;
    }
  }
  dart.setSignature(PopStateEvent, {
    constructors: () => ({_: [PopStateEvent, []]})
  });
  PopStateEvent[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('PopStateEvent')), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.CHROME)), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.FIREFOX)), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.IE, '10')), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.SAFARI)), dart.const(new _js_helper.Native("PopStateEvent"))];
  dart.registerExtension(dart.global.PopStateEvent, PopStateEvent);
  const _PositionCallback = dart.typedef('_PositionCallback', () => dart.functionType(dart.void, [Geoposition]));
  dart.defineExtensionNames([
    'code',
    'message'
  ]);
  class PositionError extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.code]() {
      return this.code;
    }
    get [dartx.message]() {
      return this.message;
    }
  }
  dart.setSignature(PositionError, {
    constructors: () => ({_: [PositionError, []]})
  });
  PositionError[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('PositionError')), dart.const(new _metadata.Unstable()), dart.const(new _js_helper.Native("PositionError"))];
  PositionError.PERMISSION_DENIED = 1;
  PositionError.POSITION_UNAVAILABLE = 2;
  PositionError.TIMEOUT = 3;
  dart.registerExtension(dart.global.PositionError, PositionError);
  const _PositionErrorCallback = dart.typedef('_PositionErrorCallback', () => dart.functionType(dart.void, [PositionError]));
  class PreElement extends HtmlElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return dart.as(exports.document[dartx.createElement]("pre"), PreElement);
    }
    created() {
      super.created();
    }
  }
  dart.defineNamedConstructor(PreElement, 'created');
  dart.setSignature(PreElement, {
    constructors: () => ({
      _: [PreElement, []],
      new: [PreElement, []],
      created: [PreElement, []]
    })
  });
  PreElement[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('HTMLPreElement')), dart.const(new _js_helper.Native("HTMLPreElement"))];
  dart.registerExtension(dart.global.HTMLPreElement, PreElement);
  class Presentation extends EventTarget {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
  }
  dart.setSignature(Presentation, {
    constructors: () => ({_: [Presentation, []]})
  });
  Presentation[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('Presentation')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("Presentation"))];
  dart.registerExtension(dart.global.Presentation, Presentation);
  dart.defineExtensionNames([
    'sheet',
    'target'
  ]);
  class ProcessingInstruction extends CharacterData {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.sheet]() {
      return this.sheet;
    }
    get [dartx.target]() {
      return this.target;
    }
  }
  dart.setSignature(ProcessingInstruction, {
    constructors: () => ({_: [ProcessingInstruction, []]})
  });
  ProcessingInstruction[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('ProcessingInstruction')), dart.const(new _metadata.Unstable()), dart.const(new _js_helper.Native("ProcessingInstruction"))];
  dart.registerExtension(dart.global.ProcessingInstruction, ProcessingInstruction);
  dart.defineExtensionNames([
    'labels',
    'max',
    'position',
    'value'
  ]);
  class ProgressElement extends HtmlElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return dart.as(exports.document[dartx.createElement]("progress"), ProgressElement);
    }
    created() {
      this[dartx.labels] = null;
      this[dartx.max] = null;
      this[dartx.position] = null;
      this[dartx.value] = null;
      super.created();
    }
    static get supported() {
      return Element.isTagSupported('progress');
    }
    get [dartx.labels]() {
      return this.labels;
    }
    get [dartx.max]() {
      return this.max;
    }
    set [dartx.max](value) {
      this.max = value;
    }
    get [dartx.position]() {
      return this.position;
    }
    get [dartx.value]() {
      return this.value;
    }
    set [dartx.value](value) {
      this.value = value;
    }
  }
  dart.defineNamedConstructor(ProgressElement, 'created');
  dart.setSignature(ProgressElement, {
    constructors: () => ({
      _: [ProgressElement, []],
      new: [ProgressElement, []],
      created: [ProgressElement, []]
    })
  });
  ProgressElement[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('HTMLProgressElement')), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.CHROME)), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.FIREFOX)), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.IE, '10')), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.SAFARI)), dart.const(new _js_helper.Native("HTMLProgressElement"))];
  dart.registerExtension(dart.global.HTMLProgressElement, ProgressElement);
  dart.defineExtensionNames([
    'lengthComputable',
    'loaded',
    'total'
  ]);
  class ProgressEvent extends Event {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.lengthComputable]() {
      return this.lengthComputable;
    }
    get [dartx.loaded]() {
      return this.loaded;
    }
    get [dartx.total]() {
      return this.total;
    }
  }
  dart.setSignature(ProgressEvent, {
    constructors: () => ({_: [ProgressEvent, []]})
  });
  ProgressEvent[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('ProgressEvent')), dart.const(new _js_helper.Native("ProgressEvent"))];
  dart.registerExtension(dart.global.ProgressEvent, ProgressEvent);
  dart.defineExtensionNames([
    'data'
  ]);
  class PushEvent extends Event {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.data]() {
      return this.data;
    }
  }
  dart.setSignature(PushEvent, {
    constructors: () => ({_: [PushEvent, []]})
  });
  PushEvent[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('PushEvent')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("PushEvent"))];
  dart.registerExtension(dart.global.PushEvent, PushEvent);
  dart.defineExtensionNames([
    'register'
  ]);
  class PushManager extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    [dartx.register](senderId) {
      return this.register(senderId);
    }
  }
  dart.setSignature(PushManager, {
    constructors: () => ({_: [PushManager, []]}),
    methods: () => ({[dartx.register]: [async.Future, [core.String]]})
  });
  PushManager[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('PushManager')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("PushManager"))];
  dart.registerExtension(dart.global.PushManager, PushManager);
  dart.defineExtensionNames([
    'pushEndpoint',
    'pushRegistrationId'
  ]);
  class PushRegistration extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.pushEndpoint]() {
      return this.pushEndpoint;
    }
    get [dartx.pushRegistrationId]() {
      return this.pushRegistrationId;
    }
  }
  dart.setSignature(PushRegistration, {
    constructors: () => ({_: [PushRegistration, []]})
  });
  PushRegistration[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('PushRegistration')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("PushRegistration"))];
  dart.registerExtension(dart.global.PushRegistration, PushRegistration);
  dart.defineExtensionNames([
    'cite'
  ]);
  class QuoteElement extends HtmlElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return dart.as(exports.document[dartx.createElement]("q"), QuoteElement);
    }
    created() {
      this[dartx.cite] = null;
      super.created();
    }
    get [dartx.cite]() {
      return this.cite;
    }
    set [dartx.cite](value) {
      this.cite = value;
    }
  }
  dart.defineNamedConstructor(QuoteElement, 'created');
  dart.setSignature(QuoteElement, {
    constructors: () => ({
      _: [QuoteElement, []],
      new: [QuoteElement, []],
      created: [QuoteElement, []]
    })
  });
  QuoteElement[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('HTMLQuoteElement')), dart.const(new _js_helper.Native("HTMLQuoteElement"))];
  dart.registerExtension(dart.global.HTMLQuoteElement, QuoteElement);
  const _RtcErrorCallback = dart.typedef('_RtcErrorCallback', () => dart.functionType(dart.void, [core.String]));
  const _RtcSessionDescriptionCallback = dart.typedef('_RtcSessionDescriptionCallback', () => dart.functionType(dart.void, [RtcSessionDescription]));
  const RtcStatsCallback = dart.typedef('RtcStatsCallback', () => dart.functionType(dart.void, [RtcStatsResponse]));
  dart.defineExtensionNames([
    'cloneContents',
    'cloneRange',
    'collapse',
    'compareBoundaryPoints',
    'comparePoint',
    'createContextualFragment',
    'deleteContents',
    'detach',
    'expand',
    'extractContents',
    'getBoundingClientRect',
    'getClientRects',
    'insertNode',
    'isPointInRange',
    'selectNode',
    'selectNodeContents',
    'setEnd',
    'setEndAfter',
    'setEndBefore',
    'setStart',
    'setStartAfter',
    'setStartBefore',
    'surroundContents',
    'collapsed',
    'commonAncestorContainer',
    'endContainer',
    'endOffset',
    'startContainer',
    'startOffset'
  ]);
  class Range extends _interceptors.Interceptor {
    static new() {
      return exports.document[dartx.createRange]();
    }
    static fromPoint(point) {
      return exports.document[_caretRangeFromPoint](dart.as(point.x, core.int), dart.as(point.y, core.int));
    }
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.collapsed]() {
      return this.collapsed;
    }
    get [dartx.commonAncestorContainer]() {
      return this.commonAncestorContainer;
    }
    get [dartx.endContainer]() {
      return this.endContainer;
    }
    get [dartx.endOffset]() {
      return this.endOffset;
    }
    get [dartx.startContainer]() {
      return this.startContainer;
    }
    get [dartx.startOffset]() {
      return this.startOffset;
    }
    [dartx.cloneContents]() {
      return this.cloneContents();
    }
    [dartx.cloneRange]() {
      return this.cloneRange();
    }
    [dartx.collapse](toStart) {
      return this.collapse(toStart);
    }
    [dartx.compareBoundaryPoints](how, sourceRange) {
      return this.compareBoundaryPoints(how, sourceRange);
    }
    [dartx.comparePoint](refNode, offset) {
      return this.comparePoint(refNode, offset);
    }
    [dartx.createContextualFragment](html) {
      return this.createContextualFragment(html);
    }
    [dartx.deleteContents]() {
      return this.deleteContents();
    }
    [dartx.detach]() {
      return this.detach();
    }
    [dartx.expand](unit) {
      return this.expand(unit);
    }
    [dartx.extractContents]() {
      return this.extractContents();
    }
    [dartx.getBoundingClientRect]() {
      return this.getBoundingClientRect();
    }
    [dartx.getClientRects]() {
      return this.getClientRects();
    }
    [dartx.insertNode](newNode) {
      return this.insertNode(newNode);
    }
    [dartx.isPointInRange](refNode, offset) {
      return this.isPointInRange(refNode, offset);
    }
    [dartx.selectNode](refNode) {
      return this.selectNode(refNode);
    }
    [dartx.selectNodeContents](refNode) {
      return this.selectNodeContents(refNode);
    }
    [dartx.setEnd](refNode, offset) {
      return this.setEnd(refNode, offset);
    }
    [dartx.setEndAfter](refNode) {
      return this.setEndAfter(refNode);
    }
    [dartx.setEndBefore](refNode) {
      return this.setEndBefore(refNode);
    }
    [dartx.setStart](refNode, offset) {
      return this.setStart(refNode, offset);
    }
    [dartx.setStartAfter](refNode) {
      return this.setStartAfter(refNode);
    }
    [dartx.setStartBefore](refNode) {
      return this.setStartBefore(refNode);
    }
    [dartx.surroundContents](newParent) {
      return this.surroundContents(newParent);
    }
    static get supportsCreateContextualFragment() {
      return "createContextualFragment" in window.Range.prototype;
    }
  }
  dart.setSignature(Range, {
    constructors: () => ({
      new: [Range, []],
      fromPoint: [Range, [math.Point]],
      _: [Range, []]
    }),
    methods: () => ({
      [dartx.cloneContents]: [DocumentFragment, []],
      [dartx.cloneRange]: [Range, []],
      [dartx.collapse]: [dart.void, [], [core.bool]],
      [dartx.compareBoundaryPoints]: [core.int, [core.int, Range]],
      [dartx.comparePoint]: [core.int, [Node, core.int]],
      [dartx.createContextualFragment]: [DocumentFragment, [core.String]],
      [dartx.deleteContents]: [dart.void, []],
      [dartx.detach]: [dart.void, []],
      [dartx.expand]: [dart.void, [core.String]],
      [dartx.extractContents]: [DocumentFragment, []],
      [dartx.getBoundingClientRect]: [math.Rectangle, []],
      [dartx.getClientRects]: [core.List$(math.Rectangle), []],
      [dartx.insertNode]: [dart.void, [Node]],
      [dartx.isPointInRange]: [core.bool, [Node, core.int]],
      [dartx.selectNode]: [dart.void, [Node]],
      [dartx.selectNodeContents]: [dart.void, [Node]],
      [dartx.setEnd]: [dart.void, [Node, core.int]],
      [dartx.setEndAfter]: [dart.void, [Node]],
      [dartx.setEndBefore]: [dart.void, [Node]],
      [dartx.setStart]: [dart.void, [Node, core.int]],
      [dartx.setStartAfter]: [dart.void, [Node]],
      [dartx.setStartBefore]: [dart.void, [Node]],
      [dartx.surroundContents]: [dart.void, [Node]]
    })
  });
  Range[dart.metadata] = () => [dart.const(new _metadata.DomName('Range')), dart.const(new _metadata.Unstable()), dart.const(new _js_helper.Native("Range"))];
  Range.END_TO_END = 2;
  Range.END_TO_START = 3;
  Range.NODE_AFTER = 1;
  Range.NODE_BEFORE = 0;
  Range.NODE_BEFORE_AND_AFTER = 2;
  Range.NODE_INSIDE = 3;
  Range.START_TO_END = 1;
  Range.START_TO_START = 0;
  dart.registerExtension(dart.global.Range, Range);
  dart.defineExtensionNames([
    'cancel',
    'read',
    'wait',
    'closed',
    'state'
  ]);
  class ReadableStream extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.closed]() {
      return this.closed;
    }
    get [dartx.state]() {
      return this.state;
    }
    [dartx.cancel](reason) {
      return this.cancel(reason);
    }
    [dartx.read]() {
      return this.read();
    }
    [dartx.wait]() {
      return this.wait();
    }
  }
  dart.setSignature(ReadableStream, {
    constructors: () => ({_: [ReadableStream, []]}),
    methods: () => ({
      [dartx.cancel]: [async.Future, [core.Object]],
      [dartx.read]: [core.Object, []],
      [dartx.wait]: [async.Future, []]
    })
  });
  ReadableStream[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('ReadableStream')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("ReadableStream"))];
  dart.registerExtension(dart.global.ReadableStream, ReadableStream);
  dart.defineExtensionNames([
    'relatedTarget'
  ]);
  class RelatedEvent extends Event {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.relatedTarget]() {
      return _convertNativeToDart_EventTarget(this[_get_relatedTarget]);
    }
    get [_get_relatedTarget]() {
      return this.relatedTarget;
    }
  }
  dart.setSignature(RelatedEvent, {
    constructors: () => ({_: [RelatedEvent, []]})
  });
  RelatedEvent[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('RelatedEvent')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("RelatedEvent"))];
  dart.registerExtension(dart.global.RelatedEvent, RelatedEvent);
  const RequestAnimationFrameCallback = dart.typedef('RequestAnimationFrameCallback', () => dart.functionType(dart.void, [core.num]));
  dart.defineExtensionNames([
    'url'
  ]);
  class ResourceProgressEvent extends ProgressEvent {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.url]() {
      return this.url;
    }
  }
  dart.setSignature(ResourceProgressEvent, {
    constructors: () => ({_: [ResourceProgressEvent, []]})
  });
  ResourceProgressEvent[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('ResourceProgressEvent')), core.deprecated, dart.const(new _js_helper.Native("ResourceProgressEvent"))];
  dart.registerExtension(dart.global.ResourceProgressEvent, ResourceProgressEvent);
  dart.defineExtensionNames([
    'close',
    'send',
    'sendBlob',
    'sendByteBuffer',
    'sendString',
    'sendTypedData',
    'onClose',
    'onError',
    'onMessage',
    'onOpen',
    'binaryType',
    'bufferedAmount',
    'id',
    'label',
    'maxRetransmitTime',
    'maxRetransmits',
    'negotiated',
    'ordered',
    'protocol',
    'readyState',
    'reliable'
  ]);
  class RtcDataChannel extends EventTarget {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.binaryType]() {
      return this.binaryType;
    }
    set [dartx.binaryType](value) {
      this.binaryType = value;
    }
    get [dartx.bufferedAmount]() {
      return this.bufferedAmount;
    }
    get [dartx.id]() {
      return this.id;
    }
    get [dartx.label]() {
      return this.label;
    }
    get [dartx.maxRetransmitTime]() {
      return this.maxRetransmitTime;
    }
    get [dartx.maxRetransmits]() {
      return this.maxRetransmits;
    }
    get [dartx.negotiated]() {
      return this.negotiated;
    }
    get [dartx.ordered]() {
      return this.ordered;
    }
    get [dartx.protocol]() {
      return this.protocol;
    }
    get [dartx.readyState]() {
      return this.readyState;
    }
    get [dartx.reliable]() {
      return this.reliable;
    }
    [dartx.close]() {
      return this.close();
    }
    [dartx.send](data) {
      return this.send(data);
    }
    [dartx.sendBlob](data) {
      return this.send(data);
    }
    [dartx.sendByteBuffer](data) {
      return this.send(data);
    }
    [dartx.sendString](data) {
      return this.send(data);
    }
    [dartx.sendTypedData](data) {
      return this.send(data);
    }
    get [dartx.onClose]() {
      return RtcDataChannel.closeEvent.forTarget(this);
    }
    get [dartx.onError]() {
      return RtcDataChannel.errorEvent.forTarget(this);
    }
    get [dartx.onMessage]() {
      return RtcDataChannel.messageEvent.forTarget(this);
    }
    get [dartx.onOpen]() {
      return RtcDataChannel.openEvent.forTarget(this);
    }
  }
  dart.setSignature(RtcDataChannel, {
    constructors: () => ({_: [RtcDataChannel, []]}),
    methods: () => ({
      [dartx.close]: [dart.void, []],
      [dartx.send]: [dart.void, [dart.dynamic]],
      [dartx.sendBlob]: [dart.void, [Blob]],
      [dartx.sendByteBuffer]: [dart.void, [typed_data.ByteBuffer]],
      [dartx.sendString]: [dart.void, [core.String]],
      [dartx.sendTypedData]: [dart.void, [typed_data.TypedData]]
    })
  });
  RtcDataChannel[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('RTCDataChannel')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("RTCDataChannel,DataChannel"))];
  dart.defineLazyProperties(RtcDataChannel, {
    get closeEvent() {
      return dart.const(new (EventStreamProvider$(Event))('close'));
    },
    get errorEvent() {
      return dart.const(new (EventStreamProvider$(Event))('error'));
    },
    get messageEvent() {
      return dart.const(new (EventStreamProvider$(MessageEvent))('message'));
    },
    get openEvent() {
      return dart.const(new (EventStreamProvider$(Event))('open'));
    }
  });
  dart.registerExtension(dart.global.RTCDataChannel, RtcDataChannel);
  dart.defineExtensionNames([
    'channel'
  ]);
  class RtcDataChannelEvent extends Event {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.channel]() {
      return this.channel;
    }
  }
  dart.setSignature(RtcDataChannelEvent, {
    constructors: () => ({_: [RtcDataChannelEvent, []]})
  });
  RtcDataChannelEvent[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('RTCDataChannelEvent')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("RTCDataChannelEvent"))];
  dart.registerExtension(dart.global.RTCDataChannelEvent, RtcDataChannelEvent);
  dart.defineExtensionNames([
    'insertDtmf',
    'onToneChange',
    'canInsertDtmf',
    'duration',
    'interToneGap',
    'toneBuffer',
    'track'
  ]);
  class RtcDtmfSender extends EventTarget {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.canInsertDtmf]() {
      return this.canInsertDTMF;
    }
    get [dartx.duration]() {
      return this.duration;
    }
    get [dartx.interToneGap]() {
      return this.interToneGap;
    }
    get [dartx.toneBuffer]() {
      return this.toneBuffer;
    }
    get [dartx.track]() {
      return this.track;
    }
    [dartx.insertDtmf](tones, duration, interToneGap) {
      return this.insertDTMF(tones, duration, interToneGap);
    }
    get [dartx.onToneChange]() {
      return RtcDtmfSender.toneChangeEvent.forTarget(this);
    }
  }
  dart.setSignature(RtcDtmfSender, {
    constructors: () => ({_: [RtcDtmfSender, []]}),
    methods: () => ({[dartx.insertDtmf]: [dart.void, [core.String], [core.int, core.int]]})
  });
  RtcDtmfSender[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('RTCDTMFSender')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("RTCDTMFSender"))];
  dart.defineLazyProperties(RtcDtmfSender, {
    get toneChangeEvent() {
      return dart.const(new (EventStreamProvider$(RtcDtmfToneChangeEvent))('tonechange'));
    }
  });
  dart.registerExtension(dart.global.RTCDTMFSender, RtcDtmfSender);
  dart.defineExtensionNames([
    'tone'
  ]);
  class RtcDtmfToneChangeEvent extends Event {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.tone]() {
      return this.tone;
    }
  }
  dart.setSignature(RtcDtmfToneChangeEvent, {
    constructors: () => ({_: [RtcDtmfToneChangeEvent, []]})
  });
  RtcDtmfToneChangeEvent[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('RTCDTMFToneChangeEvent')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("RTCDTMFToneChangeEvent"))];
  dart.registerExtension(dart.global.RTCDTMFToneChangeEvent, RtcDtmfToneChangeEvent);
  dart.defineExtensionNames([
    'candidate',
    'sdpMLineIndex',
    'sdpMid'
  ]);
  class RtcIceCandidate extends _interceptors.Interceptor {
    static new(dictionary) {
      let constructorName = window[dart.notNull(html_common.Device.isFirefox) ? `${html_common.Device.propertyPrefix}RTCIceCandidate` : 'RTCIceCandidate'];
      return dart.as(new constructorName(html_common.convertDartToNative_SerializedScriptValue(dictionary)), RtcIceCandidate);
    }
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.candidate]() {
      return this.candidate;
    }
    set [dartx.candidate](value) {
      this.candidate = value;
    }
    get [dartx.sdpMLineIndex]() {
      return this.sdpMLineIndex;
    }
    set [dartx.sdpMLineIndex](value) {
      this.sdpMLineIndex = value;
    }
    get [dartx.sdpMid]() {
      return this.sdpMid;
    }
    set [dartx.sdpMid](value) {
      this.sdpMid = value;
    }
  }
  dart.setSignature(RtcIceCandidate, {
    constructors: () => ({
      new: [RtcIceCandidate, [core.Map]],
      _: [RtcIceCandidate, []]
    })
  });
  RtcIceCandidate[dart.metadata] = () => [dart.const(new _metadata.DomName('RTCIceCandidate')), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.CHROME)), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("RTCIceCandidate,mozRTCIceCandidate"))];
  dart.registerExtension(dart.global.RTCIceCandidate, RtcIceCandidate);
  dart.defineExtensionNames([
    'candidate'
  ]);
  class RtcIceCandidateEvent extends Event {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.candidate]() {
      return this.candidate;
    }
  }
  dart.setSignature(RtcIceCandidateEvent, {
    constructors: () => ({_: [RtcIceCandidateEvent, []]})
  });
  RtcIceCandidateEvent[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('RTCIceCandidateEvent')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("RTCIceCandidateEvent,RTCPeerConnectionIceEvent"))];
  dart.registerExtension(dart.global.RTCIceCandidateEvent, RtcIceCandidateEvent);
  const _createOffer = Symbol('_createOffer');
  const _createAnswer = Symbol('_createAnswer');
  const _getStats = Symbol('_getStats');
  const _addStream_1 = Symbol('_addStream_1');
  const _addStream_2 = Symbol('_addStream_2');
  const _createAnswer_1 = Symbol('_createAnswer_1');
  const _createAnswer_2 = Symbol('_createAnswer_2');
  const _createDataChannel_1 = Symbol('_createDataChannel_1');
  const _createDataChannel_2 = Symbol('_createDataChannel_2');
  const _createOffer_1 = Symbol('_createOffer_1');
  const _createOffer_2 = Symbol('_createOffer_2');
  const _setLocalDescription = Symbol('_setLocalDescription');
  const _setRemoteDescription = Symbol('_setRemoteDescription');
  const _updateIce_1 = Symbol('_updateIce_1');
  const _updateIce_2 = Symbol('_updateIce_2');
  const _updateIce_3 = Symbol('_updateIce_3');
  dart.defineExtensionNames([
    'createOffer',
    'createAnswer',
    'getStats',
    'addIceCandidate',
    'addStream',
    'close',
    'createDtmfSender',
    'createDataChannel',
    'getLocalStreams',
    'getRemoteStreams',
    'getStreamById',
    'removeStream',
    'setLocalDescription',
    'setRemoteDescription',
    'updateIce',
    'onAddStream',
    'onDataChannel',
    'onIceCandidate',
    'onIceConnectionStateChange',
    'onNegotiationNeeded',
    'onRemoveStream',
    'onSignalingStateChange',
    'iceConnectionState',
    'iceGatheringState',
    'localDescription',
    'remoteDescription',
    'signalingState'
  ]);
  class RtcPeerConnection extends EventTarget {
    static new(rtcIceServers, mediaConstraints) {
      if (mediaConstraints === void 0) mediaConstraints = null;
      let constructorName = window[`${html_common.Device.propertyPrefix}RTCPeerConnection`];
      if (mediaConstraints != null) {
        return dart.as(new constructorName(html_common.convertDartToNative_SerializedScriptValue(rtcIceServers), html_common.convertDartToNative_SerializedScriptValue(mediaConstraints)), RtcPeerConnection);
      } else {
        return dart.as(new constructorName(html_common.convertDartToNative_SerializedScriptValue(rtcIceServers)), RtcPeerConnection);
      }
    }
    static get supported() {
      try {
        RtcPeerConnection.new(dart.map({iceServers: dart.list([dart.map({url: "stun:localhost"})], core.Map$(core.String, core.String))}));
        return true;
      } catch (_) {
        return false;
      }

      return false;
    }
    [dartx.createOffer](mediaConstraints) {
      if (mediaConstraints === void 0) mediaConstraints = null;
      let completer = async.Completer$(RtcSessionDescription).new();
      this[_createOffer](dart.fn(value => {
        completer.complete(value);
      }, dart.void, [RtcSessionDescription]), dart.fn(error => {
        completer.completeError(error);
      }, dart.void, [core.String]), mediaConstraints);
      return completer.future;
    }
    [dartx.createAnswer](mediaConstraints) {
      if (mediaConstraints === void 0) mediaConstraints = null;
      let completer = async.Completer$(RtcSessionDescription).new();
      this[_createAnswer](dart.fn(value => {
        completer.complete(value);
      }, dart.void, [RtcSessionDescription]), dart.fn(error => {
        completer.completeError(error);
      }, dart.void, [core.String]), mediaConstraints);
      return completer.future;
    }
    [dartx.getStats](selector) {
      let completer = async.Completer$(RtcStatsResponse).new();
      this[_getStats](dart.fn(value => {
        completer.complete(value);
      }, dart.void, [RtcStatsResponse]), selector);
      return completer.future;
    }
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.iceConnectionState]() {
      return this.iceConnectionState;
    }
    get [dartx.iceGatheringState]() {
      return this.iceGatheringState;
    }
    get [dartx.localDescription]() {
      return this.localDescription;
    }
    get [dartx.remoteDescription]() {
      return this.remoteDescription;
    }
    get [dartx.signalingState]() {
      return this.signalingState;
    }
    [dartx.addIceCandidate](candidate, successCallback, failureCallback) {
      return this.addIceCandidate(candidate, successCallback, failureCallback);
    }
    [dartx.addStream](stream, mediaConstraints) {
      if (mediaConstraints === void 0) mediaConstraints = null;
      if (mediaConstraints != null) {
        let mediaConstraints_1 = html_common.convertDartToNative_Dictionary(mediaConstraints);
        this[_addStream_1](stream, mediaConstraints_1);
        return;
      }
      this[_addStream_2](stream);
      return;
    }
    [_addStream_1](stream, mediaConstraints) {
      return this.addStream(stream, mediaConstraints);
    }
    [_addStream_2](stream) {
      return this.addStream(stream);
    }
    [dartx.close]() {
      return this.close();
    }
    [_createAnswer](successCallback, failureCallback, mediaConstraints) {
      if (failureCallback === void 0) failureCallback = null;
      if (mediaConstraints === void 0) mediaConstraints = null;
      if (mediaConstraints != null) {
        let mediaConstraints_1 = html_common.convertDartToNative_Dictionary(mediaConstraints);
        this[_createAnswer_1](successCallback, failureCallback, mediaConstraints_1);
        return;
      }
      this[_createAnswer_2](successCallback, failureCallback);
      return;
    }
    [_createAnswer_1](successCallback, failureCallback, mediaConstraints) {
      return this.createAnswer(successCallback, failureCallback, mediaConstraints);
    }
    [_createAnswer_2](successCallback, failureCallback) {
      return this.createAnswer(successCallback, failureCallback);
    }
    [dartx.createDtmfSender](track) {
      return this.createDTMFSender(track);
    }
    [dartx.createDataChannel](label, options) {
      if (options === void 0) options = null;
      if (options != null) {
        let options_1 = html_common.convertDartToNative_Dictionary(options);
        return this[_createDataChannel_1](label, options_1);
      }
      return this[_createDataChannel_2](label);
    }
    [_createDataChannel_1](label, options) {
      return this.createDataChannel(label, options);
    }
    [_createDataChannel_2](label) {
      return this.createDataChannel(label);
    }
    [_createOffer](successCallback, failureCallback, rtcOfferOptions) {
      if (failureCallback === void 0) failureCallback = null;
      if (rtcOfferOptions === void 0) rtcOfferOptions = null;
      if (rtcOfferOptions != null) {
        let rtcOfferOptions_1 = html_common.convertDartToNative_Dictionary(rtcOfferOptions);
        this[_createOffer_1](successCallback, failureCallback, rtcOfferOptions_1);
        return;
      }
      this[_createOffer_2](successCallback, failureCallback);
      return;
    }
    [_createOffer_1](successCallback, failureCallback, rtcOfferOptions) {
      return this.createOffer(successCallback, failureCallback, rtcOfferOptions);
    }
    [_createOffer_2](successCallback, failureCallback) {
      return this.createOffer(successCallback, failureCallback);
    }
    [dartx.getLocalStreams]() {
      return this.getLocalStreams();
    }
    [dartx.getRemoteStreams]() {
      return this.getRemoteStreams();
    }
    [_getStats](successCallback, selector) {
      return this.getStats(successCallback, selector);
    }
    [dartx.getStreamById](streamId) {
      return this.getStreamById(streamId);
    }
    [dartx.removeStream](stream) {
      return this.removeStream(stream);
    }
    [_setLocalDescription](description, successCallback, failureCallback) {
      return this.setLocalDescription(description, successCallback, failureCallback);
    }
    [dartx.setLocalDescription](description) {
      let completer = async.Completer.new();
      this[_setLocalDescription](description, dart.fn(() => {
        completer.complete();
      }, dart.void, []), dart.fn(error => {
        completer.completeError(error);
      }, dart.void, [core.String]));
      return completer.future;
    }
    [_setRemoteDescription](description, successCallback, failureCallback) {
      return this.setRemoteDescription(description, successCallback, failureCallback);
    }
    [dartx.setRemoteDescription](description) {
      let completer = async.Completer.new();
      this[_setRemoteDescription](description, dart.fn(() => {
        completer.complete();
      }, dart.void, []), dart.fn(error => {
        completer.completeError(error);
      }, dart.void, [core.String]));
      return completer.future;
    }
    [dartx.updateIce](configuration, mediaConstraints) {
      if (configuration === void 0) configuration = null;
      if (mediaConstraints === void 0) mediaConstraints = null;
      if (mediaConstraints != null) {
        let configuration_1 = html_common.convertDartToNative_Dictionary(configuration);
        let mediaConstraints_2 = html_common.convertDartToNative_Dictionary(mediaConstraints);
        this[_updateIce_1](configuration_1, mediaConstraints_2);
        return;
      }
      if (configuration != null) {
        let configuration_1 = html_common.convertDartToNative_Dictionary(configuration);
        this[_updateIce_2](configuration_1);
        return;
      }
      this[_updateIce_3]();
      return;
    }
    [_updateIce_1](configuration, mediaConstraints) {
      return this.updateIce(configuration, mediaConstraints);
    }
    [_updateIce_2](configuration) {
      return this.updateIce(configuration);
    }
    [_updateIce_3]() {
      return this.updateIce();
    }
    get [dartx.onAddStream]() {
      return RtcPeerConnection.addStreamEvent.forTarget(this);
    }
    get [dartx.onDataChannel]() {
      return RtcPeerConnection.dataChannelEvent.forTarget(this);
    }
    get [dartx.onIceCandidate]() {
      return RtcPeerConnection.iceCandidateEvent.forTarget(this);
    }
    get [dartx.onIceConnectionStateChange]() {
      return RtcPeerConnection.iceConnectionStateChangeEvent.forTarget(this);
    }
    get [dartx.onNegotiationNeeded]() {
      return RtcPeerConnection.negotiationNeededEvent.forTarget(this);
    }
    get [dartx.onRemoveStream]() {
      return RtcPeerConnection.removeStreamEvent.forTarget(this);
    }
    get [dartx.onSignalingStateChange]() {
      return RtcPeerConnection.signalingStateChangeEvent.forTarget(this);
    }
  }
  dart.setSignature(RtcPeerConnection, {
    constructors: () => ({
      new: [RtcPeerConnection, [core.Map], [core.Map]],
      _: [RtcPeerConnection, []]
    }),
    methods: () => ({
      [dartx.createOffer]: [async.Future$(RtcSessionDescription), [], [core.Map]],
      [dartx.createAnswer]: [async.Future$(RtcSessionDescription), [], [core.Map]],
      [dartx.getStats]: [async.Future$(RtcStatsResponse), [MediaStreamTrack]],
      [dartx.addIceCandidate]: [dart.void, [RtcIceCandidate, VoidCallback, _RtcErrorCallback]],
      [dartx.addStream]: [dart.void, [MediaStream], [core.Map]],
      [_addStream_1]: [dart.void, [MediaStream, dart.dynamic]],
      [_addStream_2]: [dart.void, [MediaStream]],
      [dartx.close]: [dart.void, []],
      [_createAnswer]: [dart.void, [_RtcSessionDescriptionCallback], [_RtcErrorCallback, core.Map]],
      [_createAnswer_1]: [dart.void, [_RtcSessionDescriptionCallback, _RtcErrorCallback, dart.dynamic]],
      [_createAnswer_2]: [dart.void, [_RtcSessionDescriptionCallback, _RtcErrorCallback]],
      [dartx.createDtmfSender]: [RtcDtmfSender, [MediaStreamTrack]],
      [dartx.createDataChannel]: [RtcDataChannel, [core.String], [core.Map]],
      [_createDataChannel_1]: [RtcDataChannel, [dart.dynamic, dart.dynamic]],
      [_createDataChannel_2]: [RtcDataChannel, [dart.dynamic]],
      [_createOffer]: [dart.void, [_RtcSessionDescriptionCallback], [_RtcErrorCallback, core.Map]],
      [_createOffer_1]: [dart.void, [_RtcSessionDescriptionCallback, _RtcErrorCallback, dart.dynamic]],
      [_createOffer_2]: [dart.void, [_RtcSessionDescriptionCallback, _RtcErrorCallback]],
      [dartx.getLocalStreams]: [core.List$(MediaStream), []],
      [dartx.getRemoteStreams]: [core.List$(MediaStream), []],
      [_getStats]: [dart.void, [RtcStatsCallback, MediaStreamTrack]],
      [dartx.getStreamById]: [MediaStream, [core.String]],
      [dartx.removeStream]: [dart.void, [MediaStream]],
      [_setLocalDescription]: [dart.void, [RtcSessionDescription], [VoidCallback, _RtcErrorCallback]],
      [dartx.setLocalDescription]: [async.Future, [RtcSessionDescription]],
      [_setRemoteDescription]: [dart.void, [RtcSessionDescription], [VoidCallback, _RtcErrorCallback]],
      [dartx.setRemoteDescription]: [async.Future, [RtcSessionDescription]],
      [dartx.updateIce]: [dart.void, [], [core.Map, core.Map]],
      [_updateIce_1]: [dart.void, [dart.dynamic, dart.dynamic]],
      [_updateIce_2]: [dart.void, [dart.dynamic]],
      [_updateIce_3]: [dart.void, []]
    })
  });
  RtcPeerConnection[dart.metadata] = () => [dart.const(new _metadata.DomName('RTCPeerConnection')), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.CHROME)), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("RTCPeerConnection,mozRTCPeerConnection"))];
  dart.defineLazyProperties(RtcPeerConnection, {
    get addStreamEvent() {
      return dart.const(new (EventStreamProvider$(MediaStreamEvent))('addstream'));
    },
    get dataChannelEvent() {
      return dart.const(new (EventStreamProvider$(RtcDataChannelEvent))('datachannel'));
    },
    get iceCandidateEvent() {
      return dart.const(new (EventStreamProvider$(RtcIceCandidateEvent))('icecandidate'));
    },
    get iceConnectionStateChangeEvent() {
      return dart.const(new (EventStreamProvider$(Event))('iceconnectionstatechange'));
    },
    get negotiationNeededEvent() {
      return dart.const(new (EventStreamProvider$(Event))('negotiationneeded'));
    },
    get removeStreamEvent() {
      return dart.const(new (EventStreamProvider$(MediaStreamEvent))('removestream'));
    },
    get signalingStateChangeEvent() {
      return dart.const(new (EventStreamProvider$(Event))('signalingstatechange'));
    }
  });
  dart.registerExtension(dart.global.RTCPeerConnection, RtcPeerConnection);
  dart.defineExtensionNames([
    'sdp',
    'type'
  ]);
  class RtcSessionDescription extends _interceptors.Interceptor {
    static new(dictionary) {
      let constructorName = window[dart.notNull(html_common.Device.isFirefox) ? `${html_common.Device.propertyPrefix}RTCSessionDescription` : 'RTCSessionDescription'];
      return dart.as(new constructorName(html_common.convertDartToNative_SerializedScriptValue(dictionary)), RtcSessionDescription);
    }
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.sdp]() {
      return this.sdp;
    }
    set [dartx.sdp](value) {
      this.sdp = value;
    }
    get [dartx.type]() {
      return this.type;
    }
    set [dartx.type](value) {
      this.type = value;
    }
  }
  dart.setSignature(RtcSessionDescription, {
    constructors: () => ({
      new: [RtcSessionDescription, [core.Map]],
      _: [RtcSessionDescription, []]
    })
  });
  RtcSessionDescription[dart.metadata] = () => [dart.const(new _metadata.DomName('RTCSessionDescription')), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.CHROME)), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("RTCSessionDescription,mozRTCSessionDescription"))];
  dart.registerExtension(dart.global.RTCSessionDescription, RtcSessionDescription);
  const _get_timestamp = Symbol('_get_timestamp');
  dart.defineExtensionNames([
    'timestamp',
    'names',
    'stat',
    'id',
    'local',
    'remote',
    'type'
  ]);
  class RtcStatsReport extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.id]() {
      return this.id;
    }
    get [dartx.local]() {
      return this.local;
    }
    get [dartx.remote]() {
      return this.remote;
    }
    get [dartx.timestamp]() {
      return html_common.convertNativeToDart_DateTime(this[_get_timestamp]);
    }
    get [_get_timestamp]() {
      return this.timestamp;
    }
    get [dartx.type]() {
      return this.type;
    }
    [dartx.names]() {
      return this.names();
    }
    [dartx.stat](name) {
      return this.stat(name);
    }
  }
  dart.setSignature(RtcStatsReport, {
    constructors: () => ({_: [RtcStatsReport, []]}),
    methods: () => ({
      [dartx.names]: [core.List$(core.String), []],
      [dartx.stat]: [core.String, [core.String]]
    })
  });
  RtcStatsReport[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('RTCStatsReport')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("RTCStatsReport"))];
  dart.registerExtension(dart.global.RTCStatsReport, RtcStatsReport);
  dart.defineExtensionNames([
    'namedItem',
    'result'
  ]);
  class RtcStatsResponse extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    [__getter__](name) {
      return this.__getter__(name);
    }
    [dartx.namedItem](name) {
      return this.namedItem(name);
    }
    [dartx.result]() {
      return this.result();
    }
  }
  dart.setSignature(RtcStatsResponse, {
    constructors: () => ({_: [RtcStatsResponse, []]}),
    methods: () => ({
      [__getter__]: [RtcStatsReport, [core.String]],
      [dartx.namedItem]: [RtcStatsReport, [core.String]],
      [dartx.result]: [core.List$(RtcStatsReport), []]
    })
  });
  RtcStatsResponse[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('RTCStatsResponse')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("RTCStatsResponse"))];
  dart.registerExtension(dart.global.RTCStatsResponse, RtcStatsResponse);
  const _availLeft = Symbol('_availLeft');
  const _availTop = Symbol('_availTop');
  const _availWidth = Symbol('_availWidth');
  const _availHeight = Symbol('_availHeight');
  dart.defineExtensionNames([
    'available',
    'colorDepth',
    'height',
    'orientation',
    'pixelDepth',
    'width'
  ]);
  class Screen extends _interceptors.Interceptor {
    get [dartx.available]() {
      return new math.Rectangle(this[_availLeft], this[_availTop], this[_availWidth], this[_availHeight]);
    }
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [_availHeight]() {
      return this.availHeight;
    }
    get [_availLeft]() {
      return this.availLeft;
    }
    get [_availTop]() {
      return this.availTop;
    }
    get [_availWidth]() {
      return this.availWidth;
    }
    get [dartx.colorDepth]() {
      return this.colorDepth;
    }
    get [dartx.height]() {
      return this.height;
    }
    get [dartx.orientation]() {
      return this.orientation;
    }
    get [dartx.pixelDepth]() {
      return this.pixelDepth;
    }
    get [dartx.width]() {
      return this.width;
    }
  }
  dart.setSignature(Screen, {
    constructors: () => ({_: [Screen, []]})
  });
  Screen[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('Screen')), dart.const(new _js_helper.Native("Screen"))];
  dart.registerExtension(dart.global.Screen, Screen);
  dart.defineExtensionNames([
    'lock',
    'unlock',
    'onChange',
    'angle',
    'type'
  ]);
  class ScreenOrientation extends EventTarget {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.angle]() {
      return this.angle;
    }
    get [dartx.type]() {
      return this.type;
    }
    [dartx.lock](orientation) {
      return this.lock(orientation);
    }
    [dartx.unlock]() {
      return this.unlock();
    }
    get [dartx.onChange]() {
      return ScreenOrientation.changeEvent.forTarget(this);
    }
  }
  dart.setSignature(ScreenOrientation, {
    constructors: () => ({_: [ScreenOrientation, []]}),
    methods: () => ({
      [dartx.lock]: [async.Future, [core.String]],
      [dartx.unlock]: [dart.void, []]
    })
  });
  ScreenOrientation[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('ScreenOrientation')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("ScreenOrientation"))];
  dart.defineLazyProperties(ScreenOrientation, {
    get changeEvent() {
      return dart.const(new (EventStreamProvider$(Event))('change'));
    }
  });
  dart.registerExtension(dart.global.ScreenOrientation, ScreenOrientation);
  dart.defineExtensionNames([
    'async',
    'charset',
    'crossOrigin',
    'defer',
    'integrity',
    'nonce',
    'src',
    'type'
  ]);
  class ScriptElement extends HtmlElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return dart.as(exports.document[dartx.createElement]("script"), ScriptElement);
    }
    created() {
      this[dartx.async] = null;
      this[dartx.charset] = null;
      this[dartx.crossOrigin] = null;
      this[dartx.defer] = null;
      this[dartx.integrity] = null;
      this[dartx.nonce] = null;
      this[dartx.src] = null;
      this[dartx.type] = null;
      super.created();
    }
    get [dartx.async]() {
      return this.async;
    }
    set [dartx.async](value) {
      this.async = value;
    }
    get [dartx.charset]() {
      return this.charset;
    }
    set [dartx.charset](value) {
      this.charset = value;
    }
    get [dartx.crossOrigin]() {
      return this.crossOrigin;
    }
    set [dartx.crossOrigin](value) {
      this.crossOrigin = value;
    }
    get [dartx.defer]() {
      return this.defer;
    }
    set [dartx.defer](value) {
      this.defer = value;
    }
    get [dartx.integrity]() {
      return this.integrity;
    }
    set [dartx.integrity](value) {
      this.integrity = value;
    }
    get [dartx.nonce]() {
      return this.nonce;
    }
    set [dartx.nonce](value) {
      this.nonce = value;
    }
    get [dartx.src]() {
      return this.src;
    }
    set [dartx.src](value) {
      this.src = value;
    }
    get [dartx.type]() {
      return this.type;
    }
    set [dartx.type](value) {
      this.type = value;
    }
  }
  dart.defineNamedConstructor(ScriptElement, 'created');
  dart.setSignature(ScriptElement, {
    constructors: () => ({
      _: [ScriptElement, []],
      new: [ScriptElement, []],
      created: [ScriptElement, []]
    })
  });
  ScriptElement[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('HTMLScriptElement')), dart.const(new _js_helper.Native("HTMLScriptElement"))];
  dart.registerExtension(dart.global.HTMLScriptElement, ScriptElement);
  dart.defineExtensionNames([
    'blockedUri',
    'columnNumber',
    'documentUri',
    'effectiveDirective',
    'lineNumber',
    'originalPolicy',
    'referrer',
    'sourceFile',
    'statusCode',
    'violatedDirective'
  ]);
  class SecurityPolicyViolationEvent extends Event {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.blockedUri]() {
      return this.blockedURI;
    }
    get [dartx.columnNumber]() {
      return this.columnNumber;
    }
    get [dartx.documentUri]() {
      return this.documentURI;
    }
    get [dartx.effectiveDirective]() {
      return this.effectiveDirective;
    }
    get [dartx.lineNumber]() {
      return this.lineNumber;
    }
    get [dartx.originalPolicy]() {
      return this.originalPolicy;
    }
    get [dartx.referrer]() {
      return this.referrer;
    }
    get [dartx.sourceFile]() {
      return this.sourceFile;
    }
    get [dartx.statusCode]() {
      return this.statusCode;
    }
    get [dartx.violatedDirective]() {
      return this.violatedDirective;
    }
  }
  dart.setSignature(SecurityPolicyViolationEvent, {
    constructors: () => ({_: [SecurityPolicyViolationEvent, []]})
  });
  SecurityPolicyViolationEvent[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('SecurityPolicyViolationEvent')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("SecurityPolicyViolationEvent"))];
  dart.registerExtension(dart.global.SecurityPolicyViolationEvent, SecurityPolicyViolationEvent);
  dart.defineExtensionNames([
    'add',
    'checkValidity',
    'item',
    'namedItem',
    'setCustomValidity',
    'options',
    'selectedOptions',
    'autofocus',
    'disabled',
    'form',
    'labels',
    'length',
    'multiple',
    'name',
    'required',
    'selectedIndex',
    'size',
    'type',
    'validationMessage',
    'validity',
    'value',
    'willValidate'
  ]);
  class SelectElement extends HtmlElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return dart.as(exports.document[dartx.createElement]("select"), SelectElement);
    }
    created() {
      this[dartx.autofocus] = null;
      this[dartx.disabled] = null;
      this[dartx.form] = null;
      this[dartx.labels] = null;
      this[dartx.length] = null;
      this[dartx.multiple] = null;
      this[dartx.name] = null;
      this[dartx.required] = null;
      this[dartx.selectedIndex] = null;
      this[dartx.size] = null;
      this[dartx.type] = null;
      this[dartx.validationMessage] = null;
      this[dartx.validity] = null;
      this[dartx.value] = null;
      this[dartx.willValidate] = null;
      super.created();
    }
    get [dartx.autofocus]() {
      return this.autofocus;
    }
    set [dartx.autofocus](value) {
      this.autofocus = value;
    }
    get [dartx.disabled]() {
      return this.disabled;
    }
    set [dartx.disabled](value) {
      this.disabled = value;
    }
    get [dartx.form]() {
      return this.form;
    }
    get [dartx.labels]() {
      return this.labels;
    }
    get [dartx.length]() {
      return this.length;
    }
    set [dartx.length](value) {
      this.length = value;
    }
    get [dartx.multiple]() {
      return this.multiple;
    }
    set [dartx.multiple](value) {
      this.multiple = value;
    }
    get [dartx.name]() {
      return this.name;
    }
    set [dartx.name](value) {
      this.name = value;
    }
    get [dartx.required]() {
      return this.required;
    }
    set [dartx.required](value) {
      this.required = value;
    }
    get [dartx.selectedIndex]() {
      return this.selectedIndex;
    }
    set [dartx.selectedIndex](value) {
      this.selectedIndex = value;
    }
    get [dartx.size]() {
      return this.size;
    }
    set [dartx.size](value) {
      this.size = value;
    }
    get [dartx.type]() {
      return this.type;
    }
    get [dartx.validationMessage]() {
      return this.validationMessage;
    }
    get [dartx.validity]() {
      return this.validity;
    }
    get [dartx.value]() {
      return this.value;
    }
    set [dartx.value](value) {
      this.value = value;
    }
    get [dartx.willValidate]() {
      return this.willValidate;
    }
    [__setter__](index, value) {
      return this.__setter__(index, value);
    }
    [dartx.add](element, before) {
      return this.add(element, before);
    }
    [dartx.checkValidity]() {
      return this.checkValidity();
    }
    [dartx.item](index) {
      return this.item(index);
    }
    [dartx.namedItem](name) {
      return this.namedItem(name);
    }
    [dartx.setCustomValidity](error) {
      return this.setCustomValidity(error);
    }
    get [dartx.options]() {
      let options = this[dartx.querySelectorAll]('option').where(dart.fn(e => dart.is(e, OptionElement), core.bool, [Element]))[dartx.toList]();
      return new (collection.UnmodifiableListView$(OptionElement))(options);
    }
    get [dartx.selectedOptions]() {
      if (dart.notNull(this[dartx.multiple])) {
        let options = this[dartx.options][dartx.where](dart.fn(o => o[dartx.selected], core.bool, [OptionElement]))[dartx.toList]();
        return new (collection.UnmodifiableListView$(OptionElement))(options);
      } else {
        return dart.list([this[dartx.options][dartx.get](this[dartx.selectedIndex])], OptionElement);
      }
    }
  }
  dart.defineNamedConstructor(SelectElement, 'created');
  dart.setSignature(SelectElement, {
    constructors: () => ({
      _: [SelectElement, []],
      new: [SelectElement, []],
      created: [SelectElement, []]
    }),
    methods: () => ({
      [__setter__]: [dart.void, [core.int, OptionElement]],
      [dartx.add]: [dart.void, [HtmlElement, core.int]],
      [dartx.checkValidity]: [core.bool, []],
      [dartx.item]: [Element, [core.int]],
      [dartx.namedItem]: [Element, [core.String]],
      [dartx.setCustomValidity]: [dart.void, [core.String]]
    })
  });
  SelectElement[dart.metadata] = () => [dart.const(new _metadata.DomName('HTMLSelectElement')), dart.const(new _js_helper.Native("HTMLSelectElement"))];
  dart.registerExtension(dart.global.HTMLSelectElement, SelectElement);
  dart.defineExtensionNames([
    'addRange',
    'collapse',
    'collapseToEnd',
    'collapseToStart',
    'containsNode',
    'deleteFromDocument',
    'empty',
    'extend',
    'getRangeAt',
    'modify',
    'removeAllRanges',
    'selectAllChildren',
    'setBaseAndExtent',
    'setPosition',
    'anchorNode',
    'anchorOffset',
    'baseNode',
    'baseOffset',
    'extentNode',
    'extentOffset',
    'focusNode',
    'focusOffset',
    'isCollapsed',
    'rangeCount',
    'type'
  ]);
  class Selection extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.anchorNode]() {
      return this.anchorNode;
    }
    get [dartx.anchorOffset]() {
      return this.anchorOffset;
    }
    get [dartx.baseNode]() {
      return this.baseNode;
    }
    get [dartx.baseOffset]() {
      return this.baseOffset;
    }
    get [dartx.extentNode]() {
      return this.extentNode;
    }
    get [dartx.extentOffset]() {
      return this.extentOffset;
    }
    get [dartx.focusNode]() {
      return this.focusNode;
    }
    get [dartx.focusOffset]() {
      return this.focusOffset;
    }
    get [dartx.isCollapsed]() {
      return this.isCollapsed;
    }
    get [dartx.rangeCount]() {
      return this.rangeCount;
    }
    get [dartx.type]() {
      return this.type;
    }
    [dartx.addRange](range) {
      return this.addRange(range);
    }
    [dartx.collapse](node, offset) {
      return this.collapse(node, offset);
    }
    [dartx.collapseToEnd]() {
      return this.collapseToEnd();
    }
    [dartx.collapseToStart]() {
      return this.collapseToStart();
    }
    [dartx.containsNode](node, allowPartial) {
      return this.containsNode(node, allowPartial);
    }
    [dartx.deleteFromDocument]() {
      return this.deleteFromDocument();
    }
    [dartx.empty]() {
      return this.empty();
    }
    [dartx.extend](node, offset) {
      return this.extend(node, offset);
    }
    [dartx.getRangeAt](index) {
      return this.getRangeAt(index);
    }
    [dartx.modify](alter, direction, granularity) {
      return this.modify(alter, direction, granularity);
    }
    [dartx.removeAllRanges]() {
      return this.removeAllRanges();
    }
    [dartx.selectAllChildren](node) {
      return this.selectAllChildren(node);
    }
    [dartx.setBaseAndExtent](baseNode, baseOffset, extentNode, extentOffset) {
      return this.setBaseAndExtent(baseNode, baseOffset, extentNode, extentOffset);
    }
    [dartx.setPosition](node, offset) {
      return this.setPosition(node, offset);
    }
  }
  dart.setSignature(Selection, {
    constructors: () => ({_: [Selection, []]}),
    methods: () => ({
      [dartx.addRange]: [dart.void, [Range]],
      [dartx.collapse]: [dart.void, [Node], [core.int]],
      [dartx.collapseToEnd]: [dart.void, []],
      [dartx.collapseToStart]: [dart.void, []],
      [dartx.containsNode]: [core.bool, [Node, core.bool]],
      [dartx.deleteFromDocument]: [dart.void, []],
      [dartx.empty]: [dart.void, []],
      [dartx.extend]: [dart.void, [Node], [core.int]],
      [dartx.getRangeAt]: [Range, [core.int]],
      [dartx.modify]: [dart.void, [core.String, core.String, core.String]],
      [dartx.removeAllRanges]: [dart.void, []],
      [dartx.selectAllChildren]: [dart.void, [Node]],
      [dartx.setBaseAndExtent]: [dart.void, [Node, core.int, Node, core.int]],
      [dartx.setPosition]: [dart.void, [Node], [core.int]]
    })
  });
  Selection[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('Selection')), dart.const(new _js_helper.Native("Selection"))];
  dart.registerExtension(dart.global.Selection, Selection);
  dart.defineExtensionNames([
    'postMessage',
    'id'
  ]);
  class ServiceWorkerClient extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.id]() {
      return this.id;
    }
    [dartx.postMessage](message, transfer) {
      if (transfer === void 0) transfer = null;
      if (transfer != null) {
        let message_1 = html_common.convertDartToNative_SerializedScriptValue(message);
        this[_postMessage_1](message_1, transfer);
        return;
      }
      let message_1 = html_common.convertDartToNative_SerializedScriptValue(message);
      this[_postMessage_2](message_1);
      return;
    }
    [_postMessage_1](message, transfer) {
      return this.postMessage(message, transfer);
    }
    [_postMessage_2](message) {
      return this.postMessage(message);
    }
  }
  dart.setSignature(ServiceWorkerClient, {
    constructors: () => ({_: [ServiceWorkerClient, []]}),
    methods: () => ({
      [dartx.postMessage]: [dart.void, [dart.dynamic], [core.List$(MessagePort)]],
      [_postMessage_1]: [dart.void, [dart.dynamic, core.List$(MessagePort)]],
      [_postMessage_2]: [dart.void, [dart.dynamic]]
    })
  });
  ServiceWorkerClient[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('ServiceWorkerClient')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("ServiceWorkerClient"))];
  dart.registerExtension(dart.global.ServiceWorkerClient, ServiceWorkerClient);
  const _getAll_1 = Symbol('_getAll_1');
  const _getAll_2 = Symbol('_getAll_2');
  dart.defineExtensionNames([
    'getAll'
  ]);
  class ServiceWorkerClients extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    [dartx.getAll](options) {
      if (options === void 0) options = null;
      if (options != null) {
        let options_1 = html_common.convertDartToNative_Dictionary(options);
        return this[_getAll_1](options_1);
      }
      return this[_getAll_2]();
    }
    [_getAll_1](options) {
      return this.getAll(options);
    }
    [_getAll_2]() {
      return this.getAll();
    }
  }
  dart.setSignature(ServiceWorkerClients, {
    constructors: () => ({_: [ServiceWorkerClients, []]}),
    methods: () => ({
      [dartx.getAll]: [async.Future, [], [core.Map]],
      [_getAll_1]: [async.Future, [dart.dynamic]],
      [_getAll_2]: [async.Future, []]
    })
  });
  ServiceWorkerClients[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('ServiceWorkerClients')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("ServiceWorkerClients"))];
  dart.registerExtension(dart.global.ServiceWorkerClients, ServiceWorkerClients);
  const _register_1 = Symbol('_register_1');
  const _register_2 = Symbol('_register_2');
  dart.defineExtensionNames([
    'getRegistration',
    'register',
    'controller',
    'ready'
  ]);
  class ServiceWorkerContainer extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.controller]() {
      return this.controller;
    }
    get [dartx.ready]() {
      return this.ready;
    }
    [dartx.getRegistration](documentURL) {
      return this.getRegistration(documentURL);
    }
    [dartx.register](url, options) {
      if (options === void 0) options = null;
      if (options != null) {
        let options_1 = html_common.convertDartToNative_Dictionary(options);
        return this[_register_1](url, options_1);
      }
      return this[_register_2](url);
    }
    [_register_1](url, options) {
      return this.register(url, options);
    }
    [_register_2](url) {
      return this.register(url);
    }
  }
  dart.setSignature(ServiceWorkerContainer, {
    constructors: () => ({_: [ServiceWorkerContainer, []]}),
    methods: () => ({
      [dartx.getRegistration]: [async.Future, [], [core.String]],
      [dartx.register]: [async.Future, [core.String], [core.Map]],
      [_register_1]: [async.Future, [dart.dynamic, dart.dynamic]],
      [_register_2]: [async.Future, [dart.dynamic]]
    })
  });
  ServiceWorkerContainer[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('ServiceWorkerContainer')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("ServiceWorkerContainer"))];
  dart.registerExtension(dart.global.ServiceWorkerContainer, ServiceWorkerContainer);
  const _fetch_1 = Symbol('_fetch_1');
  const _fetch_2 = Symbol('_fetch_2');
  const _fetch_3 = Symbol('_fetch_3');
  const _fetch_4 = Symbol('_fetch_4');
  const _fetch = Symbol('_fetch');
  dart.defineExtensionNames([
    'onMessage',
    'caches',
    'clients',
    'scope'
  ]);
  class ServiceWorkerGlobalScope extends WorkerGlobalScope {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.caches]() {
      return this.caches;
    }
    get [dartx.clients]() {
      return this.clients;
    }
    get [dartx.scope]() {
      return this.scope;
    }
    [_fetch](request, requestInitDict) {
      if (requestInitDict === void 0) requestInitDict = null;
      if ((typeof request == 'string' || request == null) && requestInitDict == null) {
        return this[_fetch_1](dart.as(request, core.String));
      }
      if (requestInitDict != null && (typeof request == 'string' || request == null)) {
        let requestInitDict_1 = html_common.convertDartToNative_Dictionary(requestInitDict);
        return this[_fetch_2](dart.as(request, core.String), requestInitDict_1);
      }
      if ((dart.is(request, _Request) || request == null) && requestInitDict == null) {
        return this[_fetch_3](dart.as(request, _Request));
      }
      if (requestInitDict != null && (dart.is(request, _Request) || request == null)) {
        let requestInitDict_1 = html_common.convertDartToNative_Dictionary(requestInitDict);
        return this[_fetch_4](dart.as(request, _Request), requestInitDict_1);
      }
      dart.throw(new core.ArgumentError("Incorrect number or type of arguments"));
    }
    [_fetch_1](request) {
      return this.fetch(request);
    }
    [_fetch_2](request, requestInitDict) {
      return this.fetch(request, requestInitDict);
    }
    [_fetch_3](request) {
      return this.fetch(request);
    }
    [_fetch_4](request, requestInitDict) {
      return this.fetch(request, requestInitDict);
    }
    get [dartx.onMessage]() {
      return ServiceWorkerGlobalScope.messageEvent.forTarget(this);
    }
  }
  dart.setSignature(ServiceWorkerGlobalScope, {
    constructors: () => ({_: [ServiceWorkerGlobalScope, []]}),
    methods: () => ({
      [_fetch]: [async.Future, [dart.dynamic], [core.Map]],
      [_fetch_1]: [async.Future, [core.String]],
      [_fetch_2]: [async.Future, [core.String, dart.dynamic]],
      [_fetch_3]: [async.Future, [_Request]],
      [_fetch_4]: [async.Future, [_Request, dart.dynamic]]
    })
  });
  ServiceWorkerGlobalScope[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('ServiceWorkerGlobalScope')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("ServiceWorkerGlobalScope"))];
  dart.defineLazyProperties(ServiceWorkerGlobalScope, {
    get messageEvent() {
      return dart.const(new (EventStreamProvider$(MessageEvent))('message'));
    }
  });
  dart.registerExtension(dart.global.ServiceWorkerGlobalScope, ServiceWorkerGlobalScope);
  dart.defineExtensionNames([
    'unregister',
    'active',
    'installing',
    'scope',
    'waiting'
  ]);
  class ServiceWorkerRegistration extends EventTarget {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.active]() {
      return this.active;
    }
    get [dartx.installing]() {
      return this.installing;
    }
    get [dartx.scope]() {
      return this.scope;
    }
    get [dartx.waiting]() {
      return this.waiting;
    }
    [dartx.unregister]() {
      return this.unregister();
    }
  }
  dart.setSignature(ServiceWorkerRegistration, {
    constructors: () => ({_: [ServiceWorkerRegistration, []]}),
    methods: () => ({[dartx.unregister]: [async.Future, []]})
  });
  ServiceWorkerRegistration[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('ServiceWorkerRegistration')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("ServiceWorkerRegistration"))];
  dart.registerExtension(dart.global.ServiceWorkerRegistration, ServiceWorkerRegistration);
  dart.defineExtensionNames([
    'getDistributedNodes'
  ]);
  class ShadowElement extends HtmlElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return dart.as(exports.document[dartx.createElement]("shadow"), ShadowElement);
    }
    created() {
      super.created();
    }
    static get supported() {
      return Element.isTagSupported('shadow');
    }
    [dartx.getDistributedNodes]() {
      return this.getDistributedNodes();
    }
  }
  dart.defineNamedConstructor(ShadowElement, 'created');
  dart.setSignature(ShadowElement, {
    constructors: () => ({
      _: [ShadowElement, []],
      new: [ShadowElement, []],
      created: [ShadowElement, []]
    }),
    methods: () => ({[dartx.getDistributedNodes]: [core.List$(Node), []]})
  });
  ShadowElement[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('HTMLShadowElement')), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.CHROME, '26')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("HTMLShadowElement"))];
  dart.registerExtension(dart.global.HTMLShadowElement, ShadowElement);
  dart.defineExtensionNames([
    'clone',
    'elementFromPoint',
    'getElementsByClassName',
    'getElementsByTagName',
    'getSelection',
    'resetStyleInheritance',
    'resetStyleInheritance',
    'applyAuthorStyles',
    'applyAuthorStyles',
    'activeElement',
    'host',
    'innerHtml',
    'olderShadowRoot',
    'styleSheets'
  ]);
  class ShadowRoot extends DocumentFragment {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.activeElement]() {
      return this.activeElement;
    }
    get [dartx.host]() {
      return this.host;
    }
    get [dartx.innerHtml]() {
      return this.innerHTML;
    }
    set [dartx.innerHtml](value) {
      this.innerHTML = value;
    }
    get [dartx.olderShadowRoot]() {
      return this.olderShadowRoot;
    }
    get [dartx.styleSheets]() {
      return this.styleSheets;
    }
    [dartx.clone](deep) {
      return this.cloneNode(deep);
    }
    [dartx.elementFromPoint](x, y) {
      return this.elementFromPoint(x, y);
    }
    [dartx.getElementsByClassName](className) {
      return this.getElementsByClassName(className);
    }
    [dartx.getElementsByTagName](tagName) {
      return this.getElementsByTagName(tagName);
    }
    [dartx.getSelection]() {
      return this.getSelection();
    }
    static get supported() {
      return !!(Element.prototype.createShadowRoot || Element.prototype.webkitCreateShadowRoot);
    }
    static _shadowRootDeprecationReport() {
      if (!dart.notNull(ShadowRoot._shadowRootDeprecationReported)) {
        exports.window[dartx.console].warn('ShadowRoot.resetStyleInheritance and ShadowRoot.applyAuthorStyles now deprecated in dart:html.\nPlease remove them from your code.\n');
        ShadowRoot._shadowRootDeprecationReported = true;
      }
    }
    get [dartx.resetStyleInheritance]() {
      ShadowRoot._shadowRootDeprecationReport();
      return false;
    }
    set [dartx.resetStyleInheritance](value) {
      ShadowRoot._shadowRootDeprecationReport();
    }
    get [dartx.applyAuthorStyles]() {
      ShadowRoot._shadowRootDeprecationReport();
      return false;
    }
    set [dartx.applyAuthorStyles](value) {
      ShadowRoot._shadowRootDeprecationReport();
    }
  }
  dart.virtualField(ShadowRoot, dartx.innerHtml);
  dart.setSignature(ShadowRoot, {
    constructors: () => ({_: [ShadowRoot, []]}),
    methods: () => ({
      [dartx.elementFromPoint]: [Element, [core.int, core.int]],
      [dartx.getElementsByClassName]: [core.List$(Node), [core.String]],
      [dartx.getElementsByTagName]: [core.List$(Node), [core.String]],
      [dartx.getSelection]: [Selection, []]
    }),
    statics: () => ({_shadowRootDeprecationReport: [dart.void, []]}),
    names: ['_shadowRootDeprecationReport']
  });
  ShadowRoot[dart.metadata] = () => [dart.const(new _metadata.DomName('ShadowRoot')), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.CHROME, '26')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("ShadowRoot"))];
  ShadowRoot._shadowRootDeprecationReported = false;
  dart.registerExtension(dart.global.ShadowRoot, ShadowRoot);
  dart.defineExtensionNames([
    'onError',
    'port',
    'workerStart'
  ]);
  class SharedWorker extends EventTarget {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new(scriptURL, name) {
      if (name === void 0) name = null;
      if (name != null) {
        return SharedWorker._create_1(scriptURL, name);
      }
      return SharedWorker._create_2(scriptURL);
    }
    static _create_1(scriptURL, name) {
      return dart.as(new SharedWorker(scriptURL, name), SharedWorker);
    }
    static _create_2(scriptURL) {
      return dart.as(new SharedWorker(scriptURL), SharedWorker);
    }
    get [dartx.port]() {
      return this.port;
    }
    get [dartx.workerStart]() {
      return this.workerStart;
    }
    get [dartx.onError]() {
      return SharedWorker.errorEvent.forTarget(this);
    }
  }
  SharedWorker[dart.implements] = () => [AbstractWorker];
  dart.setSignature(SharedWorker, {
    constructors: () => ({
      _: [SharedWorker, []],
      new: [SharedWorker, [core.String], [core.String]]
    }),
    statics: () => ({
      _create_1: [SharedWorker, [dart.dynamic, dart.dynamic]],
      _create_2: [SharedWorker, [dart.dynamic]]
    }),
    names: ['_create_1', '_create_2']
  });
  SharedWorker[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('SharedWorker')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("SharedWorker"))];
  dart.defineLazyProperties(SharedWorker, {
    get errorEvent() {
      return dart.const(new (EventStreamProvider$(Event))('error'));
    }
  });
  dart.registerExtension(dart.global.SharedWorker, SharedWorker);
  dart.defineExtensionNames([
    'onConnect',
    'name'
  ]);
  class SharedWorkerGlobalScope extends WorkerGlobalScope {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.name]() {
      return this.name;
    }
    get [dartx.onConnect]() {
      return SharedWorkerGlobalScope.connectEvent.forTarget(this);
    }
  }
  dart.setSignature(SharedWorkerGlobalScope, {
    constructors: () => ({_: [SharedWorkerGlobalScope, []]})
  });
  SharedWorkerGlobalScope[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('SharedWorkerGlobalScope')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("SharedWorkerGlobalScope"))];
  dart.defineLazyProperties(SharedWorkerGlobalScope, {
    get connectEvent() {
      return dart.const(new (EventStreamProvider$(Event))('connect'));
    }
  });
  dart.registerExtension(dart.global.SharedWorkerGlobalScope, SharedWorkerGlobalScope);
  dart.defineExtensionNames([
    'abort',
    'appendBuffer',
    'appendStream',
    'appendTypedData',
    'remove',
    'appendWindowEnd',
    'appendWindowStart',
    'buffered',
    'mode',
    'timestampOffset',
    'updating'
  ]);
  class SourceBuffer extends EventTarget {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.appendWindowEnd]() {
      return this.appendWindowEnd;
    }
    set [dartx.appendWindowEnd](value) {
      this.appendWindowEnd = value;
    }
    get [dartx.appendWindowStart]() {
      return this.appendWindowStart;
    }
    set [dartx.appendWindowStart](value) {
      this.appendWindowStart = value;
    }
    get [dartx.buffered]() {
      return this.buffered;
    }
    get [dartx.mode]() {
      return this.mode;
    }
    set [dartx.mode](value) {
      this.mode = value;
    }
    get [dartx.timestampOffset]() {
      return this.timestampOffset;
    }
    set [dartx.timestampOffset](value) {
      this.timestampOffset = value;
    }
    get [dartx.updating]() {
      return this.updating;
    }
    [dartx.abort]() {
      return this.abort();
    }
    [dartx.appendBuffer](data) {
      return this.appendBuffer(data);
    }
    [dartx.appendStream](stream, maxSize) {
      return this.appendStream(stream, maxSize);
    }
    [dartx.appendTypedData](data) {
      return this.appendBuffer(data);
    }
    [dartx.remove](start, end) {
      return this.remove(start, end);
    }
  }
  dart.setSignature(SourceBuffer, {
    constructors: () => ({_: [SourceBuffer, []]}),
    methods: () => ({
      [dartx.abort]: [dart.void, []],
      [dartx.appendBuffer]: [dart.void, [typed_data.ByteBuffer]],
      [dartx.appendStream]: [dart.void, [FileStream], [core.int]],
      [dartx.appendTypedData]: [dart.void, [typed_data.TypedData]],
      [dartx.remove]: [dart.void, [core.num, core.num]]
    })
  });
  SourceBuffer[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('SourceBuffer')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("SourceBuffer"))];
  dart.registerExtension(dart.global.SourceBuffer, SourceBuffer);
  dart.defineExtensionNames([
    'length',
    'get',
    'set',
    'length',
    'first',
    'last',
    'single',
    'elementAt',
    'item'
  ]);
  class SourceBufferList extends dart.mixin(EventTarget, collection.ListMixin$(SourceBuffer), ImmutableListMixin$(SourceBuffer)) {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.length]() {
      return this.length;
    }
    [dartx.get](index) {
      if (index >>> 0 !== index || index >= this[dartx.length]) dart.throw(core.RangeError.index(index, this));
      return dart.as(this[index], SourceBuffer);
    }
    [dartx.set](index, value) {
      dart.throw(new core.UnsupportedError("Cannot assign element of immutable List."));
      return value;
    }
    set [dartx.length](value) {
      dart.throw(new core.UnsupportedError("Cannot resize immutable List."));
    }
    get [dartx.first]() {
      if (dart.notNull(this[dartx.length]) > 0) {
        return dart.as(this[0], SourceBuffer);
      }
      dart.throw(new core.StateError("No elements"));
    }
    get [dartx.last]() {
      let len = this[dartx.length];
      if (dart.notNull(len) > 0) {
        return dart.as(this[dart.notNull(len) - 1], SourceBuffer);
      }
      dart.throw(new core.StateError("No elements"));
    }
    get [dartx.single]() {
      let len = this[dartx.length];
      if (len == 1) {
        return dart.as(this[0], SourceBuffer);
      }
      if (len == 0) dart.throw(new core.StateError("No elements"));
      dart.throw(new core.StateError("More than one element"));
    }
    [dartx.elementAt](index) {
      return this[dartx.get](index);
    }
    [dartx.item](index) {
      return this.item(index);
    }
  }
  SourceBufferList[dart.implements] = () => [_js_helper.JavaScriptIndexingBehavior, core.List$(SourceBuffer)];
  dart.setSignature(SourceBufferList, {
    constructors: () => ({_: [SourceBufferList, []]}),
    methods: () => ({
      [dartx.get]: [SourceBuffer, [core.int]],
      [dartx.set]: [dart.void, [core.int, SourceBuffer]],
      [dartx.elementAt]: [SourceBuffer, [core.int]],
      [dartx.item]: [SourceBuffer, [core.int]]
    })
  });
  SourceBufferList[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('SourceBufferList')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("SourceBufferList"))];
  dart.registerExtension(dart.global.SourceBufferList, SourceBufferList);
  dart.defineExtensionNames([
    'integrity',
    'media',
    'sizes',
    'src',
    'srcset',
    'type'
  ]);
  class SourceElement extends HtmlElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return dart.as(exports.document[dartx.createElement]("source"), SourceElement);
    }
    created() {
      this[dartx.integrity] = null;
      this[dartx.media] = null;
      this[dartx.sizes] = null;
      this[dartx.src] = null;
      this[dartx.srcset] = null;
      this[dartx.type] = null;
      super.created();
    }
    get [dartx.integrity]() {
      return this.integrity;
    }
    set [dartx.integrity](value) {
      this.integrity = value;
    }
    get [dartx.media]() {
      return this.media;
    }
    set [dartx.media](value) {
      this.media = value;
    }
    get [dartx.sizes]() {
      return this.sizes;
    }
    set [dartx.sizes](value) {
      this.sizes = value;
    }
    get [dartx.src]() {
      return this.src;
    }
    set [dartx.src](value) {
      this.src = value;
    }
    get [dartx.srcset]() {
      return this.srcset;
    }
    set [dartx.srcset](value) {
      this.srcset = value;
    }
    get [dartx.type]() {
      return this.type;
    }
    set [dartx.type](value) {
      this.type = value;
    }
  }
  dart.defineNamedConstructor(SourceElement, 'created');
  dart.setSignature(SourceElement, {
    constructors: () => ({
      _: [SourceElement, []],
      new: [SourceElement, []],
      created: [SourceElement, []]
    })
  });
  SourceElement[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('HTMLSourceElement')), dart.const(new _js_helper.Native("HTMLSourceElement"))];
  dart.registerExtension(dart.global.HTMLSourceElement, SourceElement);
  dart.defineExtensionNames([
    'facing',
    'id',
    'kind',
    'label'
  ]);
  class SourceInfo extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.facing]() {
      return this.facing;
    }
    get [dartx.id]() {
      return this.id;
    }
    get [dartx.kind]() {
      return this.kind;
    }
    get [dartx.label]() {
      return this.label;
    }
  }
  dart.setSignature(SourceInfo, {
    constructors: () => ({_: [SourceInfo, []]})
  });
  SourceInfo[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('SourceInfo')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("SourceInfo"))];
  dart.registerExtension(dart.global.SourceInfo, SourceInfo);
  class SpanElement extends HtmlElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return dart.as(exports.document[dartx.createElement]("span"), SpanElement);
    }
    created() {
      super.created();
    }
  }
  dart.defineNamedConstructor(SpanElement, 'created');
  dart.setSignature(SpanElement, {
    constructors: () => ({
      _: [SpanElement, []],
      new: [SpanElement, []],
      created: [SpanElement, []]
    })
  });
  SpanElement[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('HTMLSpanElement')), dart.const(new _js_helper.Native("HTMLSpanElement"))];
  dart.registerExtension(dart.global.HTMLSpanElement, SpanElement);
  dart.defineExtensionNames([
    'src',
    'weight'
  ]);
  class SpeechGrammar extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return SpeechGrammar._create_1();
    }
    static _create_1() {
      return dart.as(new SpeechGrammar(), SpeechGrammar);
    }
    get [dartx.src]() {
      return this.src;
    }
    set [dartx.src](value) {
      this.src = value;
    }
    get [dartx.weight]() {
      return this.weight;
    }
    set [dartx.weight](value) {
      this.weight = value;
    }
  }
  dart.setSignature(SpeechGrammar, {
    constructors: () => ({
      _: [SpeechGrammar, []],
      new: [SpeechGrammar, []]
    }),
    statics: () => ({_create_1: [SpeechGrammar, []]}),
    names: ['_create_1']
  });
  SpeechGrammar[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('SpeechGrammar')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("SpeechGrammar"))];
  dart.registerExtension(dart.global.SpeechGrammar, SpeechGrammar);
  dart.defineExtensionNames([
    'length',
    'get',
    'set',
    'length',
    'first',
    'last',
    'single',
    'elementAt',
    'addFromString',
    'addFromUri',
    'item'
  ]);
  class SpeechGrammarList extends dart.mixin(_interceptors.Interceptor, collection.ListMixin$(SpeechGrammar), ImmutableListMixin$(SpeechGrammar)) {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return SpeechGrammarList._create_1();
    }
    static _create_1() {
      return dart.as(new SpeechGrammarList(), SpeechGrammarList);
    }
    get [dartx.length]() {
      return this.length;
    }
    [dartx.get](index) {
      if (index >>> 0 !== index || index >= this[dartx.length]) dart.throw(core.RangeError.index(index, this));
      return dart.as(this[index], SpeechGrammar);
    }
    [dartx.set](index, value) {
      dart.throw(new core.UnsupportedError("Cannot assign element of immutable List."));
      return value;
    }
    set [dartx.length](value) {
      dart.throw(new core.UnsupportedError("Cannot resize immutable List."));
    }
    get [dartx.first]() {
      if (dart.notNull(this[dartx.length]) > 0) {
        return dart.as(this[0], SpeechGrammar);
      }
      dart.throw(new core.StateError("No elements"));
    }
    get [dartx.last]() {
      let len = this[dartx.length];
      if (dart.notNull(len) > 0) {
        return dart.as(this[dart.notNull(len) - 1], SpeechGrammar);
      }
      dart.throw(new core.StateError("No elements"));
    }
    get [dartx.single]() {
      let len = this[dartx.length];
      if (len == 1) {
        return dart.as(this[0], SpeechGrammar);
      }
      if (len == 0) dart.throw(new core.StateError("No elements"));
      dart.throw(new core.StateError("More than one element"));
    }
    [dartx.elementAt](index) {
      return this[dartx.get](index);
    }
    [dartx.addFromString](string, weight) {
      return this.addFromString(string, weight);
    }
    [dartx.addFromUri](src, weight) {
      return this.addFromUri(src, weight);
    }
    [dartx.item](index) {
      return this.item(index);
    }
  }
  SpeechGrammarList[dart.implements] = () => [_js_helper.JavaScriptIndexingBehavior, core.List$(SpeechGrammar)];
  dart.setSignature(SpeechGrammarList, {
    constructors: () => ({
      _: [SpeechGrammarList, []],
      new: [SpeechGrammarList, []]
    }),
    methods: () => ({
      [dartx.get]: [SpeechGrammar, [core.int]],
      [dartx.set]: [dart.void, [core.int, SpeechGrammar]],
      [dartx.elementAt]: [SpeechGrammar, [core.int]],
      [dartx.addFromString]: [dart.void, [core.String], [core.num]],
      [dartx.addFromUri]: [dart.void, [core.String], [core.num]],
      [dartx.item]: [SpeechGrammar, [core.int]]
    }),
    statics: () => ({_create_1: [SpeechGrammarList, []]}),
    names: ['_create_1']
  });
  SpeechGrammarList[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('SpeechGrammarList')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("SpeechGrammarList"))];
  dart.registerExtension(dart.global.SpeechGrammarList, SpeechGrammarList);
  dart.defineExtensionNames([
    'abort',
    'start',
    'stop',
    'onAudioEnd',
    'onAudioStart',
    'onEnd',
    'onError',
    'onNoMatch',
    'onResult',
    'onSoundEnd',
    'onSoundStart',
    'onSpeechEnd',
    'onSpeechStart',
    'onStart',
    'continuous',
    'grammars',
    'interimResults',
    'lang',
    'maxAlternatives'
  ]);
  class SpeechRecognition extends EventTarget {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static get supported() {
      return !!(window.SpeechRecognition || window.webkitSpeechRecognition);
    }
    get [dartx.continuous]() {
      return this.continuous;
    }
    set [dartx.continuous](value) {
      this.continuous = value;
    }
    get [dartx.grammars]() {
      return this.grammars;
    }
    set [dartx.grammars](value) {
      this.grammars = value;
    }
    get [dartx.interimResults]() {
      return this.interimResults;
    }
    set [dartx.interimResults](value) {
      this.interimResults = value;
    }
    get [dartx.lang]() {
      return this.lang;
    }
    set [dartx.lang](value) {
      this.lang = value;
    }
    get [dartx.maxAlternatives]() {
      return this.maxAlternatives;
    }
    set [dartx.maxAlternatives](value) {
      this.maxAlternatives = value;
    }
    [dartx.abort]() {
      return this.abort();
    }
    [dartx.start]() {
      return this.start();
    }
    [dartx.stop]() {
      return this.stop();
    }
    get [dartx.onAudioEnd]() {
      return SpeechRecognition.audioEndEvent.forTarget(this);
    }
    get [dartx.onAudioStart]() {
      return SpeechRecognition.audioStartEvent.forTarget(this);
    }
    get [dartx.onEnd]() {
      return SpeechRecognition.endEvent.forTarget(this);
    }
    get [dartx.onError]() {
      return SpeechRecognition.errorEvent.forTarget(this);
    }
    get [dartx.onNoMatch]() {
      return SpeechRecognition.noMatchEvent.forTarget(this);
    }
    get [dartx.onResult]() {
      return SpeechRecognition.resultEvent.forTarget(this);
    }
    get [dartx.onSoundEnd]() {
      return SpeechRecognition.soundEndEvent.forTarget(this);
    }
    get [dartx.onSoundStart]() {
      return SpeechRecognition.soundStartEvent.forTarget(this);
    }
    get [dartx.onSpeechEnd]() {
      return SpeechRecognition.speechEndEvent.forTarget(this);
    }
    get [dartx.onSpeechStart]() {
      return SpeechRecognition.speechStartEvent.forTarget(this);
    }
    get [dartx.onStart]() {
      return SpeechRecognition.startEvent.forTarget(this);
    }
    static new() {
      return dart.as(new (window.SpeechRecognition || window.webkitSpeechRecognition)(), SpeechRecognition);
    }
  }
  dart.setSignature(SpeechRecognition, {
    constructors: () => ({
      _: [SpeechRecognition, []],
      new: [SpeechRecognition, []]
    }),
    methods: () => ({
      [dartx.abort]: [dart.void, []],
      [dartx.start]: [dart.void, []],
      [dartx.stop]: [dart.void, []]
    })
  });
  SpeechRecognition[dart.metadata] = () => [dart.const(new _metadata.DomName('SpeechRecognition')), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.CHROME, '25')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("SpeechRecognition"))];
  dart.defineLazyProperties(SpeechRecognition, {
    get audioEndEvent() {
      return dart.const(new (EventStreamProvider$(Event))('audioend'));
    },
    get audioStartEvent() {
      return dart.const(new (EventStreamProvider$(Event))('audiostart'));
    },
    get endEvent() {
      return dart.const(new (EventStreamProvider$(Event))('end'));
    },
    get errorEvent() {
      return dart.const(new (EventStreamProvider$(SpeechRecognitionError))('error'));
    },
    get noMatchEvent() {
      return dart.const(new (EventStreamProvider$(SpeechRecognitionEvent))('nomatch'));
    },
    get resultEvent() {
      return dart.const(new (EventStreamProvider$(SpeechRecognitionEvent))('result'));
    },
    get soundEndEvent() {
      return dart.const(new (EventStreamProvider$(Event))('soundend'));
    },
    get soundStartEvent() {
      return dart.const(new (EventStreamProvider$(Event))('soundstart'));
    },
    get speechEndEvent() {
      return dart.const(new (EventStreamProvider$(Event))('speechend'));
    },
    get speechStartEvent() {
      return dart.const(new (EventStreamProvider$(Event))('speechstart'));
    },
    get startEvent() {
      return dart.const(new (EventStreamProvider$(Event))('start'));
    }
  });
  dart.registerExtension(dart.global.SpeechRecognition, SpeechRecognition);
  dart.defineExtensionNames([
    'confidence',
    'transcript'
  ]);
  class SpeechRecognitionAlternative extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.confidence]() {
      return this.confidence;
    }
    get [dartx.transcript]() {
      return this.transcript;
    }
  }
  dart.setSignature(SpeechRecognitionAlternative, {
    constructors: () => ({_: [SpeechRecognitionAlternative, []]})
  });
  SpeechRecognitionAlternative[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('SpeechRecognitionAlternative')), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.CHROME, '25')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("SpeechRecognitionAlternative"))];
  dart.registerExtension(dart.global.SpeechRecognitionAlternative, SpeechRecognitionAlternative);
  dart.defineExtensionNames([
    'error',
    'message'
  ]);
  class SpeechRecognitionError extends Event {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.error]() {
      return this.error;
    }
    get [dartx.message]() {
      return this.message;
    }
  }
  dart.setSignature(SpeechRecognitionError, {
    constructors: () => ({_: [SpeechRecognitionError, []]})
  });
  SpeechRecognitionError[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('SpeechRecognitionError')), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.CHROME, '25')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("SpeechRecognitionError"))];
  dart.registerExtension(dart.global.SpeechRecognitionError, SpeechRecognitionError);
  dart.defineExtensionNames([
    'emma',
    'interpretation',
    'resultIndex',
    'results'
  ]);
  class SpeechRecognitionEvent extends Event {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.emma]() {
      return this.emma;
    }
    get [dartx.interpretation]() {
      return this.interpretation;
    }
    get [dartx.resultIndex]() {
      return this.resultIndex;
    }
    get [dartx.results]() {
      return this.results;
    }
  }
  dart.setSignature(SpeechRecognitionEvent, {
    constructors: () => ({_: [SpeechRecognitionEvent, []]})
  });
  SpeechRecognitionEvent[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('SpeechRecognitionEvent')), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.CHROME, '25')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("SpeechRecognitionEvent"))];
  dart.registerExtension(dart.global.SpeechRecognitionEvent, SpeechRecognitionEvent);
  dart.defineExtensionNames([
    'item',
    'isFinal',
    'length'
  ]);
  class SpeechRecognitionResult extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.isFinal]() {
      return this.isFinal;
    }
    get [dartx.length]() {
      return this.length;
    }
    [dartx.item](index) {
      return this.item(index);
    }
  }
  dart.setSignature(SpeechRecognitionResult, {
    constructors: () => ({_: [SpeechRecognitionResult, []]}),
    methods: () => ({[dartx.item]: [SpeechRecognitionAlternative, [core.int]]})
  });
  SpeechRecognitionResult[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('SpeechRecognitionResult')), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.CHROME, '25')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("SpeechRecognitionResult"))];
  dart.registerExtension(dart.global.SpeechRecognitionResult, SpeechRecognitionResult);
  dart.defineExtensionNames([
    'cancel',
    'getVoices',
    'pause',
    'resume',
    'speak',
    'paused',
    'pending',
    'speaking'
  ]);
  class SpeechSynthesis extends EventTarget {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.paused]() {
      return this.paused;
    }
    get [dartx.pending]() {
      return this.pending;
    }
    get [dartx.speaking]() {
      return this.speaking;
    }
    [dartx.cancel]() {
      return this.cancel();
    }
    [dartx.getVoices]() {
      return this.getVoices();
    }
    [dartx.pause]() {
      return this.pause();
    }
    [dartx.resume]() {
      return this.resume();
    }
    [dartx.speak](utterance) {
      return this.speak(utterance);
    }
  }
  dart.setSignature(SpeechSynthesis, {
    constructors: () => ({_: [SpeechSynthesis, []]}),
    methods: () => ({
      [dartx.cancel]: [dart.void, []],
      [dartx.getVoices]: [core.List$(SpeechSynthesisVoice), []],
      [dartx.pause]: [dart.void, []],
      [dartx.resume]: [dart.void, []],
      [dartx.speak]: [dart.void, [SpeechSynthesisUtterance]]
    })
  });
  SpeechSynthesis[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('SpeechSynthesis')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("SpeechSynthesis"))];
  dart.registerExtension(dart.global.SpeechSynthesis, SpeechSynthesis);
  dart.defineExtensionNames([
    'charIndex',
    'elapsedTime',
    'name'
  ]);
  class SpeechSynthesisEvent extends Event {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.charIndex]() {
      return this.charIndex;
    }
    get [dartx.elapsedTime]() {
      return this.elapsedTime;
    }
    get [dartx.name]() {
      return this.name;
    }
  }
  dart.setSignature(SpeechSynthesisEvent, {
    constructors: () => ({_: [SpeechSynthesisEvent, []]})
  });
  SpeechSynthesisEvent[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('SpeechSynthesisEvent')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("SpeechSynthesisEvent"))];
  dart.registerExtension(dart.global.SpeechSynthesisEvent, SpeechSynthesisEvent);
  dart.defineExtensionNames([
    'onBoundary',
    'onEnd',
    'onError',
    'onMark',
    'onPause',
    'onResume',
    'onStart',
    'lang',
    'pitch',
    'rate',
    'text',
    'voice',
    'volume'
  ]);
  class SpeechSynthesisUtterance extends EventTarget {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new(text) {
      if (text === void 0) text = null;
      if (text != null) {
        return SpeechSynthesisUtterance._create_1(text);
      }
      return SpeechSynthesisUtterance._create_2();
    }
    static _create_1(text) {
      return dart.as(new SpeechSynthesisUtterance(text), SpeechSynthesisUtterance);
    }
    static _create_2() {
      return dart.as(new SpeechSynthesisUtterance(), SpeechSynthesisUtterance);
    }
    get [dartx.lang]() {
      return this.lang;
    }
    set [dartx.lang](value) {
      this.lang = value;
    }
    get [dartx.pitch]() {
      return this.pitch;
    }
    set [dartx.pitch](value) {
      this.pitch = value;
    }
    get [dartx.rate]() {
      return this.rate;
    }
    set [dartx.rate](value) {
      this.rate = value;
    }
    get [dartx.text]() {
      return this.text;
    }
    set [dartx.text](value) {
      this.text = value;
    }
    get [dartx.voice]() {
      return this.voice;
    }
    set [dartx.voice](value) {
      this.voice = value;
    }
    get [dartx.volume]() {
      return this.volume;
    }
    set [dartx.volume](value) {
      this.volume = value;
    }
    get [dartx.onBoundary]() {
      return SpeechSynthesisUtterance.boundaryEvent.forTarget(this);
    }
    get [dartx.onEnd]() {
      return SpeechSynthesisUtterance.endEvent.forTarget(this);
    }
    get [dartx.onError]() {
      return SpeechSynthesisUtterance.errorEvent.forTarget(this);
    }
    get [dartx.onMark]() {
      return SpeechSynthesisUtterance.markEvent.forTarget(this);
    }
    get [dartx.onPause]() {
      return SpeechSynthesisUtterance.pauseEvent.forTarget(this);
    }
    get [dartx.onResume]() {
      return SpeechSynthesisUtterance.resumeEvent.forTarget(this);
    }
    get [dartx.onStart]() {
      return SpeechSynthesisUtterance.startEvent.forTarget(this);
    }
  }
  dart.setSignature(SpeechSynthesisUtterance, {
    constructors: () => ({
      _: [SpeechSynthesisUtterance, []],
      new: [SpeechSynthesisUtterance, [], [core.String]]
    }),
    statics: () => ({
      _create_1: [SpeechSynthesisUtterance, [dart.dynamic]],
      _create_2: [SpeechSynthesisUtterance, []]
    }),
    names: ['_create_1', '_create_2']
  });
  SpeechSynthesisUtterance[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('SpeechSynthesisUtterance')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("SpeechSynthesisUtterance"))];
  dart.defineLazyProperties(SpeechSynthesisUtterance, {
    get boundaryEvent() {
      return dart.const(new (EventStreamProvider$(SpeechSynthesisEvent))('boundary'));
    },
    get endEvent() {
      return dart.const(new (EventStreamProvider$(SpeechSynthesisEvent))('end'));
    },
    get errorEvent() {
      return dart.const(new (EventStreamProvider$(Event))('error'));
    },
    get markEvent() {
      return dart.const(new (EventStreamProvider$(SpeechSynthesisEvent))('mark'));
    },
    get pauseEvent() {
      return dart.const(new (EventStreamProvider$(Event))('pause'));
    },
    get resumeEvent() {
      return dart.const(new (EventStreamProvider$(SpeechSynthesisEvent))('resume'));
    },
    get startEvent() {
      return dart.const(new (EventStreamProvider$(SpeechSynthesisEvent))('start'));
    }
  });
  dart.registerExtension(dart.global.SpeechSynthesisUtterance, SpeechSynthesisUtterance);
  dart.defineExtensionNames([
    'defaultValue',
    'lang',
    'localService',
    'name',
    'voiceUri'
  ]);
  class SpeechSynthesisVoice extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.defaultValue]() {
      return this.default;
    }
    get [dartx.lang]() {
      return this.lang;
    }
    get [dartx.localService]() {
      return this.localService;
    }
    get [dartx.name]() {
      return this.name;
    }
    get [dartx.voiceUri]() {
      return this.voiceURI;
    }
  }
  dart.setSignature(SpeechSynthesisVoice, {
    constructors: () => ({_: [SpeechSynthesisVoice, []]})
  });
  SpeechSynthesisVoice[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('SpeechSynthesisVoice')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("SpeechSynthesisVoice"))];
  dart.registerExtension(dart.global.SpeechSynthesisVoice, SpeechSynthesisVoice);
  const _getItem = Symbol('_getItem');
  const _setItem = Symbol('_setItem');
  const _removeItem = Symbol('_removeItem');
  const _key = Symbol('_key');
  const _length = Symbol('_length');
  const __delete__ = Symbol('__delete__');
  dart.defineExtensionNames([
    'addAll',
    'containsValue',
    'containsKey',
    'get',
    'set',
    'putIfAbsent',
    'remove',
    'clear',
    'forEach',
    'keys',
    'values',
    'length',
    'isEmpty',
    'isNotEmpty'
  ]);
  class Storage extends _interceptors.Interceptor {
    [dartx.addAll](other) {
      other[dartx.forEach](dart.fn((k, v) => {
        this[dartx.set](k, v);
      }, dart.void, [core.String, core.String]));
    }
    [dartx.containsValue](value) {
      return this[dartx.values][dartx.any](dart.fn(e => e == value, core.bool, [core.String]));
    }
    [dartx.containsKey](key) {
      return this[_getItem](key) != null;
    }
    [dartx.get](key) {
      return this[_getItem](key);
    }
    [dartx.set](key, value) {
      this[_setItem](key, value);
      return value;
    }
    [dartx.putIfAbsent](key, ifAbsent) {
      if (!dart.notNull(this[dartx.containsKey](key))) this[dartx.set](key, ifAbsent());
      return this[dartx.get](key);
    }
    [dartx.remove](key) {
      let value = this[dartx.get](key);
      this[_removeItem](key);
      return value;
    }
    [dartx.clear]() {
      return this[_clear]();
    }
    [dartx.forEach](f) {
      for (let i = 0; true; i++) {
        let key = this[_key](i);
        if (key == null) return;
        f(key, this[dartx.get](key));
      }
    }
    get [dartx.keys]() {
      let keys = [];
      this[dartx.forEach](dart.fn((k, v) => keys[dartx.add](k), dart.void, [core.String, core.String]));
      return dart.as(keys, core.Iterable$(core.String));
    }
    get [dartx.values]() {
      let values = [];
      this[dartx.forEach](dart.fn((k, v) => values[dartx.add](v), dart.void, [core.String, core.String]));
      return dart.as(values, core.Iterable$(core.String));
    }
    get [dartx.length]() {
      return this[_length];
    }
    get [dartx.isEmpty]() {
      return this[_key](0) == null;
    }
    get [dartx.isNotEmpty]() {
      return !dart.notNull(this[dartx.isEmpty]);
    }
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [_length]() {
      return this.length;
    }
    [__delete__](index_OR_name) {
      return this.__delete__(index_OR_name);
    }
    [__getter__](index_OR_name) {
      return this.__getter__(index_OR_name);
    }
    [__setter__](index_OR_name, value) {
      return this.__setter__(index_OR_name, value);
    }
    [_clear]() {
      return this.clear();
    }
    [_getItem](key) {
      return this.getItem(key);
    }
    [_key](index) {
      return this.key(index);
    }
    [_removeItem](key) {
      return this.removeItem(key);
    }
    [_setItem](key, data) {
      return this.setItem(key, data);
    }
  }
  Storage[dart.implements] = () => [core.Map$(core.String, core.String)];
  dart.setSignature(Storage, {
    constructors: () => ({_: [Storage, []]}),
    methods: () => ({
      [dartx.addAll]: [dart.void, [core.Map$(core.String, core.String)]],
      [dartx.containsValue]: [core.bool, [core.String]],
      [dartx.containsKey]: [core.bool, [core.String]],
      [dartx.get]: [core.String, [core.String]],
      [dartx.set]: [dart.void, [core.String, core.String]],
      [dartx.putIfAbsent]: [core.String, [core.String, dart.functionType(core.String, [])]],
      [dartx.remove]: [core.String, [core.String]],
      [dartx.clear]: [dart.void, []],
      [dartx.forEach]: [dart.void, [dart.functionType(dart.void, [core.String, core.String])]],
      [__delete__]: [core.bool, [dart.dynamic]],
      [__getter__]: [core.String, [dart.dynamic]],
      [__setter__]: [dart.void, [dart.dynamic, core.String]],
      [_clear]: [dart.void, []],
      [_getItem]: [core.String, [core.String]],
      [_key]: [core.String, [core.int]],
      [_removeItem]: [dart.void, [core.String]],
      [_setItem]: [dart.void, [core.String, core.String]]
    })
  });
  Storage[dart.metadata] = () => [dart.const(new _metadata.DomName('Storage')), dart.const(new _metadata.Unstable()), dart.const(new _js_helper.Native("Storage"))];
  dart.registerExtension(dart.global.Storage, Storage);
  const StorageErrorCallback = dart.typedef('StorageErrorCallback', () => dart.functionType(dart.void, [DomError]));
  const _initStorageEvent = Symbol('_initStorageEvent');
  dart.defineExtensionNames([
    'key',
    'newValue',
    'oldValue',
    'storageArea',
    'url'
  ]);
  class StorageEvent extends Event {
    static new(type, opts) {
      let canBubble = opts && 'canBubble' in opts ? opts.canBubble : false;
      let cancelable = opts && 'cancelable' in opts ? opts.cancelable : false;
      let key = opts && 'key' in opts ? opts.key : null;
      let oldValue = opts && 'oldValue' in opts ? opts.oldValue : null;
      let newValue = opts && 'newValue' in opts ? opts.newValue : null;
      let url = opts && 'url' in opts ? opts.url : null;
      let storageArea = opts && 'storageArea' in opts ? opts.storageArea : null;
      let e = exports.document[_createEvent]("StorageEvent");
      dart.dcall(e[_initStorageEvent], type, canBubble, cancelable, key, oldValue, newValue, url, storageArea);
      return dart.as(e, StorageEvent);
    }
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.key]() {
      return this.key;
    }
    get [dartx.newValue]() {
      return this.newValue;
    }
    get [dartx.oldValue]() {
      return this.oldValue;
    }
    get [dartx.storageArea]() {
      return this.storageArea;
    }
    get [dartx.url]() {
      return this.url;
    }
    [_initStorageEvent](typeArg, canBubbleArg, cancelableArg, keyArg, oldValueArg, newValueArg, urlArg, storageAreaArg) {
      return this.initStorageEvent(typeArg, canBubbleArg, cancelableArg, keyArg, oldValueArg, newValueArg, urlArg, storageAreaArg);
    }
  }
  dart.setSignature(StorageEvent, {
    constructors: () => ({
      new: [StorageEvent, [core.String], {canBubble: core.bool, cancelable: core.bool, key: core.String, oldValue: core.String, newValue: core.String, url: core.String, storageArea: Storage}],
      _: [StorageEvent, []]
    }),
    methods: () => ({[_initStorageEvent]: [dart.void, [core.String, core.bool, core.bool, core.String, core.String, core.String, core.String, Storage]]})
  });
  StorageEvent[dart.metadata] = () => [dart.const(new _metadata.DomName('StorageEvent')), dart.const(new _metadata.Unstable()), dart.const(new _js_helper.Native("StorageEvent"))];
  dart.registerExtension(dart.global.StorageEvent, StorageEvent);
  dart.defineExtensionNames([
    'quota',
    'usage'
  ]);
  class StorageInfo extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.quota]() {
      return this.quota;
    }
    get [dartx.usage]() {
      return this.usage;
    }
  }
  dart.setSignature(StorageInfo, {
    constructors: () => ({_: [StorageInfo, []]})
  });
  StorageInfo[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('StorageInfo')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("StorageInfo"))];
  dart.registerExtension(dart.global.StorageInfo, StorageInfo);
  dart.defineExtensionNames([
    'queryInfo',
    'requestPersistentQuota',
    'supportedTypes'
  ]);
  class StorageQuota extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.supportedTypes]() {
      return this.supportedTypes;
    }
    [dartx.queryInfo](type) {
      return this.queryInfo(type);
    }
    [dartx.requestPersistentQuota](newQuota) {
      return this.requestPersistentQuota(newQuota);
    }
  }
  dart.setSignature(StorageQuota, {
    constructors: () => ({_: [StorageQuota, []]}),
    methods: () => ({
      [dartx.queryInfo]: [async.Future, [core.String]],
      [dartx.requestPersistentQuota]: [async.Future, [core.int]]
    })
  });
  StorageQuota[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('StorageQuota')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("StorageQuota"))];
  dart.registerExtension(dart.global.StorageQuota, StorageQuota);
  const StorageQuotaCallback = dart.typedef('StorageQuotaCallback', () => dart.functionType(dart.void, [core.int]));
  const StorageUsageCallback = dart.typedef('StorageUsageCallback', () => dart.functionType(dart.void, [core.int, core.int]));
  const _StringCallback = dart.typedef('_StringCallback', () => dart.functionType(dart.void, [core.String]));
  dart.defineExtensionNames([
    'disabled',
    'media',
    'sheet',
    'type'
  ]);
  class StyleElement extends HtmlElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return dart.as(exports.document[dartx.createElement]("style"), StyleElement);
    }
    created() {
      this[dartx.disabled] = null;
      this[dartx.media] = null;
      this[dartx.sheet] = null;
      this[dartx.type] = null;
      super.created();
    }
    get [dartx.disabled]() {
      return this.disabled;
    }
    set [dartx.disabled](value) {
      this.disabled = value;
    }
    get [dartx.media]() {
      return this.media;
    }
    set [dartx.media](value) {
      this.media = value;
    }
    get [dartx.sheet]() {
      return this.sheet;
    }
    get [dartx.type]() {
      return this.type;
    }
    set [dartx.type](value) {
      this.type = value;
    }
  }
  dart.defineNamedConstructor(StyleElement, 'created');
  dart.setSignature(StyleElement, {
    constructors: () => ({
      _: [StyleElement, []],
      new: [StyleElement, []],
      created: [StyleElement, []]
    })
  });
  StyleElement[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('HTMLStyleElement')), dart.const(new _js_helper.Native("HTMLStyleElement"))];
  dart.registerExtension(dart.global.HTMLStyleElement, StyleElement);
  dart.defineExtensionNames([
    'matchMedium',
    'type'
  ]);
  class StyleMedia extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.type]() {
      return this.type;
    }
    [dartx.matchMedium](mediaquery) {
      return this.matchMedium(mediaquery);
    }
  }
  dart.setSignature(StyleMedia, {
    constructors: () => ({_: [StyleMedia, []]}),
    methods: () => ({[dartx.matchMedium]: [core.bool, [core.String]]})
  });
  StyleMedia[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('StyleMedia')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("StyleMedia"))];
  dart.registerExtension(dart.global.StyleMedia, StyleMedia);
  class TableCaptionElement extends HtmlElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return dart.as(exports.document[dartx.createElement]("caption"), TableCaptionElement);
    }
    created() {
      super.created();
    }
  }
  dart.defineNamedConstructor(TableCaptionElement, 'created');
  dart.setSignature(TableCaptionElement, {
    constructors: () => ({
      _: [TableCaptionElement, []],
      new: [TableCaptionElement, []],
      created: [TableCaptionElement, []]
    })
  });
  TableCaptionElement[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('HTMLTableCaptionElement')), dart.const(new _js_helper.Native("HTMLTableCaptionElement"))];
  dart.registerExtension(dart.global.HTMLTableCaptionElement, TableCaptionElement);
  dart.defineExtensionNames([
    'cellIndex',
    'colSpan',
    'headers',
    'rowSpan'
  ]);
  class TableCellElement extends HtmlElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return dart.as(exports.document[dartx.createElement]("td"), TableCellElement);
    }
    created() {
      this[dartx.cellIndex] = null;
      this[dartx.colSpan] = null;
      this[dartx.headers] = null;
      this[dartx.rowSpan] = null;
      super.created();
    }
    get [dartx.cellIndex]() {
      return this.cellIndex;
    }
    get [dartx.colSpan]() {
      return this.colSpan;
    }
    set [dartx.colSpan](value) {
      this.colSpan = value;
    }
    get [dartx.headers]() {
      return this.headers;
    }
    set [dartx.headers](value) {
      this.headers = value;
    }
    get [dartx.rowSpan]() {
      return this.rowSpan;
    }
    set [dartx.rowSpan](value) {
      this.rowSpan = value;
    }
  }
  dart.defineNamedConstructor(TableCellElement, 'created');
  dart.setSignature(TableCellElement, {
    constructors: () => ({
      _: [TableCellElement, []],
      new: [TableCellElement, []],
      created: [TableCellElement, []]
    })
  });
  TableCellElement[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('HTMLTableCellElement')), dart.const(new _js_helper.Native("HTMLTableCellElement,HTMLTableDataCellElement,HTMLTableHeaderCellElement"))];
  dart.registerExtension(dart.global.HTMLTableCellElement, TableCellElement);
  dart.defineExtensionNames([
    'span'
  ]);
  class TableColElement extends HtmlElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return dart.as(exports.document[dartx.createElement]("col"), TableColElement);
    }
    created() {
      this[dartx.span] = null;
      super.created();
    }
    get [dartx.span]() {
      return this.span;
    }
    set [dartx.span](value) {
      this.span = value;
    }
  }
  dart.defineNamedConstructor(TableColElement, 'created');
  dart.setSignature(TableColElement, {
    constructors: () => ({
      _: [TableColElement, []],
      new: [TableColElement, []],
      created: [TableColElement, []]
    })
  });
  TableColElement[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('HTMLTableColElement')), dart.const(new _js_helper.Native("HTMLTableColElement"))];
  dart.registerExtension(dart.global.HTMLTableColElement, TableColElement);
  const _tBodies = Symbol('_tBodies');
  const _rows = Symbol('_rows');
  const _createCaption = Symbol('_createCaption');
  const _createTBody = Symbol('_createTBody');
  const _createTFoot = Symbol('_createTFoot');
  const _createTHead = Symbol('_createTHead');
  const _insertRow = Symbol('_insertRow');
  const _nativeCreateTBody = Symbol('_nativeCreateTBody');
  dart.defineExtensionNames([
    'tBodies',
    'rows',
    'addRow',
    'createCaption',
    'createTBody',
    'createTFoot',
    'createTHead',
    'insertRow',
    'createFragment',
    'deleteCaption',
    'deleteRow',
    'deleteTFoot',
    'deleteTHead',
    'caption',
    'tFoot',
    'tHead'
  ]);
  class TableElement extends HtmlElement {
    get [dartx.tBodies]() {
      return new (_WrappedList$(TableSectionElement))(this[_tBodies]);
    }
    get [dartx.rows]() {
      return new (_WrappedList$(TableRowElement))(this[_rows]);
    }
    [dartx.addRow]() {
      return this[dartx.insertRow](-1);
    }
    [dartx.createCaption]() {
      return dart.as(this[_createCaption](), TableCaptionElement);
    }
    [dartx.createTBody]() {
      return this[_createTBody]();
    }
    [dartx.createTFoot]() {
      return dart.as(this[_createTFoot](), TableSectionElement);
    }
    [dartx.createTHead]() {
      return dart.as(this[_createTHead](), TableSectionElement);
    }
    [dartx.insertRow](index) {
      return dart.as(this[_insertRow](index), TableRowElement);
    }
    [_createTBody]() {
      if (!!this.createTBody) {
        return this[_nativeCreateTBody]();
      }
      let tbody = Element.tag('tbody');
      this[dartx.children][dartx.add](tbody);
      return dart.as(tbody, TableSectionElement);
    }
    [_nativeCreateTBody]() {
      return this.createTBody();
    }
    [dartx.createFragment](html, opts) {
      let validator = opts && 'validator' in opts ? opts.validator : null;
      let treeSanitizer = opts && 'treeSanitizer' in opts ? opts.treeSanitizer : null;
      if (dart.notNull(Range.supportsCreateContextualFragment)) {
        return super[dartx.createFragment](html, {validator: validator, treeSanitizer: treeSanitizer});
      }
      let contextualHtml = `<table>${html}</table>`;
      let table = Element.html(contextualHtml, {validator: validator, treeSanitizer: treeSanitizer});
      let fragment = DocumentFragment.new();
      fragment[dartx.nodes][dartx.addAll](table[dartx.nodes]);
      return fragment;
    }
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return dart.as(exports.document[dartx.createElement]("table"), TableElement);
    }
    created() {
      this[dartx.caption] = null;
      this[_rows] = null;
      this[_tBodies] = null;
      this[dartx.tFoot] = null;
      this[dartx.tHead] = null;
      super.created();
    }
    get [dartx.caption]() {
      return this.caption;
    }
    set [dartx.caption](value) {
      this.caption = value;
    }
    get [_rows]() {
      return this.rows;
    }
    get [_tBodies]() {
      return this.tBodies;
    }
    get [dartx.tFoot]() {
      return this.tFoot;
    }
    set [dartx.tFoot](value) {
      this.tFoot = value;
    }
    get [dartx.tHead]() {
      return this.tHead;
    }
    set [dartx.tHead](value) {
      this.tHead = value;
    }
    [_createCaption]() {
      return this.createCaption();
    }
    [_createTFoot]() {
      return this.createTFoot();
    }
    [_createTHead]() {
      return this.createTHead();
    }
    [dartx.deleteCaption]() {
      return this.deleteCaption();
    }
    [dartx.deleteRow](index) {
      return this.deleteRow(index);
    }
    [dartx.deleteTFoot]() {
      return this.deleteTFoot();
    }
    [dartx.deleteTHead]() {
      return this.deleteTHead();
    }
    [_insertRow](index) {
      return this.insertRow(index);
    }
  }
  dart.defineNamedConstructor(TableElement, 'created');
  dart.setSignature(TableElement, {
    constructors: () => ({
      _: [TableElement, []],
      new: [TableElement, []],
      created: [TableElement, []]
    }),
    methods: () => ({
      [dartx.addRow]: [TableRowElement, []],
      [dartx.createCaption]: [TableCaptionElement, []],
      [dartx.createTBody]: [TableSectionElement, []],
      [dartx.createTFoot]: [TableSectionElement, []],
      [dartx.createTHead]: [TableSectionElement, []],
      [dartx.insertRow]: [TableRowElement, [core.int]],
      [_createTBody]: [TableSectionElement, []],
      [_nativeCreateTBody]: [TableSectionElement, []],
      [_createCaption]: [HtmlElement, []],
      [_createTFoot]: [HtmlElement, []],
      [_createTHead]: [HtmlElement, []],
      [dartx.deleteCaption]: [dart.void, []],
      [dartx.deleteRow]: [dart.void, [core.int]],
      [dartx.deleteTFoot]: [dart.void, []],
      [dartx.deleteTHead]: [dart.void, []],
      [_insertRow]: [HtmlElement, [], [core.int]]
    })
  });
  TableElement[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('HTMLTableElement')), dart.const(new _js_helper.Native("HTMLTableElement"))];
  dart.registerExtension(dart.global.HTMLTableElement, TableElement);
  const _cells = Symbol('_cells');
  const _insertCell = Symbol('_insertCell');
  dart.defineExtensionNames([
    'cells',
    'addCell',
    'insertCell',
    'createFragment',
    'deleteCell',
    'rowIndex',
    'sectionRowIndex'
  ]);
  class TableRowElement extends HtmlElement {
    get [dartx.cells]() {
      return new (_WrappedList$(TableCellElement))(this[_cells]);
    }
    [dartx.addCell]() {
      return this[dartx.insertCell](-1);
    }
    [dartx.insertCell](index) {
      return dart.as(this[_insertCell](index), TableCellElement);
    }
    [dartx.createFragment](html, opts) {
      let validator = opts && 'validator' in opts ? opts.validator : null;
      let treeSanitizer = opts && 'treeSanitizer' in opts ? opts.treeSanitizer : null;
      if (dart.notNull(Range.supportsCreateContextualFragment)) {
        return super[dartx.createFragment](html, {validator: validator, treeSanitizer: treeSanitizer});
      }
      let fragment = DocumentFragment.new();
      let section = TableElement.new()[dartx.createFragment](html, {validator: validator, treeSanitizer: treeSanitizer})[dartx.nodes][dartx.single];
      let row = section[dartx.nodes][dartx.single];
      fragment[dartx.nodes][dartx.addAll](row[dartx.nodes]);
      return fragment;
    }
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return dart.as(exports.document[dartx.createElement]("tr"), TableRowElement);
    }
    created() {
      this[_cells] = null;
      this[dartx.rowIndex] = null;
      this[dartx.sectionRowIndex] = null;
      super.created();
    }
    get [_cells]() {
      return this.cells;
    }
    get [dartx.rowIndex]() {
      return this.rowIndex;
    }
    get [dartx.sectionRowIndex]() {
      return this.sectionRowIndex;
    }
    [dartx.deleteCell](index) {
      return this.deleteCell(index);
    }
    [_insertCell](index) {
      return this.insertCell(index);
    }
  }
  dart.defineNamedConstructor(TableRowElement, 'created');
  dart.setSignature(TableRowElement, {
    constructors: () => ({
      _: [TableRowElement, []],
      new: [TableRowElement, []],
      created: [TableRowElement, []]
    }),
    methods: () => ({
      [dartx.addCell]: [TableCellElement, []],
      [dartx.insertCell]: [TableCellElement, [core.int]],
      [dartx.deleteCell]: [dart.void, [core.int]],
      [_insertCell]: [HtmlElement, [], [core.int]]
    })
  });
  TableRowElement[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('HTMLTableRowElement')), dart.const(new _js_helper.Native("HTMLTableRowElement"))];
  dart.registerExtension(dart.global.HTMLTableRowElement, TableRowElement);
  dart.defineExtensionNames([
    'rows',
    'addRow',
    'insertRow',
    'createFragment',
    'deleteRow'
  ]);
  class TableSectionElement extends HtmlElement {
    get [dartx.rows]() {
      return new (_WrappedList$(TableRowElement))(this[_rows]);
    }
    [dartx.addRow]() {
      return this[dartx.insertRow](-1);
    }
    [dartx.insertRow](index) {
      return dart.as(this[_insertRow](index), TableRowElement);
    }
    [dartx.createFragment](html, opts) {
      let validator = opts && 'validator' in opts ? opts.validator : null;
      let treeSanitizer = opts && 'treeSanitizer' in opts ? opts.treeSanitizer : null;
      if (dart.notNull(Range.supportsCreateContextualFragment)) {
        return super[dartx.createFragment](html, {validator: validator, treeSanitizer: treeSanitizer});
      }
      let fragment = DocumentFragment.new();
      let section = TableElement.new()[dartx.createFragment](html, {validator: validator, treeSanitizer: treeSanitizer})[dartx.nodes][dartx.single];
      fragment[dartx.nodes][dartx.addAll](section[dartx.nodes]);
      return fragment;
    }
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    created() {
      this[_rows] = null;
      super.created();
    }
    get [_rows]() {
      return this.rows;
    }
    [dartx.deleteRow](index) {
      return this.deleteRow(index);
    }
    [_insertRow](index) {
      return this.insertRow(index);
    }
  }
  dart.defineNamedConstructor(TableSectionElement, 'created');
  dart.setSignature(TableSectionElement, {
    constructors: () => ({
      _: [TableSectionElement, []],
      created: [TableSectionElement, []]
    }),
    methods: () => ({
      [dartx.addRow]: [TableRowElement, []],
      [dartx.insertRow]: [TableRowElement, [core.int]],
      [dartx.deleteRow]: [dart.void, [core.int]],
      [_insertRow]: [HtmlElement, [], [core.int]]
    })
  });
  TableSectionElement[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('HTMLTableSectionElement')), dart.const(new _js_helper.Native("HTMLTableSectionElement"))];
  dart.registerExtension(dart.global.HTMLTableSectionElement, TableSectionElement);
  dart.defineExtensionNames([
    'setInnerHtml',
    'content'
  ]);
  class TemplateElement extends HtmlElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return dart.as(exports.document[dartx.createElement]("template"), TemplateElement);
    }
    created() {
      this[dartx.content] = null;
      super.created();
    }
    static get supported() {
      return Element.isTagSupported('template');
    }
    get [dartx.content]() {
      return this.content;
    }
    [dartx.setInnerHtml](html, opts) {
      let validator = opts && 'validator' in opts ? opts.validator : null;
      let treeSanitizer = opts && 'treeSanitizer' in opts ? opts.treeSanitizer : null;
      this[dartx.text] = null;
      let fragment = this[dartx.createFragment](html, {validator: validator, treeSanitizer: treeSanitizer});
      this[dartx.content][dartx.append](fragment);
    }
  }
  dart.defineNamedConstructor(TemplateElement, 'created');
  dart.setSignature(TemplateElement, {
    constructors: () => ({
      _: [TemplateElement, []],
      new: [TemplateElement, []],
      created: [TemplateElement, []]
    })
  });
  TemplateElement[dart.metadata] = () => [dart.const(new _metadata.Experimental()), dart.const(new _metadata.DomName('HTMLTemplateElement')), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.CHROME)), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("HTMLTemplateElement"))];
  dart.registerExtension(dart.global.HTMLTemplateElement, TemplateElement);
  dart.defineExtensionNames([
    'checkValidity',
    'select',
    'setCustomValidity',
    'setRangeText',
    'setSelectionRange',
    'autofocus',
    'cols',
    'defaultValue',
    'dirName',
    'disabled',
    'form',
    'inputMode',
    'labels',
    'maxLength',
    'name',
    'placeholder',
    'readOnly',
    'required',
    'rows',
    'selectionDirection',
    'selectionEnd',
    'selectionStart',
    'textLength',
    'type',
    'validationMessage',
    'validity',
    'value',
    'willValidate',
    'wrap'
  ]);
  class TextAreaElement extends HtmlElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return dart.as(exports.document[dartx.createElement]("textarea"), TextAreaElement);
    }
    created() {
      this[dartx.autofocus] = null;
      this[dartx.cols] = null;
      this[dartx.defaultValue] = null;
      this[dartx.dirName] = null;
      this[dartx.disabled] = null;
      this[dartx.form] = null;
      this[dartx.inputMode] = null;
      this[dartx.labels] = null;
      this[dartx.maxLength] = null;
      this[dartx.name] = null;
      this[dartx.placeholder] = null;
      this[dartx.readOnly] = null;
      this[dartx.required] = null;
      this[dartx.rows] = null;
      this[dartx.selectionDirection] = null;
      this[dartx.selectionEnd] = null;
      this[dartx.selectionStart] = null;
      this[dartx.textLength] = null;
      this[dartx.type] = null;
      this[dartx.validationMessage] = null;
      this[dartx.validity] = null;
      this[dartx.value] = null;
      this[dartx.willValidate] = null;
      this[dartx.wrap] = null;
      super.created();
    }
    get [dartx.autofocus]() {
      return this.autofocus;
    }
    set [dartx.autofocus](value) {
      this.autofocus = value;
    }
    get [dartx.cols]() {
      return this.cols;
    }
    set [dartx.cols](value) {
      this.cols = value;
    }
    get [dartx.defaultValue]() {
      return this.defaultValue;
    }
    set [dartx.defaultValue](value) {
      this.defaultValue = value;
    }
    get [dartx.dirName]() {
      return this.dirName;
    }
    set [dartx.dirName](value) {
      this.dirName = value;
    }
    get [dartx.disabled]() {
      return this.disabled;
    }
    set [dartx.disabled](value) {
      this.disabled = value;
    }
    get [dartx.form]() {
      return this.form;
    }
    get [dartx.inputMode]() {
      return this.inputMode;
    }
    set [dartx.inputMode](value) {
      this.inputMode = value;
    }
    get [dartx.labels]() {
      return this.labels;
    }
    get [dartx.maxLength]() {
      return this.maxLength;
    }
    set [dartx.maxLength](value) {
      this.maxLength = value;
    }
    get [dartx.name]() {
      return this.name;
    }
    set [dartx.name](value) {
      this.name = value;
    }
    get [dartx.placeholder]() {
      return this.placeholder;
    }
    set [dartx.placeholder](value) {
      this.placeholder = value;
    }
    get [dartx.readOnly]() {
      return this.readOnly;
    }
    set [dartx.readOnly](value) {
      this.readOnly = value;
    }
    get [dartx.required]() {
      return this.required;
    }
    set [dartx.required](value) {
      this.required = value;
    }
    get [dartx.rows]() {
      return this.rows;
    }
    set [dartx.rows](value) {
      this.rows = value;
    }
    get [dartx.selectionDirection]() {
      return this.selectionDirection;
    }
    set [dartx.selectionDirection](value) {
      this.selectionDirection = value;
    }
    get [dartx.selectionEnd]() {
      return this.selectionEnd;
    }
    set [dartx.selectionEnd](value) {
      this.selectionEnd = value;
    }
    get [dartx.selectionStart]() {
      return this.selectionStart;
    }
    set [dartx.selectionStart](value) {
      this.selectionStart = value;
    }
    get [dartx.textLength]() {
      return this.textLength;
    }
    get [dartx.type]() {
      return this.type;
    }
    get [dartx.validationMessage]() {
      return this.validationMessage;
    }
    get [dartx.validity]() {
      return this.validity;
    }
    get [dartx.value]() {
      return this.value;
    }
    set [dartx.value](value) {
      this.value = value;
    }
    get [dartx.willValidate]() {
      return this.willValidate;
    }
    get [dartx.wrap]() {
      return this.wrap;
    }
    set [dartx.wrap](value) {
      this.wrap = value;
    }
    [dartx.checkValidity]() {
      return this.checkValidity();
    }
    [dartx.select]() {
      return this.select();
    }
    [dartx.setCustomValidity](error) {
      return this.setCustomValidity(error);
    }
    [dartx.setRangeText](replacement, opts) {
      return this.setRangeText(replacement, opts);
    }
    [dartx.setSelectionRange](start, end, direction) {
      return this.setSelectionRange(start, end, direction);
    }
  }
  dart.defineNamedConstructor(TextAreaElement, 'created');
  dart.setSignature(TextAreaElement, {
    constructors: () => ({
      _: [TextAreaElement, []],
      new: [TextAreaElement, []],
      created: [TextAreaElement, []]
    }),
    methods: () => ({
      [dartx.checkValidity]: [core.bool, []],
      [dartx.select]: [dart.void, []],
      [dartx.setCustomValidity]: [dart.void, [core.String]],
      [dartx.setRangeText]: [dart.void, [core.String], {start: core.int, end: core.int, selectionMode: core.String}],
      [dartx.setSelectionRange]: [dart.void, [core.int, core.int], [core.String]]
    })
  });
  TextAreaElement[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('HTMLTextAreaElement')), dart.const(new _js_helper.Native("HTMLTextAreaElement"))];
  dart.registerExtension(dart.global.HTMLTextAreaElement, TextAreaElement);
  const _initTextEvent = Symbol('_initTextEvent');
  dart.defineExtensionNames([
    'data'
  ]);
  class TextEvent extends UIEvent {
    static new(type, opts) {
      let canBubble = opts && 'canBubble' in opts ? opts.canBubble : false;
      let cancelable = opts && 'cancelable' in opts ? opts.cancelable : false;
      let view = opts && 'view' in opts ? opts.view : null;
      let data = opts && 'data' in opts ? opts.data : null;
      if (view == null) {
        view = exports.window;
      }
      let e = exports.document[_createEvent]("TextEvent");
      dart.dcall(e[_initTextEvent], type, canBubble, cancelable, view, data);
      return dart.as(e, TextEvent);
    }
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.data]() {
      return this.data;
    }
    [_initTextEvent](typeArg, canBubbleArg, cancelableArg, viewArg, dataArg) {
      return this.initTextEvent(typeArg, canBubbleArg, cancelableArg, viewArg, dataArg);
    }
  }
  dart.setSignature(TextEvent, {
    constructors: () => ({
      new: [TextEvent, [core.String], {canBubble: core.bool, cancelable: core.bool, view: Window, data: core.String}],
      _: [TextEvent, []]
    }),
    methods: () => ({[_initTextEvent]: [dart.void, [core.String, core.bool, core.bool, Window, core.String]]})
  });
  TextEvent[dart.metadata] = () => [dart.const(new _metadata.DomName('TextEvent')), dart.const(new _metadata.Unstable()), dart.const(new _js_helper.Native("TextEvent"))];
  dart.registerExtension(dart.global.TextEvent, TextEvent);
  dart.defineExtensionNames([
    'actualBoundingBoxAscent',
    'actualBoundingBoxDescent',
    'actualBoundingBoxLeft',
    'actualBoundingBoxRight',
    'alphabeticBaseline',
    'emHeightAscent',
    'emHeightDescent',
    'fontBoundingBoxAscent',
    'fontBoundingBoxDescent',
    'hangingBaseline',
    'ideographicBaseline',
    'width'
  ]);
  class TextMetrics extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.actualBoundingBoxAscent]() {
      return this.actualBoundingBoxAscent;
    }
    get [dartx.actualBoundingBoxDescent]() {
      return this.actualBoundingBoxDescent;
    }
    get [dartx.actualBoundingBoxLeft]() {
      return this.actualBoundingBoxLeft;
    }
    get [dartx.actualBoundingBoxRight]() {
      return this.actualBoundingBoxRight;
    }
    get [dartx.alphabeticBaseline]() {
      return this.alphabeticBaseline;
    }
    get [dartx.emHeightAscent]() {
      return this.emHeightAscent;
    }
    get [dartx.emHeightDescent]() {
      return this.emHeightDescent;
    }
    get [dartx.fontBoundingBoxAscent]() {
      return this.fontBoundingBoxAscent;
    }
    get [dartx.fontBoundingBoxDescent]() {
      return this.fontBoundingBoxDescent;
    }
    get [dartx.hangingBaseline]() {
      return this.hangingBaseline;
    }
    get [dartx.ideographicBaseline]() {
      return this.ideographicBaseline;
    }
    get [dartx.width]() {
      return this.width;
    }
  }
  dart.setSignature(TextMetrics, {
    constructors: () => ({_: [TextMetrics, []]})
  });
  TextMetrics[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('TextMetrics')), dart.const(new _js_helper.Native("TextMetrics"))];
  dart.registerExtension(dart.global.TextMetrics, TextMetrics);
  dart.defineExtensionNames([
    'addCue',
    'addRegion',
    'removeCue',
    'removeRegion',
    'onCueChange',
    'activeCues',
    'cues',
    'id',
    'kind',
    'label',
    'language',
    'mode',
    'regions'
  ]);
  class TextTrack extends EventTarget {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.activeCues]() {
      return this.activeCues;
    }
    get [dartx.cues]() {
      return this.cues;
    }
    get [dartx.id]() {
      return this.id;
    }
    get [dartx.kind]() {
      return this.kind;
    }
    get [dartx.label]() {
      return this.label;
    }
    get [dartx.language]() {
      return this.language;
    }
    get [dartx.mode]() {
      return this.mode;
    }
    set [dartx.mode](value) {
      this.mode = value;
    }
    get [dartx.regions]() {
      return this.regions;
    }
    [dartx.addCue](cue) {
      return this.addCue(cue);
    }
    [dartx.addRegion](region) {
      return this.addRegion(region);
    }
    [dartx.removeCue](cue) {
      return this.removeCue(cue);
    }
    [dartx.removeRegion](region) {
      return this.removeRegion(region);
    }
    get [dartx.onCueChange]() {
      return TextTrack.cueChangeEvent.forTarget(this);
    }
  }
  dart.setSignature(TextTrack, {
    constructors: () => ({_: [TextTrack, []]}),
    methods: () => ({
      [dartx.addCue]: [dart.void, [TextTrackCue]],
      [dartx.addRegion]: [dart.void, [VttRegion]],
      [dartx.removeCue]: [dart.void, [TextTrackCue]],
      [dartx.removeRegion]: [dart.void, [VttRegion]]
    })
  });
  TextTrack[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('TextTrack')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("TextTrack"))];
  dart.defineLazyProperties(TextTrack, {
    get cueChangeEvent() {
      return dart.const(new (EventStreamProvider$(Event))('cuechange'));
    }
  });
  dart.registerExtension(dart.global.TextTrack, TextTrack);
  dart.defineExtensionNames([
    'onEnter',
    'onExit',
    'endTime',
    'id',
    'pauseOnExit',
    'startTime',
    'track'
  ]);
  class TextTrackCue extends EventTarget {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.endTime]() {
      return this.endTime;
    }
    set [dartx.endTime](value) {
      this.endTime = value;
    }
    get [dartx.id]() {
      return this.id;
    }
    set [dartx.id](value) {
      this.id = value;
    }
    get [dartx.pauseOnExit]() {
      return this.pauseOnExit;
    }
    set [dartx.pauseOnExit](value) {
      this.pauseOnExit = value;
    }
    get [dartx.startTime]() {
      return this.startTime;
    }
    set [dartx.startTime](value) {
      this.startTime = value;
    }
    get [dartx.track]() {
      return this.track;
    }
    get [dartx.onEnter]() {
      return TextTrackCue.enterEvent.forTarget(this);
    }
    get [dartx.onExit]() {
      return TextTrackCue.exitEvent.forTarget(this);
    }
  }
  dart.setSignature(TextTrackCue, {
    constructors: () => ({_: [TextTrackCue, []]})
  });
  TextTrackCue[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('TextTrackCue')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("TextTrackCue"))];
  dart.defineLazyProperties(TextTrackCue, {
    get enterEvent() {
      return dart.const(new (EventStreamProvider$(Event))('enter'));
    },
    get exitEvent() {
      return dart.const(new (EventStreamProvider$(Event))('exit'));
    }
  });
  dart.registerExtension(dart.global.TextTrackCue, TextTrackCue);
  dart.defineExtensionNames([
    'length',
    'get',
    'set',
    'length',
    'first',
    'last',
    'single',
    'elementAt',
    'getCueById',
    'item'
  ]);
  class TextTrackCueList extends dart.mixin(_interceptors.Interceptor, collection.ListMixin$(TextTrackCue), ImmutableListMixin$(TextTrackCue)) {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.length]() {
      return this.length;
    }
    [dartx.get](index) {
      if (index >>> 0 !== index || index >= this[dartx.length]) dart.throw(core.RangeError.index(index, this));
      return dart.as(this[index], TextTrackCue);
    }
    [dartx.set](index, value) {
      dart.throw(new core.UnsupportedError("Cannot assign element of immutable List."));
      return value;
    }
    set [dartx.length](value) {
      dart.throw(new core.UnsupportedError("Cannot resize immutable List."));
    }
    get [dartx.first]() {
      if (dart.notNull(this[dartx.length]) > 0) {
        return dart.as(this[0], TextTrackCue);
      }
      dart.throw(new core.StateError("No elements"));
    }
    get [dartx.last]() {
      let len = this[dartx.length];
      if (dart.notNull(len) > 0) {
        return dart.as(this[dart.notNull(len) - 1], TextTrackCue);
      }
      dart.throw(new core.StateError("No elements"));
    }
    get [dartx.single]() {
      let len = this[dartx.length];
      if (len == 1) {
        return dart.as(this[0], TextTrackCue);
      }
      if (len == 0) dart.throw(new core.StateError("No elements"));
      dart.throw(new core.StateError("More than one element"));
    }
    [dartx.elementAt](index) {
      return this[dartx.get](index);
    }
    [dartx.getCueById](id) {
      return this.getCueById(id);
    }
    [dartx.item](index) {
      return this.item(index);
    }
  }
  TextTrackCueList[dart.implements] = () => [core.List$(TextTrackCue), _js_helper.JavaScriptIndexingBehavior];
  dart.setSignature(TextTrackCueList, {
    constructors: () => ({_: [TextTrackCueList, []]}),
    methods: () => ({
      [dartx.get]: [TextTrackCue, [core.int]],
      [dartx.set]: [dart.void, [core.int, TextTrackCue]],
      [dartx.elementAt]: [TextTrackCue, [core.int]],
      [dartx.getCueById]: [TextTrackCue, [core.String]],
      [dartx.item]: [TextTrackCue, [core.int]]
    })
  });
  TextTrackCueList[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('TextTrackCueList')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("TextTrackCueList"))];
  dart.registerExtension(dart.global.TextTrackCueList, TextTrackCueList);
  dart.defineExtensionNames([
    'length',
    'get',
    'set',
    'length',
    'first',
    'last',
    'single',
    'elementAt',
    'getTrackById',
    'item',
    'onAddTrack',
    'onChange'
  ]);
  class TextTrackList extends dart.mixin(EventTarget, collection.ListMixin$(TextTrack), ImmutableListMixin$(TextTrack)) {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.length]() {
      return this.length;
    }
    [dartx.get](index) {
      if (index >>> 0 !== index || index >= this[dartx.length]) dart.throw(core.RangeError.index(index, this));
      return dart.as(this[index], TextTrack);
    }
    [dartx.set](index, value) {
      dart.throw(new core.UnsupportedError("Cannot assign element of immutable List."));
      return value;
    }
    set [dartx.length](value) {
      dart.throw(new core.UnsupportedError("Cannot resize immutable List."));
    }
    get [dartx.first]() {
      if (dart.notNull(this[dartx.length]) > 0) {
        return dart.as(this[0], TextTrack);
      }
      dart.throw(new core.StateError("No elements"));
    }
    get [dartx.last]() {
      let len = this[dartx.length];
      if (dart.notNull(len) > 0) {
        return dart.as(this[dart.notNull(len) - 1], TextTrack);
      }
      dart.throw(new core.StateError("No elements"));
    }
    get [dartx.single]() {
      let len = this[dartx.length];
      if (len == 1) {
        return dart.as(this[0], TextTrack);
      }
      if (len == 0) dart.throw(new core.StateError("No elements"));
      dart.throw(new core.StateError("More than one element"));
    }
    [dartx.elementAt](index) {
      return this[dartx.get](index);
    }
    [dartx.getTrackById](id) {
      return this.getTrackById(id);
    }
    [dartx.item](index) {
      return this.item(index);
    }
    get [dartx.onAddTrack]() {
      return TextTrackList.addTrackEvent.forTarget(this);
    }
    get [dartx.onChange]() {
      return TextTrackList.changeEvent.forTarget(this);
    }
  }
  TextTrackList[dart.implements] = () => [_js_helper.JavaScriptIndexingBehavior, core.List$(TextTrack)];
  dart.setSignature(TextTrackList, {
    constructors: () => ({_: [TextTrackList, []]}),
    methods: () => ({
      [dartx.get]: [TextTrack, [core.int]],
      [dartx.set]: [dart.void, [core.int, TextTrack]],
      [dartx.elementAt]: [TextTrack, [core.int]],
      [dartx.getTrackById]: [TextTrack, [core.String]],
      [dartx.item]: [TextTrack, [core.int]]
    })
  });
  TextTrackList[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('TextTrackList')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("TextTrackList"))];
  dart.defineLazyProperties(TextTrackList, {
    get addTrackEvent() {
      return dart.const(new (EventStreamProvider$(TrackEvent))('addtrack'));
    },
    get changeEvent() {
      return dart.const(new (EventStreamProvider$(Event))('change'));
    }
  });
  dart.registerExtension(dart.global.TextTrackList, TextTrackList);
  dart.defineExtensionNames([
    'end',
    'start',
    'length'
  ]);
  class TimeRanges extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.length]() {
      return this.length;
    }
    [dartx.end](index) {
      return this.end(index);
    }
    [dartx.start](index) {
      return this.start(index);
    }
  }
  dart.setSignature(TimeRanges, {
    constructors: () => ({_: [TimeRanges, []]}),
    methods: () => ({
      [dartx.end]: [core.double, [core.int]],
      [dartx.start]: [core.double, [core.int]]
    })
  });
  TimeRanges[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('TimeRanges')), dart.const(new _metadata.Unstable()), dart.const(new _js_helper.Native("TimeRanges"))];
  dart.registerExtension(dart.global.TimeRanges, TimeRanges);
  const TimeoutHandler = dart.typedef('TimeoutHandler', () => dart.functionType(dart.void, []));
  dart.defineExtensionNames([
    'delay',
    'direction',
    'easing',
    'endDelay',
    'fill',
    'iterationStart',
    'iterations',
    'playbackRate'
  ]);
  class Timing extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.delay]() {
      return this.delay;
    }
    set [dartx.delay](value) {
      this.delay = value;
    }
    get [dartx.direction]() {
      return this.direction;
    }
    set [dartx.direction](value) {
      this.direction = value;
    }
    get [dartx.easing]() {
      return this.easing;
    }
    set [dartx.easing](value) {
      this.easing = value;
    }
    get [dartx.endDelay]() {
      return this.endDelay;
    }
    set [dartx.endDelay](value) {
      this.endDelay = value;
    }
    get [dartx.fill]() {
      return this.fill;
    }
    set [dartx.fill](value) {
      this.fill = value;
    }
    get [dartx.iterationStart]() {
      return this.iterationStart;
    }
    set [dartx.iterationStart](value) {
      this.iterationStart = value;
    }
    get [dartx.iterations]() {
      return this.iterations;
    }
    set [dartx.iterations](value) {
      this.iterations = value;
    }
    get [dartx.playbackRate]() {
      return this.playbackRate;
    }
    set [dartx.playbackRate](value) {
      this.playbackRate = value;
    }
    [__getter__](name) {
      return this.__getter__(name);
    }
    [__setter__](name, duration) {
      return this.__setter__(name, duration);
    }
  }
  dart.setSignature(Timing, {
    constructors: () => ({_: [Timing, []]}),
    methods: () => ({
      [__getter__]: [core.Object, [core.String]],
      [__setter__]: [dart.void, [core.String, core.num]]
    })
  });
  Timing[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('Timing')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("Timing"))];
  dart.registerExtension(dart.global.Timing, Timing);
  class TitleElement extends HtmlElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return dart.as(exports.document[dartx.createElement]("title"), TitleElement);
    }
    created() {
      super.created();
    }
  }
  dart.defineNamedConstructor(TitleElement, 'created');
  dart.setSignature(TitleElement, {
    constructors: () => ({
      _: [TitleElement, []],
      new: [TitleElement, []],
      created: [TitleElement, []]
    })
  });
  TitleElement[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('HTMLTitleElement')), dart.const(new _js_helper.Native("HTMLTitleElement"))];
  dart.registerExtension(dart.global.HTMLTitleElement, TitleElement);
  const _radiusX = Symbol('_radiusX');
  const _radiusY = Symbol('_radiusY');
  const __clientX = Symbol('__clientX');
  const __clientY = Symbol('__clientY');
  const __screenX = Symbol('__screenX');
  const __screenY = Symbol('__screenY');
  const __pageX = Symbol('__pageX');
  const __pageY = Symbol('__pageY');
  const __radiusX = Symbol('__radiusX');
  const __radiusY = Symbol('__radiusY');
  dart.defineExtensionNames([
    'target',
    'client',
    'page',
    'screen',
    'radiusX',
    'radiusY',
    'force',
    'identifier',
    'rotationAngle'
  ]);
  class Touch extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [_clientX]() {
      return this.clientX;
    }
    get [_clientY]() {
      return this.clientY;
    }
    get [dartx.force]() {
      return this.force;
    }
    get [dartx.identifier]() {
      return this.identifier;
    }
    get [_pageX]() {
      return this.pageX;
    }
    get [_pageY]() {
      return this.pageY;
    }
    get [_radiusX]() {
      return this.radiusX;
    }
    get [_radiusY]() {
      return this.radiusY;
    }
    get [_screenX]() {
      return this.screenX;
    }
    get [_screenY]() {
      return this.screenY;
    }
    get [dartx.target]() {
      return _convertNativeToDart_EventTarget(this[_get_target]);
    }
    get [_get_target]() {
      return this.target;
    }
    get [dartx.rotationAngle]() {
      return this.webkitRotationAngle;
    }
    get [__clientX]() {
      return this.clientX[dartx.round]();
    }
    get [__clientY]() {
      return this.clientY[dartx.round]();
    }
    get [__screenX]() {
      return this.screenX[dartx.round]();
    }
    get [__screenY]() {
      return this.screenY[dartx.round]();
    }
    get [__pageX]() {
      return this.pageX[dartx.round]();
    }
    get [__pageY]() {
      return this.pageY[dartx.round]();
    }
    get [__radiusX]() {
      return this.radiusX[dartx.round]();
    }
    get [__radiusY]() {
      return this.radiusY[dartx.round]();
    }
    get [dartx.client]() {
      return new math.Point(this[__clientX], this[__clientY]);
    }
    get [dartx.page]() {
      return new math.Point(this[__pageX], this[__pageY]);
    }
    get [dartx.screen]() {
      return new math.Point(this[__screenX], this[__screenY]);
    }
    get [dartx.radiusX]() {
      return this[__radiusX];
    }
    get [dartx.radiusY]() {
      return this[__radiusY];
    }
  }
  dart.setSignature(Touch, {
    constructors: () => ({_: [Touch, []]})
  });
  Touch[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('Touch')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("Touch"))];
  dart.registerExtension(dart.global.Touch, Touch);
  const _initTouchEvent = Symbol('_initTouchEvent');
  dart.defineExtensionNames([
    'altKey',
    'changedTouches',
    'ctrlKey',
    'metaKey',
    'shiftKey',
    'targetTouches',
    'touches'
  ]);
  class TouchEvent extends UIEvent {
    static new(touches, targetTouches, changedTouches, type, opts) {
      let view = opts && 'view' in opts ? opts.view : null;
      let screenX = opts && 'screenX' in opts ? opts.screenX : 0;
      let screenY = opts && 'screenY' in opts ? opts.screenY : 0;
      let clientX = opts && 'clientX' in opts ? opts.clientX : 0;
      let clientY = opts && 'clientY' in opts ? opts.clientY : 0;
      let ctrlKey = opts && 'ctrlKey' in opts ? opts.ctrlKey : false;
      let altKey = opts && 'altKey' in opts ? opts.altKey : false;
      let shiftKey = opts && 'shiftKey' in opts ? opts.shiftKey : false;
      let metaKey = opts && 'metaKey' in opts ? opts.metaKey : false;
      if (view == null) {
        view = exports.window;
      }
      let e = exports.document[_createEvent]("TouchEvent");
      dart.dcall(e[_initTouchEvent], touches, targetTouches, changedTouches, type, view, screenX, screenY, clientX, clientY, ctrlKey, altKey, shiftKey, metaKey);
      return dart.as(e, TouchEvent);
    }
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.altKey]() {
      return this.altKey;
    }
    get [dartx.changedTouches]() {
      return this.changedTouches;
    }
    get [dartx.ctrlKey]() {
      return this.ctrlKey;
    }
    get [dartx.metaKey]() {
      return this.metaKey;
    }
    get [dartx.shiftKey]() {
      return this.shiftKey;
    }
    get [dartx.targetTouches]() {
      return this.targetTouches;
    }
    get [dartx.touches]() {
      return this.touches;
    }
    [_initTouchEvent](touches, targetTouches, changedTouches, type, view, unused1, unused2, unused3, unused4, ctrlKey, altKey, shiftKey, metaKey) {
      return this.initTouchEvent(touches, targetTouches, changedTouches, type, view, unused1, unused2, unused3, unused4, ctrlKey, altKey, shiftKey, metaKey);
    }
    static get supported() {
      return html_common.Device.isEventTypeSupported('TouchEvent');
    }
  }
  dart.setSignature(TouchEvent, {
    constructors: () => ({
      new: [TouchEvent, [TouchList, TouchList, TouchList, core.String], {view: Window, screenX: core.int, screenY: core.int, clientX: core.int, clientY: core.int, ctrlKey: core.bool, altKey: core.bool, shiftKey: core.bool, metaKey: core.bool}],
      _: [TouchEvent, []]
    }),
    methods: () => ({[_initTouchEvent]: [dart.void, [TouchList, TouchList, TouchList, core.String, Window, core.int, core.int, core.int, core.int, core.bool, core.bool, core.bool, core.bool]]})
  });
  TouchEvent[dart.metadata] = () => [dart.const(new _metadata.DomName('TouchEvent')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("TouchEvent"))];
  dart.registerExtension(dart.global.TouchEvent, TouchEvent);
  dart.defineExtensionNames([
    'length',
    'get',
    'set',
    'length',
    'first',
    'last',
    'single',
    'elementAt',
    'item'
  ]);
  class TouchList extends dart.mixin(_interceptors.Interceptor, collection.ListMixin$(Touch), ImmutableListMixin$(Touch)) {
    static new() {
      return null;
    }
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static get supported() {
      return !!document.createTouchList;
    }
    get [dartx.length]() {
      return this.length;
    }
    [dartx.get](index) {
      if (index >>> 0 !== index || index >= this[dartx.length]) dart.throw(core.RangeError.index(index, this));
      return dart.as(this[index], Touch);
    }
    [dartx.set](index, value) {
      dart.throw(new core.UnsupportedError("Cannot assign element of immutable List."));
      return value;
    }
    set [dartx.length](value) {
      dart.throw(new core.UnsupportedError("Cannot resize immutable List."));
    }
    get [dartx.first]() {
      if (dart.notNull(this[dartx.length]) > 0) {
        return dart.as(this[0], Touch);
      }
      dart.throw(new core.StateError("No elements"));
    }
    get [dartx.last]() {
      let len = this[dartx.length];
      if (dart.notNull(len) > 0) {
        return dart.as(this[dart.notNull(len) - 1], Touch);
      }
      dart.throw(new core.StateError("No elements"));
    }
    get [dartx.single]() {
      let len = this[dartx.length];
      if (len == 1) {
        return dart.as(this[0], Touch);
      }
      if (len == 0) dart.throw(new core.StateError("No elements"));
      dart.throw(new core.StateError("More than one element"));
    }
    [dartx.elementAt](index) {
      return this[dartx.get](index);
    }
    [dartx.item](index) {
      return this.item(index);
    }
  }
  TouchList[dart.implements] = () => [_js_helper.JavaScriptIndexingBehavior, core.List$(Touch)];
  dart.setSignature(TouchList, {
    constructors: () => ({
      new: [TouchList, []],
      _: [TouchList, []]
    }),
    methods: () => ({
      [dartx.get]: [Touch, [core.int]],
      [dartx.set]: [dart.void, [core.int, Touch]],
      [dartx.elementAt]: [Touch, [core.int]],
      [dartx.item]: [Touch, [core.int]]
    })
  });
  TouchList[dart.metadata] = () => [dart.const(new _metadata.DomName('TouchList')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("TouchList"))];
  dart.registerExtension(dart.global.TouchList, TouchList);
  dart.defineExtensionNames([
    'defaultValue',
    'integrity',
    'kind',
    'label',
    'readyState',
    'src',
    'srclang',
    'track'
  ]);
  class TrackElement extends HtmlElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return dart.as(exports.document[dartx.createElement]("track"), TrackElement);
    }
    created() {
      this[dartx.defaultValue] = null;
      this[dartx.integrity] = null;
      this[dartx.kind] = null;
      this[dartx.label] = null;
      this[dartx.readyState] = null;
      this[dartx.src] = null;
      this[dartx.srclang] = null;
      this[dartx.track] = null;
      super.created();
    }
    static get supported() {
      return Element.isTagSupported('track');
    }
    get [dartx.defaultValue]() {
      return this.default;
    }
    set [dartx.defaultValue](value) {
      this.default = value;
    }
    get [dartx.integrity]() {
      return this.integrity;
    }
    set [dartx.integrity](value) {
      this.integrity = value;
    }
    get [dartx.kind]() {
      return this.kind;
    }
    set [dartx.kind](value) {
      this.kind = value;
    }
    get [dartx.label]() {
      return this.label;
    }
    set [dartx.label](value) {
      this.label = value;
    }
    get [dartx.readyState]() {
      return this.readyState;
    }
    get [dartx.src]() {
      return this.src;
    }
    set [dartx.src](value) {
      this.src = value;
    }
    get [dartx.srclang]() {
      return this.srclang;
    }
    set [dartx.srclang](value) {
      this.srclang = value;
    }
    get [dartx.track]() {
      return this.track;
    }
  }
  dart.defineNamedConstructor(TrackElement, 'created');
  dart.setSignature(TrackElement, {
    constructors: () => ({
      _: [TrackElement, []],
      new: [TrackElement, []],
      created: [TrackElement, []]
    })
  });
  TrackElement[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('HTMLTrackElement')), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.CHROME)), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.IE, '10')), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.SAFARI)), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("HTMLTrackElement"))];
  TrackElement.ERROR = 3;
  TrackElement.LOADED = 2;
  TrackElement.LOADING = 1;
  TrackElement.NONE = 0;
  dart.registerExtension(dart.global.HTMLTrackElement, TrackElement);
  dart.defineExtensionNames([
    'track'
  ]);
  class TrackEvent extends Event {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.track]() {
      return this.track;
    }
  }
  dart.setSignature(TrackEvent, {
    constructors: () => ({_: [TrackEvent, []]})
  });
  TrackEvent[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('TrackEvent')), dart.const(new _metadata.Unstable()), dart.const(new _js_helper.Native("TrackEvent"))];
  dart.registerExtension(dart.global.TrackEvent, TrackEvent);
  dart.defineExtensionNames([
    'elapsedTime',
    'propertyName',
    'pseudoElement'
  ]);
  class TransitionEvent extends Event {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.elapsedTime]() {
      return this.elapsedTime;
    }
    get [dartx.propertyName]() {
      return this.propertyName;
    }
    get [dartx.pseudoElement]() {
      return this.pseudoElement;
    }
  }
  dart.setSignature(TransitionEvent, {
    constructors: () => ({_: [TransitionEvent, []]})
  });
  TransitionEvent[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('TransitionEvent')), dart.const(new _js_helper.Native("TransitionEvent,WebKitTransitionEvent"))];
  dart.registerExtension(dart.global.TransitionEvent, TransitionEvent);
  dart.defineExtensionNames([
    'firstChild',
    'lastChild',
    'nextNode',
    'nextSibling',
    'parentNode',
    'previousNode',
    'previousSibling',
    'currentNode',
    'filter',
    'root',
    'whatToShow'
  ]);
  class TreeWalker extends _interceptors.Interceptor {
    static new(root, whatToShow) {
      return exports.document[_createTreeWalker](root, whatToShow, null);
    }
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.currentNode]() {
      return this.currentNode;
    }
    set [dartx.currentNode](value) {
      this.currentNode = value;
    }
    get [dartx.filter]() {
      return this.filter;
    }
    get [dartx.root]() {
      return this.root;
    }
    get [dartx.whatToShow]() {
      return this.whatToShow;
    }
    [dartx.firstChild]() {
      return this.firstChild();
    }
    [dartx.lastChild]() {
      return this.lastChild();
    }
    [dartx.nextNode]() {
      return this.nextNode();
    }
    [dartx.nextSibling]() {
      return this.nextSibling();
    }
    [dartx.parentNode]() {
      return this.parentNode();
    }
    [dartx.previousNode]() {
      return this.previousNode();
    }
    [dartx.previousSibling]() {
      return this.previousSibling();
    }
  }
  dart.setSignature(TreeWalker, {
    constructors: () => ({
      new: [TreeWalker, [Node, core.int]],
      _: [TreeWalker, []]
    }),
    methods: () => ({
      [dartx.firstChild]: [Node, []],
      [dartx.lastChild]: [Node, []],
      [dartx.nextNode]: [Node, []],
      [dartx.nextSibling]: [Node, []],
      [dartx.parentNode]: [Node, []],
      [dartx.previousNode]: [Node, []],
      [dartx.previousSibling]: [Node, []]
    })
  });
  TreeWalker[dart.metadata] = () => [dart.const(new _metadata.DomName('TreeWalker')), dart.const(new _metadata.Unstable()), dart.const(new _js_helper.Native("TreeWalker"))];
  dart.registerExtension(dart.global.TreeWalker, TreeWalker);
  class UListElement extends HtmlElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return dart.as(exports.document[dartx.createElement]("ul"), UListElement);
    }
    created() {
      super.created();
    }
  }
  dart.defineNamedConstructor(UListElement, 'created');
  dart.setSignature(UListElement, {
    constructors: () => ({
      _: [UListElement, []],
      new: [UListElement, []],
      created: [UListElement, []]
    })
  });
  UListElement[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('HTMLUListElement')), dart.const(new _js_helper.Native("HTMLUListElement"))];
  dart.registerExtension(dart.global.HTMLUListElement, UListElement);
  class UnknownElement extends HtmlElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    created() {
      super.created();
    }
  }
  dart.defineNamedConstructor(UnknownElement, 'created');
  dart.setSignature(UnknownElement, {
    constructors: () => ({
      _: [UnknownElement, []],
      created: [UnknownElement, []]
    })
  });
  UnknownElement[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('HTMLUnknownElement')), dart.const(new _js_helper.Native("HTMLUnknownElement"))];
  dart.registerExtension(dart.global.HTMLUnknownElement, UnknownElement);
  dart.defineExtensionNames([
    'toString',
    'hash',
    'host',
    'hostname',
    'href',
    'origin',
    'password',
    'pathname',
    'port',
    'protocol',
    'search',
    'username'
  ]);
  class Url extends _interceptors.Interceptor {
    static createObjectUrl(blob_OR_source_OR_stream) {
      return (self.URL || self.webkitURL).createObjectURL(blob_OR_source_OR_stream);
    }
    static createObjectUrlFromSource(source) {
      return (self.URL || self.webkitURL).createObjectURL(source);
    }
    static createObjectUrlFromStream(stream) {
      return (self.URL || self.webkitURL).createObjectURL(stream);
    }
    static createObjectUrlFromBlob(blob) {
      return (self.URL || self.webkitURL).createObjectURL(blob);
    }
    static revokeObjectUrl(url) {
      return (self.URL || self.webkitURL).revokeObjectURL(url);
    }
    toString() {
      return String(this);
    }
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.hash]() {
      return this.hash;
    }
    set [dartx.hash](value) {
      this.hash = value;
    }
    get [dartx.host]() {
      return this.host;
    }
    set [dartx.host](value) {
      this.host = value;
    }
    get [dartx.hostname]() {
      return this.hostname;
    }
    set [dartx.hostname](value) {
      this.hostname = value;
    }
    get [dartx.href]() {
      return this.href;
    }
    set [dartx.href](value) {
      this.href = value;
    }
    get [dartx.origin]() {
      return this.origin;
    }
    get [dartx.password]() {
      return this.password;
    }
    set [dartx.password](value) {
      this.password = value;
    }
    get [dartx.pathname]() {
      return this.pathname;
    }
    set [dartx.pathname](value) {
      this.pathname = value;
    }
    get [dartx.port]() {
      return this.port;
    }
    set [dartx.port](value) {
      this.port = value;
    }
    get [dartx.protocol]() {
      return this.protocol;
    }
    set [dartx.protocol](value) {
      this.protocol = value;
    }
    get [dartx.search]() {
      return this.search;
    }
    set [dartx.search](value) {
      this.search = value;
    }
    get [dartx.username]() {
      return this.username;
    }
    set [dartx.username](value) {
      this.username = value;
    }
  }
  Url[dart.implements] = () => [UrlUtils];
  dart.setSignature(Url, {
    constructors: () => ({_: [Url, []]}),
    statics: () => ({
      createObjectUrl: [core.String, [dart.dynamic]],
      createObjectUrlFromSource: [core.String, [MediaSource]],
      createObjectUrlFromStream: [core.String, [MediaStream]],
      createObjectUrlFromBlob: [core.String, [Blob]],
      revokeObjectUrl: [dart.void, [core.String]]
    }),
    names: ['createObjectUrl', 'createObjectUrlFromSource', 'createObjectUrlFromStream', 'createObjectUrlFromBlob', 'revokeObjectUrl']
  });
  Url[dart.metadata] = () => [dart.const(new _metadata.DomName('URL')), dart.const(new _js_helper.Native("URL"))];
  dart.registerExtension(dart.global.URL, Url);
  dart.defineExtensionNames([
    'hash',
    'host',
    'hostname',
    'href',
    'origin',
    'password',
    'pathname',
    'port',
    'protocol',
    'search',
    'username'
  ]);
  class UrlUtils extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.hash]() {
      return this.hash;
    }
    set [dartx.hash](value) {
      this.hash = value;
    }
    get [dartx.host]() {
      return this.host;
    }
    set [dartx.host](value) {
      this.host = value;
    }
    get [dartx.hostname]() {
      return this.hostname;
    }
    set [dartx.hostname](value) {
      this.hostname = value;
    }
    get [dartx.href]() {
      return this.href;
    }
    set [dartx.href](value) {
      this.href = value;
    }
    get [dartx.origin]() {
      return this.origin;
    }
    get [dartx.password]() {
      return this.password;
    }
    set [dartx.password](value) {
      this.password = value;
    }
    get [dartx.pathname]() {
      return this.pathname;
    }
    set [dartx.pathname](value) {
      this.pathname = value;
    }
    get [dartx.port]() {
      return this.port;
    }
    set [dartx.port](value) {
      this.port = value;
    }
    get [dartx.protocol]() {
      return this.protocol;
    }
    set [dartx.protocol](value) {
      this.protocol = value;
    }
    get [dartx.search]() {
      return this.search;
    }
    set [dartx.search](value) {
      this.search = value;
    }
    get [dartx.username]() {
      return this.username;
    }
    set [dartx.username](value) {
      this.username = value;
    }
  }
  dart.setSignature(UrlUtils, {
    constructors: () => ({_: [UrlUtils, []]})
  });
  UrlUtils[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('URLUtils')), dart.const(new _metadata.Experimental())];
  dart.defineExtensionNames([
    'hash',
    'host',
    'hostname',
    'href',
    'origin',
    'pathname',
    'port',
    'protocol',
    'search'
  ]);
  class UrlUtilsReadOnly extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.hash]() {
      return this.hash;
    }
    get [dartx.host]() {
      return this.host;
    }
    get [dartx.hostname]() {
      return this.hostname;
    }
    get [dartx.href]() {
      return this.href;
    }
    get [dartx.origin]() {
      return this.origin;
    }
    get [dartx.pathname]() {
      return this.pathname;
    }
    get [dartx.port]() {
      return this.port;
    }
    get [dartx.protocol]() {
      return this.protocol;
    }
    get [dartx.search]() {
      return this.search;
    }
  }
  dart.setSignature(UrlUtilsReadOnly, {
    constructors: () => ({_: [UrlUtilsReadOnly, []]})
  });
  UrlUtilsReadOnly[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('URLUtilsReadOnly')), dart.const(new _metadata.Experimental())];
  dart.defineExtensionNames([
    'badInput',
    'customError',
    'patternMismatch',
    'rangeOverflow',
    'rangeUnderflow',
    'stepMismatch',
    'tooLong',
    'typeMismatch',
    'valid',
    'valueMissing'
  ]);
  class ValidityState extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.badInput]() {
      return this.badInput;
    }
    get [dartx.customError]() {
      return this.customError;
    }
    get [dartx.patternMismatch]() {
      return this.patternMismatch;
    }
    get [dartx.rangeOverflow]() {
      return this.rangeOverflow;
    }
    get [dartx.rangeUnderflow]() {
      return this.rangeUnderflow;
    }
    get [dartx.stepMismatch]() {
      return this.stepMismatch;
    }
    get [dartx.tooLong]() {
      return this.tooLong;
    }
    get [dartx.typeMismatch]() {
      return this.typeMismatch;
    }
    get [dartx.valid]() {
      return this.valid;
    }
    get [dartx.valueMissing]() {
      return this.valueMissing;
    }
  }
  dart.setSignature(ValidityState, {
    constructors: () => ({_: [ValidityState, []]})
  });
  ValidityState[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('ValidityState')), dart.const(new _js_helper.Native("ValidityState"))];
  dart.registerExtension(dart.global.ValidityState, ValidityState);
  dart.defineExtensionNames([
    'getVideoPlaybackQuality',
    'enterFullscreen',
    'exitFullscreen',
    'height',
    'poster',
    'videoHeight',
    'videoWidth',
    'decodedFrameCount',
    'droppedFrameCount',
    'width'
  ]);
  class VideoElement extends MediaElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return dart.as(exports.document[dartx.createElement]("video"), VideoElement);
    }
    created() {
      this[dartx.height] = null;
      this[dartx.poster] = null;
      this[dartx.videoHeight] = null;
      this[dartx.videoWidth] = null;
      this[dartx.decodedFrameCount] = null;
      this[dartx.droppedFrameCount] = null;
      this[dartx.width] = null;
      super.created();
    }
    get [dartx.height]() {
      return this.height;
    }
    set [dartx.height](value) {
      this.height = value;
    }
    get [dartx.poster]() {
      return this.poster;
    }
    set [dartx.poster](value) {
      this.poster = value;
    }
    get [dartx.videoHeight]() {
      return this.videoHeight;
    }
    get [dartx.videoWidth]() {
      return this.videoWidth;
    }
    get [dartx.decodedFrameCount]() {
      return this.webkitDecodedFrameCount;
    }
    get [dartx.droppedFrameCount]() {
      return this.webkitDroppedFrameCount;
    }
    get [dartx.width]() {
      return this.width;
    }
    set [dartx.width](value) {
      this.width = value;
    }
    [dartx.getVideoPlaybackQuality]() {
      return this.getVideoPlaybackQuality();
    }
    [dartx.enterFullscreen]() {
      return this.webkitEnterFullscreen();
    }
    [dartx.exitFullscreen]() {
      return this.webkitExitFullscreen();
    }
  }
  VideoElement[dart.implements] = () => [CanvasImageSource];
  dart.defineNamedConstructor(VideoElement, 'created');
  dart.setSignature(VideoElement, {
    constructors: () => ({
      _: [VideoElement, []],
      new: [VideoElement, []],
      created: [VideoElement, []]
    }),
    methods: () => ({
      [dartx.getVideoPlaybackQuality]: [VideoPlaybackQuality, []],
      [dartx.enterFullscreen]: [dart.void, []],
      [dartx.exitFullscreen]: [dart.void, []]
    })
  });
  VideoElement[dart.metadata] = () => [dart.const(new _metadata.DomName('HTMLVideoElement')), dart.const(new _js_helper.Native("HTMLVideoElement"))];
  dart.registerExtension(dart.global.HTMLVideoElement, VideoElement);
  dart.defineExtensionNames([
    'corruptedVideoFrames',
    'creationTime',
    'droppedVideoFrames',
    'totalVideoFrames'
  ]);
  class VideoPlaybackQuality extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.corruptedVideoFrames]() {
      return this.corruptedVideoFrames;
    }
    get [dartx.creationTime]() {
      return this.creationTime;
    }
    get [dartx.droppedVideoFrames]() {
      return this.droppedVideoFrames;
    }
    get [dartx.totalVideoFrames]() {
      return this.totalVideoFrames;
    }
  }
  dart.setSignature(VideoPlaybackQuality, {
    constructors: () => ({_: [VideoPlaybackQuality, []]})
  });
  VideoPlaybackQuality[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('VideoPlaybackQuality')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("VideoPlaybackQuality"))];
  dart.registerExtension(dart.global.VideoPlaybackQuality, VideoPlaybackQuality);
  dart.defineExtensionNames([
    'id',
    'kind',
    'label',
    'language',
    'selected'
  ]);
  class VideoTrack extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.id]() {
      return this.id;
    }
    get [dartx.kind]() {
      return this.kind;
    }
    get [dartx.label]() {
      return this.label;
    }
    get [dartx.language]() {
      return this.language;
    }
    get [dartx.selected]() {
      return this.selected;
    }
    set [dartx.selected](value) {
      this.selected = value;
    }
  }
  dart.setSignature(VideoTrack, {
    constructors: () => ({_: [VideoTrack, []]})
  });
  VideoTrack[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('VideoTrack')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("VideoTrack"))];
  dart.registerExtension(dart.global.VideoTrack, VideoTrack);
  dart.defineExtensionNames([
    'getTrackById',
    'onChange',
    'length',
    'selectedIndex'
  ]);
  class VideoTrackList extends EventTarget {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.length]() {
      return this.length;
    }
    get [dartx.selectedIndex]() {
      return this.selectedIndex;
    }
    [__getter__](index) {
      return this.__getter__(index);
    }
    [dartx.getTrackById](id) {
      return this.getTrackById(id);
    }
    get [dartx.onChange]() {
      return VideoTrackList.changeEvent.forTarget(this);
    }
  }
  dart.setSignature(VideoTrackList, {
    constructors: () => ({_: [VideoTrackList, []]}),
    methods: () => ({
      [__getter__]: [VideoTrack, [core.int]],
      [dartx.getTrackById]: [VideoTrack, [core.String]]
    })
  });
  VideoTrackList[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('VideoTrackList')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("VideoTrackList"))];
  dart.defineLazyProperties(VideoTrackList, {
    get changeEvent() {
      return dart.const(new (EventStreamProvider$(Event))('change'));
    }
  });
  dart.registerExtension(dart.global.VideoTrackList, VideoTrackList);
  const VoidCallback = dart.typedef('VoidCallback', () => dart.functionType(dart.void, []));
  dart.defineExtensionNames([
    'getCueAsHtml',
    'align',
    'line',
    'position',
    'regionId',
    'size',
    'snapToLines',
    'text',
    'vertical'
  ]);
  class VttCue extends TextTrackCue {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new(startTime, endTime, text) {
      return VttCue._create_1(startTime, endTime, text);
    }
    static _create_1(startTime, endTime, text) {
      return dart.as(new VTTCue(startTime, endTime, text), VttCue);
    }
    get [dartx.align]() {
      return this.align;
    }
    set [dartx.align](value) {
      this.align = value;
    }
    get [dartx.line]() {
      return this.line;
    }
    set [dartx.line](value) {
      this.line = value;
    }
    get [dartx.position]() {
      return this.position;
    }
    set [dartx.position](value) {
      this.position = value;
    }
    get [dartx.regionId]() {
      return this.regionId;
    }
    set [dartx.regionId](value) {
      this.regionId = value;
    }
    get [dartx.size]() {
      return this.size;
    }
    set [dartx.size](value) {
      this.size = value;
    }
    get [dartx.snapToLines]() {
      return this.snapToLines;
    }
    set [dartx.snapToLines](value) {
      this.snapToLines = value;
    }
    get [dartx.text]() {
      return this.text;
    }
    set [dartx.text](value) {
      this.text = value;
    }
    get [dartx.vertical]() {
      return this.vertical;
    }
    set [dartx.vertical](value) {
      this.vertical = value;
    }
    [dartx.getCueAsHtml]() {
      return this.getCueAsHTML();
    }
  }
  dart.setSignature(VttCue, {
    constructors: () => ({
      _: [VttCue, []],
      new: [VttCue, [core.num, core.num, core.String]]
    }),
    methods: () => ({[dartx.getCueAsHtml]: [DocumentFragment, []]}),
    statics: () => ({_create_1: [VttCue, [dart.dynamic, dart.dynamic, dart.dynamic]]}),
    names: ['_create_1']
  });
  VttCue[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('VTTCue')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("VTTCue"))];
  dart.registerExtension(dart.global.VTTCue, VttCue);
  dart.defineExtensionNames([
    'height',
    'id',
    'regionAnchorX',
    'regionAnchorY',
    'scroll',
    'track',
    'viewportAnchorX',
    'viewportAnchorY',
    'width'
  ]);
  class VttRegion extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return VttRegion._create_1();
    }
    static _create_1() {
      return dart.as(new VTTRegion(), VttRegion);
    }
    get [dartx.height]() {
      return this.height;
    }
    set [dartx.height](value) {
      this.height = value;
    }
    get [dartx.id]() {
      return this.id;
    }
    set [dartx.id](value) {
      this.id = value;
    }
    get [dartx.regionAnchorX]() {
      return this.regionAnchorX;
    }
    set [dartx.regionAnchorX](value) {
      this.regionAnchorX = value;
    }
    get [dartx.regionAnchorY]() {
      return this.regionAnchorY;
    }
    set [dartx.regionAnchorY](value) {
      this.regionAnchorY = value;
    }
    get [dartx.scroll]() {
      return this.scroll;
    }
    set [dartx.scroll](value) {
      this.scroll = value;
    }
    get [dartx.track]() {
      return this.track;
    }
    get [dartx.viewportAnchorX]() {
      return this.viewportAnchorX;
    }
    set [dartx.viewportAnchorX](value) {
      this.viewportAnchorX = value;
    }
    get [dartx.viewportAnchorY]() {
      return this.viewportAnchorY;
    }
    set [dartx.viewportAnchorY](value) {
      this.viewportAnchorY = value;
    }
    get [dartx.width]() {
      return this.width;
    }
    set [dartx.width](value) {
      this.width = value;
    }
  }
  dart.setSignature(VttRegion, {
    constructors: () => ({
      _: [VttRegion, []],
      new: [VttRegion, []]
    }),
    statics: () => ({_create_1: [VttRegion, []]}),
    names: ['_create_1']
  });
  VttRegion[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('VTTRegion')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("VTTRegion"))];
  dart.registerExtension(dart.global.VTTRegion, VttRegion);
  dart.defineExtensionNames([
    'getRegionById',
    'item',
    'length'
  ]);
  class VttRegionList extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.length]() {
      return this.length;
    }
    [dartx.getRegionById](id) {
      return this.getRegionById(id);
    }
    [dartx.item](index) {
      return this.item(index);
    }
  }
  dart.setSignature(VttRegionList, {
    constructors: () => ({_: [VttRegionList, []]}),
    methods: () => ({
      [dartx.getRegionById]: [VttRegion, [core.String]],
      [dartx.item]: [VttRegion, [core.int]]
    })
  });
  VttRegionList[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('VTTRegionList')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("VTTRegionList"))];
  dart.registerExtension(dart.global.VTTRegionList, VttRegionList);
  dart.defineExtensionNames([
    'close',
    'send',
    'sendBlob',
    'sendByteBuffer',
    'sendString',
    'sendTypedData',
    'onClose',
    'onError',
    'onMessage',
    'onOpen',
    'binaryType',
    'bufferedAmount',
    'extensions',
    'protocol',
    'readyState',
    'url'
  ]);
  class WebSocket extends EventTarget {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new(url, protocol_OR_protocols) {
      if (protocol_OR_protocols === void 0) protocol_OR_protocols = null;
      if ((typeof url == 'string' || url == null) && protocol_OR_protocols == null) {
        return WebSocket._create_1(url);
      }
      if ((typeof protocol_OR_protocols == 'string' || protocol_OR_protocols == null) && (typeof url == 'string' || url == null)) {
        return WebSocket._create_2(url, protocol_OR_protocols);
      }
      if ((dart.is(protocol_OR_protocols, core.List$(core.String)) || protocol_OR_protocols == null) && (typeof url == 'string' || url == null)) {
        let protocols_1 = html_common.convertDartToNative_StringArray(dart.as(protocol_OR_protocols, core.List$(core.String)));
        return WebSocket._create_3(url, protocols_1);
      }
      dart.throw(new core.ArgumentError("Incorrect number or type of arguments"));
    }
    static _create_1(url) {
      return dart.as(new WebSocket(url), WebSocket);
    }
    static _create_2(url, protocol_OR_protocols) {
      return dart.as(new WebSocket(url, protocol_OR_protocols), WebSocket);
    }
    static _create_3(url, protocol_OR_protocols) {
      return dart.as(new WebSocket(url, protocol_OR_protocols), WebSocket);
    }
    static get supported() {
      return typeof window.WebSocket != "undefined";
    }
    get [dartx.binaryType]() {
      return this.binaryType;
    }
    set [dartx.binaryType](value) {
      this.binaryType = value;
    }
    get [dartx.bufferedAmount]() {
      return this.bufferedAmount;
    }
    get [dartx.extensions]() {
      return this.extensions;
    }
    get [dartx.protocol]() {
      return this.protocol;
    }
    get [dartx.readyState]() {
      return this.readyState;
    }
    get [dartx.url]() {
      return this.url;
    }
    [dartx.close](code, reason) {
      return this.close(code, reason);
    }
    [dartx.send](data) {
      return this.send(data);
    }
    [dartx.sendBlob](data) {
      return this.send(data);
    }
    [dartx.sendByteBuffer](data) {
      return this.send(data);
    }
    [dartx.sendString](data) {
      return this.send(data);
    }
    [dartx.sendTypedData](data) {
      return this.send(data);
    }
    get [dartx.onClose]() {
      return WebSocket.closeEvent.forTarget(this);
    }
    get [dartx.onError]() {
      return WebSocket.errorEvent.forTarget(this);
    }
    get [dartx.onMessage]() {
      return WebSocket.messageEvent.forTarget(this);
    }
    get [dartx.onOpen]() {
      return WebSocket.openEvent.forTarget(this);
    }
  }
  dart.setSignature(WebSocket, {
    constructors: () => ({
      _: [WebSocket, []],
      new: [WebSocket, [core.String], [dart.dynamic]]
    }),
    methods: () => ({
      [dartx.close]: [dart.void, [], [core.int, core.String]],
      [dartx.send]: [dart.void, [dart.dynamic]],
      [dartx.sendBlob]: [dart.void, [Blob]],
      [dartx.sendByteBuffer]: [dart.void, [typed_data.ByteBuffer]],
      [dartx.sendString]: [dart.void, [core.String]],
      [dartx.sendTypedData]: [dart.void, [typed_data.TypedData]]
    }),
    statics: () => ({
      _create_1: [WebSocket, [dart.dynamic]],
      _create_2: [WebSocket, [dart.dynamic, dart.dynamic]],
      _create_3: [WebSocket, [dart.dynamic, dart.dynamic]]
    }),
    names: ['_create_1', '_create_2', '_create_3']
  });
  WebSocket[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('WebSocket')), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.CHROME)), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.FIREFOX)), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.IE, '10')), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.SAFARI)), dart.const(new _metadata.Unstable()), dart.const(new _js_helper.Native("WebSocket"))];
  WebSocket.CLOSED = 3;
  WebSocket.CLOSING = 2;
  WebSocket.CONNECTING = 0;
  WebSocket.OPEN = 1;
  dart.defineLazyProperties(WebSocket, {
    get closeEvent() {
      return dart.const(new (EventStreamProvider$(CloseEvent))('close'));
    },
    get errorEvent() {
      return dart.const(new (EventStreamProvider$(Event))('error'));
    },
    get messageEvent() {
      return dart.const(new (EventStreamProvider$(MessageEvent))('message'));
    },
    get openEvent() {
      return dart.const(new (EventStreamProvider$(Event))('open'));
    }
  });
  dart.registerExtension(dart.global.WebSocket, WebSocket);
  const _deltaX = Symbol('_deltaX');
  const _deltaY = Symbol('_deltaY');
  const _wheelDelta = Symbol('_wheelDelta');
  const _wheelDeltaX = Symbol('_wheelDeltaX');
  const _hasInitMouseScrollEvent = Symbol('_hasInitMouseScrollEvent');
  const _initMouseScrollEvent = Symbol('_initMouseScrollEvent');
  const _hasInitWheelEvent = Symbol('_hasInitWheelEvent');
  const _initWheelEvent = Symbol('_initWheelEvent');
  dart.defineExtensionNames([
    'deltaY',
    'deltaX',
    'deltaMode',
    'deltaZ'
  ]);
  class WheelEvent extends MouseEvent {
    static new(type, opts) {
      let view = opts && 'view' in opts ? opts.view : null;
      let deltaX = opts && 'deltaX' in opts ? opts.deltaX : 0;
      let deltaY = opts && 'deltaY' in opts ? opts.deltaY : 0;
      let deltaZ = opts && 'deltaZ' in opts ? opts.deltaZ : 0;
      let deltaMode = opts && 'deltaMode' in opts ? opts.deltaMode : 0;
      let detail = opts && 'detail' in opts ? opts.detail : 0;
      let screenX = opts && 'screenX' in opts ? opts.screenX : 0;
      let screenY = opts && 'screenY' in opts ? opts.screenY : 0;
      let clientX = opts && 'clientX' in opts ? opts.clientX : 0;
      let clientY = opts && 'clientY' in opts ? opts.clientY : 0;
      let button = opts && 'button' in opts ? opts.button : 0;
      let canBubble = opts && 'canBubble' in opts ? opts.canBubble : true;
      let cancelable = opts && 'cancelable' in opts ? opts.cancelable : true;
      let ctrlKey = opts && 'ctrlKey' in opts ? opts.ctrlKey : false;
      let altKey = opts && 'altKey' in opts ? opts.altKey : false;
      let shiftKey = opts && 'shiftKey' in opts ? opts.shiftKey : false;
      let metaKey = opts && 'metaKey' in opts ? opts.metaKey : false;
      let relatedTarget = opts && 'relatedTarget' in opts ? opts.relatedTarget : null;
      let options = dart.map({view: view, deltaMode: deltaMode, deltaX: deltaX, deltaY: deltaY, deltaZ: deltaZ, detail: detail, screenX: screenX, screenY: screenY, clientX: clientX, clientY: clientY, button: button, bubbles: canBubble, cancelable: cancelable, ctrlKey: ctrlKey, altKey: altKey, shiftKey: shiftKey, metaKey: metaKey, relatedTarget: relatedTarget});
      if (view == null) {
        view = exports.window;
      }
      return dart.as(new WheelEvent(type, html_common.convertDartToNative_Dictionary(options)), WheelEvent);
    }
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [_deltaX]() {
      return this.deltaX;
    }
    get [_deltaY]() {
      return this.deltaY;
    }
    get [dartx.deltaZ]() {
      return this.deltaZ;
    }
    get [dartx.deltaY]() {
      if (this.deltaY !== undefined) {
        return this[_deltaY];
      }
      dart.throw(new core.UnsupportedError('deltaY is not supported'));
    }
    get [dartx.deltaX]() {
      if (this.deltaX !== undefined) {
        return this[_deltaX];
      }
      dart.throw(new core.UnsupportedError('deltaX is not supported'));
    }
    get [dartx.deltaMode]() {
      if (!!this.deltaMode) {
        return this.deltaMode;
      }
      return 0;
    }
    get [_wheelDelta]() {
      return this.wheelDelta;
    }
    get [_wheelDeltaX]() {
      return this.wheelDeltaX;
    }
    get [_detail]() {
      return this.detail;
    }
    get [_hasInitMouseScrollEvent]() {
      return !!this.initMouseScrollEvent;
    }
    [_initMouseScrollEvent](type, canBubble, cancelable, view, detail, screenX, screenY, clientX, clientY, ctrlKey, altKey, shiftKey, metaKey, button, relatedTarget, axis) {
      return this.initMouseScrollEvent(type, canBubble, cancelable, view, detail, screenX, screenY, clientX, clientY, ctrlKey, altKey, shiftKey, metaKey, button, relatedTarget, axis);
    }
    get [_hasInitWheelEvent]() {
      return !!this.initWheelEvent;
    }
    [_initWheelEvent](eventType, canBubble, cancelable, view, detail, screenX, screenY, clientX, clientY, button, relatedTarget, modifiersList, deltaX, deltaY, deltaZ, deltaMode) {
      return this.initWheelEvent(eventType, canBubble, cancelable, view, detail, screenX, screenY, clientX, clientY, button, relatedTarget, modifiersList, deltaX, deltaY, deltaZ, deltaMode);
    }
  }
  dart.setSignature(WheelEvent, {
    constructors: () => ({
      new: [WheelEvent, [core.String], {view: Window, deltaX: core.num, deltaY: core.num, deltaZ: core.num, deltaMode: core.int, detail: core.int, screenX: core.int, screenY: core.int, clientX: core.int, clientY: core.int, button: core.int, canBubble: core.bool, cancelable: core.bool, ctrlKey: core.bool, altKey: core.bool, shiftKey: core.bool, metaKey: core.bool, relatedTarget: EventTarget}],
      _: [WheelEvent, []]
    }),
    methods: () => ({
      [_initMouseScrollEvent]: [dart.void, [core.String, core.bool, core.bool, Window, core.int, core.int, core.int, core.int, core.int, core.bool, core.bool, core.bool, core.bool, core.int, EventTarget, core.int]],
      [_initWheelEvent]: [dart.void, [core.String, core.bool, core.bool, Window, core.int, core.int, core.int, core.int, core.int, core.int, EventTarget, core.String, core.int, core.int, core.int, core.int]]
    })
  });
  WheelEvent[dart.metadata] = () => [dart.const(new _metadata.DomName('WheelEvent')), dart.const(new _js_helper.Native("WheelEvent"))];
  WheelEvent.DOM_DELTA_LINE = 1;
  WheelEvent.DOM_DELTA_PAGE = 2;
  WheelEvent.DOM_DELTA_PIXEL = 0;
  dart.registerExtension(dart.global.WheelEvent, WheelEvent);
  const _open2 = Symbol('_open2');
  const _open3 = Symbol('_open3');
  const _location = Symbol('_location');
  const _ensureRequestAnimationFrame = Symbol('_ensureRequestAnimationFrame');
  const _requestAnimationFrame = Symbol('_requestAnimationFrame');
  const _cancelAnimationFrame = Symbol('_cancelAnimationFrame');
  const _requestFileSystem = Symbol('_requestFileSystem');
  const _get_opener = Symbol('_get_opener');
  const _pageXOffset = Symbol('_pageXOffset');
  const _pageYOffset = Symbol('_pageYOffset');
  const _get_parent = Symbol('_get_parent');
  const _get_self = Symbol('_get_self');
  const _get_top = Symbol('_get_top');
  const __getter___1 = Symbol('__getter___1');
  const __getter___2 = Symbol('__getter___2');
  const _scroll_1 = Symbol('_scroll_1');
  const _scroll_2 = Symbol('_scroll_2');
  const _scroll_3 = Symbol('_scroll_3');
  const _scroll_4 = Symbol('_scroll_4');
  const _scrollBy_1 = Symbol('_scrollBy_1');
  const _scrollBy_2 = Symbol('_scrollBy_2');
  const _scrollBy_3 = Symbol('_scrollBy_3');
  const _scrollBy_4 = Symbol('_scrollBy_4');
  const _scrollTo_1 = Symbol('_scrollTo_1');
  const _scrollTo_2 = Symbol('_scrollTo_2');
  const _scrollTo_3 = Symbol('_scrollTo_3');
  const _scrollTo_4 = Symbol('_scrollTo_4');
  const __requestFileSystem = Symbol('__requestFileSystem');
  const _resolveLocalFileSystemUrl = Symbol('_resolveLocalFileSystemUrl');
  dart.defineExtensionNames([
    'animationFrame',
    'document',
    'open',
    'location',
    'location',
    'requestAnimationFrame',
    'cancelAnimationFrame',
    'indexedDB',
    'console',
    'requestFileSystem',
    'opener',
    'opener',
    'parent',
    'self',
    'top',
    'window',
    'alert',
    'close',
    'confirm',
    'find',
    'getMatchedCssRules',
    'getSelection',
    'matchMedia',
    'moveBy',
    'openDatabase',
    'postMessage',
    'print',
    'resizeBy',
    'resizeTo',
    'scroll',
    'scrollBy',
    'scrollTo',
    'showModalDialog',
    'stop',
    'resolveLocalFileSystemUrl',
    'atob',
    'btoa',
    'onContentLoaded',
    'onAbort',
    'onBlur',
    'onCanPlay',
    'onCanPlayThrough',
    'onChange',
    'onClick',
    'onContextMenu',
    'onDoubleClick',
    'onDeviceMotion',
    'onDeviceOrientation',
    'onDrag',
    'onDragEnd',
    'onDragEnter',
    'onDragLeave',
    'onDragOver',
    'onDragStart',
    'onDrop',
    'onDurationChange',
    'onEmptied',
    'onEnded',
    'onError',
    'onFocus',
    'onHashChange',
    'onInput',
    'onInvalid',
    'onKeyDown',
    'onKeyPress',
    'onKeyUp',
    'onLoad',
    'onLoadedData',
    'onLoadedMetadata',
    'onLoadStart',
    'onMessage',
    'onMouseDown',
    'onMouseEnter',
    'onMouseLeave',
    'onMouseMove',
    'onMouseOut',
    'onMouseOver',
    'onMouseUp',
    'onMouseWheel',
    'onOffline',
    'onOnline',
    'onPageHide',
    'onPageShow',
    'onPause',
    'onPlay',
    'onPlaying',
    'onPopState',
    'onProgress',
    'onRateChange',
    'onReset',
    'onResize',
    'onScroll',
    'onSearch',
    'onSeeked',
    'onSeeking',
    'onSelect',
    'onStalled',
    'onStorage',
    'onSubmit',
    'onSuspend',
    'onTimeUpdate',
    'onTouchCancel',
    'onTouchEnd',
    'onTouchMove',
    'onTouchStart',
    'onTransitionEnd',
    'onUnload',
    'onVolumeChange',
    'onWaiting',
    'onAnimationEnd',
    'onAnimationIteration',
    'onAnimationStart',
    'onBeforeUnload',
    'moveTo',
    'pageXOffset',
    'pageYOffset',
    'scrollX',
    'scrollY',
    'css',
    'applicationCache',
    'closed',
    'crypto',
    'defaultStatus',
    'defaultstatus',
    'devicePixelRatio',
    'history',
    'innerHeight',
    'innerWidth',
    'localStorage',
    'locationbar',
    'menubar',
    'name',
    'navigator',
    'offscreenBuffering',
    'orientation',
    'outerHeight',
    'outerWidth',
    'performance',
    'screen',
    'screenLeft',
    'screenTop',
    'screenX',
    'screenY',
    'scrollbars',
    'sessionStorage',
    'speechSynthesis',
    'status',
    'statusbar',
    'styleMedia',
    'toolbar'
  ]);
  class Window extends EventTarget {
    get [dartx.animationFrame]() {
      let completer = async.Completer$(core.num).sync();
      this[dartx.requestAnimationFrame](dart.fn(time => {
        completer.complete(time);
      }, dart.void, [core.num]));
      return completer.future;
    }
    get [dartx.document]() {
      return dart.as(this.document, Document);
    }
    [_open2](url, name) {
      return dart.as(this.open(url, name), WindowBase);
    }
    [_open3](url, name, options) {
      return dart.as(this.open(url, name, options), WindowBase);
    }
    [dartx.open](url, name, options) {
      if (options === void 0) options = null;
      if (options == null) {
        return _DOMWindowCrossFrame._createSafe(this[_open2](url, name));
      } else {
        return _DOMWindowCrossFrame._createSafe(this[_open3](url, name, options));
      }
    }
    get [dartx.location]() {
      return dart.as(this[_location], Location);
    }
    set [dartx.location](value) {
      this[_location] = value;
    }
    get [_location]() {
      return this.location;
    }
    set [_location](value) {
      this.location = value;
    }
    [dartx.requestAnimationFrame](callback) {
      this[_ensureRequestAnimationFrame]();
      return this[_requestAnimationFrame](dart.as(_wrapZone(callback), RequestAnimationFrameCallback));
    }
    [dartx.cancelAnimationFrame](id) {
      this[_ensureRequestAnimationFrame]();
      this[_cancelAnimationFrame](id);
    }
    [_requestAnimationFrame](callback) {
      return this.requestAnimationFrame(callback);
    }
    [_cancelAnimationFrame](id) {
      return this.cancelAnimationFrame(id);
    }
    [_ensureRequestAnimationFrame]() {
      if (!!(this.requestAnimationFrame && this.cancelAnimationFrame)) return;
      (function($this) {
        var vendors = ['ms', 'moz', 'webkit', 'o'];
        for (var i = 0; i < vendors.length && !$this.requestAnimationFrame; ++i) {
          $this.requestAnimationFrame = $this[vendors[i] + 'RequestAnimationFrame'];
          $this.cancelAnimationFrame = $this[vendors[i] + 'CancelAnimationFrame'] || $this[vendors[i] + 'CancelRequestAnimationFrame'];
        }
        if ($this.requestAnimationFrame && $this.cancelAnimationFrame) return;
        $this.requestAnimationFrame = function(callback) {
          return window.setTimeout(function() {
            callback(Date.now());
          }, 16);
        };
        $this.cancelAnimationFrame = function(id) {
          clearTimeout(id);
        };
      })(this);
    }
    get [dartx.indexedDB]() {
      return dart.as(this.indexedDB || this.webkitIndexedDB || this.mozIndexedDB, indexed_db.IdbFactory);
    }
    get [dartx.console]() {
      return Console._safeConsole;
    }
    [dartx.requestFileSystem](size, opts) {
      let persistent = opts && 'persistent' in opts ? opts.persistent : false;
      return this[_requestFileSystem](dart.notNull(persistent) ? 1 : 0, size);
    }
    static get supportsPointConversions() {
      return DomPoint.supported;
    }
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.css]() {
      return this.CSS;
    }
    get [dartx.applicationCache]() {
      return this.applicationCache;
    }
    get [dartx.closed]() {
      return this.closed;
    }
    get [dartx.crypto]() {
      return this.crypto;
    }
    get [dartx.defaultStatus]() {
      return this.defaultStatus;
    }
    set [dartx.defaultStatus](value) {
      this.defaultStatus = value;
    }
    get [dartx.defaultstatus]() {
      return this.defaultstatus;
    }
    set [dartx.defaultstatus](value) {
      this.defaultstatus = value;
    }
    get [dartx.devicePixelRatio]() {
      return this.devicePixelRatio;
    }
    get [dartx.history]() {
      return this.history;
    }
    get [dartx.innerHeight]() {
      return this.innerHeight;
    }
    get [dartx.innerWidth]() {
      return this.innerWidth;
    }
    get [dartx.localStorage]() {
      return this.localStorage;
    }
    get [dartx.locationbar]() {
      return this.locationbar;
    }
    get [dartx.menubar]() {
      return this.menubar;
    }
    get [dartx.name]() {
      return this.name;
    }
    set [dartx.name](value) {
      this.name = value;
    }
    get [dartx.navigator]() {
      return this.navigator;
    }
    get [dartx.offscreenBuffering]() {
      return this.offscreenBuffering;
    }
    get [dartx.opener]() {
      return _convertNativeToDart_Window(this[_get_opener]);
    }
    get [_get_opener]() {
      return this.opener;
    }
    set [dartx.opener](value) {
      this.opener = value;
    }
    get [dartx.orientation]() {
      return this.orientation;
    }
    get [dartx.outerHeight]() {
      return this.outerHeight;
    }
    get [dartx.outerWidth]() {
      return this.outerWidth;
    }
    get [_pageXOffset]() {
      return this.pageXOffset;
    }
    get [_pageYOffset]() {
      return this.pageYOffset;
    }
    get [dartx.parent]() {
      return _convertNativeToDart_Window(this[_get_parent]);
    }
    get [_get_parent]() {
      return this.parent;
    }
    get [dartx.performance]() {
      return this.performance;
    }
    get [dartx.screen]() {
      return this.screen;
    }
    get [dartx.screenLeft]() {
      return this.screenLeft;
    }
    get [dartx.screenTop]() {
      return this.screenTop;
    }
    get [dartx.screenX]() {
      return this.screenX;
    }
    get [dartx.screenY]() {
      return this.screenY;
    }
    get [dartx.scrollbars]() {
      return this.scrollbars;
    }
    get [dartx.self]() {
      return _convertNativeToDart_Window(this[_get_self]);
    }
    get [_get_self]() {
      return this.self;
    }
    get [dartx.sessionStorage]() {
      return this.sessionStorage;
    }
    get [dartx.speechSynthesis]() {
      return this.speechSynthesis;
    }
    get [dartx.status]() {
      return this.status;
    }
    set [dartx.status](value) {
      this.status = value;
    }
    get [dartx.statusbar]() {
      return this.statusbar;
    }
    get [dartx.styleMedia]() {
      return this.styleMedia;
    }
    get [dartx.toolbar]() {
      return this.toolbar;
    }
    get [dartx.top]() {
      return _convertNativeToDart_Window(this[_get_top]);
    }
    get [_get_top]() {
      return this.top;
    }
    get [dartx.window]() {
      return _convertNativeToDart_Window(this[_get_window]);
    }
    get [_get_window]() {
      return this.window;
    }
    [__getter__](index_OR_name) {
      if (typeof index_OR_name == 'number') {
        return _convertNativeToDart_Window(this[__getter___1](index_OR_name));
      }
      if (typeof index_OR_name == 'string') {
        return _convertNativeToDart_Window(this[__getter___2](index_OR_name));
      }
      dart.throw(new core.ArgumentError("Incorrect number or type of arguments"));
    }
    [__getter___1](index) {
      return this.__getter__(index);
    }
    [__getter___2](name) {
      return this.__getter__(name);
    }
    [dartx.alert](message) {
      return this.alert(message);
    }
    [dartx.close]() {
      return this.close();
    }
    [dartx.confirm](message) {
      return this.confirm(message);
    }
    [dartx.find](string, caseSensitive, backwards, wrap, wholeWord, searchInFrames, showDialog) {
      return this.find(string, caseSensitive, backwards, wrap, wholeWord, searchInFrames, showDialog);
    }
    [_getComputedStyle](element, pseudoElement) {
      return this.getComputedStyle(element, pseudoElement);
    }
    [dartx.getMatchedCssRules](element, pseudoElement) {
      return this.getMatchedCSSRules(element, pseudoElement);
    }
    [dartx.getSelection]() {
      return this.getSelection();
    }
    [dartx.matchMedia](query) {
      return this.matchMedia(query);
    }
    [dartx.moveBy](x, y) {
      return this.moveBy(x, y);
    }
    [_moveTo](x, y) {
      return this.moveTo(x, y);
    }
    [dartx.openDatabase](name, version, displayName, estimatedSize, creationCallback) {
      return this.openDatabase(name, version, displayName, estimatedSize, creationCallback);
    }
    [dartx.postMessage](message, targetOrigin, transfer) {
      if (transfer === void 0) transfer = null;
      if (transfer != null) {
        let message_1 = html_common.convertDartToNative_SerializedScriptValue(message);
        this[_postMessage_1](message_1, targetOrigin, transfer);
        return;
      }
      let message_1 = html_common.convertDartToNative_SerializedScriptValue(message);
      this[_postMessage_2](message_1, targetOrigin);
      return;
    }
    [_postMessage_1](message, targetOrigin, transfer) {
      return this.postMessage(message, targetOrigin, transfer);
    }
    [_postMessage_2](message, targetOrigin) {
      return this.postMessage(message, targetOrigin);
    }
    [dartx.print]() {
      return this.print();
    }
    [dartx.resizeBy](x, y) {
      return this.resizeBy(x, y);
    }
    [dartx.resizeTo](width, height) {
      return this.resizeTo(width, height);
    }
    [dartx.scroll](x, y, scrollOptions) {
      if (scrollOptions === void 0) scrollOptions = null;
      if (typeof y == 'number' && typeof x == 'number' && scrollOptions == null) {
        this[_scroll_1](x, y);
        return;
      }
      if (scrollOptions != null && typeof y == 'number' && typeof x == 'number') {
        let scrollOptions_1 = html_common.convertDartToNative_Dictionary(scrollOptions);
        this[_scroll_2](x, y, scrollOptions_1);
        return;
      }
      if (typeof y == 'number' && typeof x == 'number' && scrollOptions == null) {
        this[_scroll_3](x, y);
        return;
      }
      if (scrollOptions != null && typeof y == 'number' && typeof x == 'number') {
        let scrollOptions_1 = html_common.convertDartToNative_Dictionary(scrollOptions);
        this[_scroll_4](x, y, scrollOptions_1);
        return;
      }
      dart.throw(new core.ArgumentError("Incorrect number or type of arguments"));
    }
    [_scroll_1](x, y) {
      return this.scroll(x, y);
    }
    [_scroll_2](x, y, scrollOptions) {
      return this.scroll(x, y, scrollOptions);
    }
    [_scroll_3](x, y) {
      return this.scroll(x, y);
    }
    [_scroll_4](x, y, scrollOptions) {
      return this.scroll(x, y, scrollOptions);
    }
    [dartx.scrollBy](x, y, scrollOptions) {
      if (scrollOptions === void 0) scrollOptions = null;
      if (typeof y == 'number' && typeof x == 'number' && scrollOptions == null) {
        this[_scrollBy_1](x, y);
        return;
      }
      if (scrollOptions != null && typeof y == 'number' && typeof x == 'number') {
        let scrollOptions_1 = html_common.convertDartToNative_Dictionary(scrollOptions);
        this[_scrollBy_2](x, y, scrollOptions_1);
        return;
      }
      if (typeof y == 'number' && typeof x == 'number' && scrollOptions == null) {
        this[_scrollBy_3](x, y);
        return;
      }
      if (scrollOptions != null && typeof y == 'number' && typeof x == 'number') {
        let scrollOptions_1 = html_common.convertDartToNative_Dictionary(scrollOptions);
        this[_scrollBy_4](x, y, scrollOptions_1);
        return;
      }
      dart.throw(new core.ArgumentError("Incorrect number or type of arguments"));
    }
    [_scrollBy_1](x, y) {
      return this.scrollBy(x, y);
    }
    [_scrollBy_2](x, y, scrollOptions) {
      return this.scrollBy(x, y, scrollOptions);
    }
    [_scrollBy_3](x, y) {
      return this.scrollBy(x, y);
    }
    [_scrollBy_4](x, y, scrollOptions) {
      return this.scrollBy(x, y, scrollOptions);
    }
    [dartx.scrollTo](x, y, scrollOptions) {
      if (scrollOptions === void 0) scrollOptions = null;
      if (typeof y == 'number' && typeof x == 'number' && scrollOptions == null) {
        this[_scrollTo_1](x, y);
        return;
      }
      if (scrollOptions != null && typeof y == 'number' && typeof x == 'number') {
        let scrollOptions_1 = html_common.convertDartToNative_Dictionary(scrollOptions);
        this[_scrollTo_2](x, y, scrollOptions_1);
        return;
      }
      if (typeof y == 'number' && typeof x == 'number' && scrollOptions == null) {
        this[_scrollTo_3](x, y);
        return;
      }
      if (scrollOptions != null && typeof y == 'number' && typeof x == 'number') {
        let scrollOptions_1 = html_common.convertDartToNative_Dictionary(scrollOptions);
        this[_scrollTo_4](x, y, scrollOptions_1);
        return;
      }
      dart.throw(new core.ArgumentError("Incorrect number or type of arguments"));
    }
    [_scrollTo_1](x, y) {
      return this.scrollTo(x, y);
    }
    [_scrollTo_2](x, y, scrollOptions) {
      return this.scrollTo(x, y, scrollOptions);
    }
    [_scrollTo_3](x, y) {
      return this.scrollTo(x, y);
    }
    [_scrollTo_4](x, y, scrollOptions) {
      return this.scrollTo(x, y, scrollOptions);
    }
    [dartx.showModalDialog](url, dialogArgs, featureArgs) {
      return this.showModalDialog(url, dialogArgs, featureArgs);
    }
    [dartx.stop]() {
      return this.stop();
    }
    [__requestFileSystem](type, size, successCallback, errorCallback) {
      return this.webkitRequestFileSystem(type, size, successCallback, errorCallback);
    }
    [_requestFileSystem](type, size) {
      let completer = async.Completer$(FileSystem).new();
      this[__requestFileSystem](type, size, dart.fn(value => {
        completer.complete(value);
      }, dart.void, [FileSystem]), dart.fn(error => {
        completer.completeError(error);
      }, dart.void, [FileError]));
      return completer.future;
    }
    [_resolveLocalFileSystemUrl](url, successCallback, errorCallback) {
      return this.webkitResolveLocalFileSystemURL(url, successCallback, errorCallback);
    }
    [dartx.resolveLocalFileSystemUrl](url) {
      let completer = async.Completer$(Entry).new();
      this[_resolveLocalFileSystemUrl](url, dart.fn(value => {
        completer.complete(value);
      }, dart.void, [Entry]), dart.fn(error => {
        completer.completeError(error);
      }, dart.void, [FileError]));
      return completer.future;
    }
    [dartx.atob](string) {
      return this.atob(string);
    }
    [dartx.btoa](string) {
      return this.btoa(string);
    }
    [_clearInterval](handle) {
      return this.clearInterval(handle);
    }
    [_clearTimeout](handle) {
      return this.clearTimeout(handle);
    }
    [_setInterval](handler, timeout) {
      return this.setInterval(handler, timeout);
    }
    [_setTimeout](handler, timeout) {
      return this.setTimeout(handler, timeout);
    }
    get [dartx.onContentLoaded]() {
      return Window.contentLoadedEvent.forTarget(this);
    }
    get [dartx.onAbort]() {
      return Element.abortEvent.forTarget(this);
    }
    get [dartx.onBlur]() {
      return Element.blurEvent.forTarget(this);
    }
    get [dartx.onCanPlay]() {
      return Element.canPlayEvent.forTarget(this);
    }
    get [dartx.onCanPlayThrough]() {
      return Element.canPlayThroughEvent.forTarget(this);
    }
    get [dartx.onChange]() {
      return Element.changeEvent.forTarget(this);
    }
    get [dartx.onClick]() {
      return Element.clickEvent.forTarget(this);
    }
    get [dartx.onContextMenu]() {
      return Element.contextMenuEvent.forTarget(this);
    }
    get [dartx.onDoubleClick]() {
      return Element.doubleClickEvent.forTarget(this);
    }
    get [dartx.onDeviceMotion]() {
      return Window.deviceMotionEvent.forTarget(this);
    }
    get [dartx.onDeviceOrientation]() {
      return Window.deviceOrientationEvent.forTarget(this);
    }
    get [dartx.onDrag]() {
      return Element.dragEvent.forTarget(this);
    }
    get [dartx.onDragEnd]() {
      return Element.dragEndEvent.forTarget(this);
    }
    get [dartx.onDragEnter]() {
      return Element.dragEnterEvent.forTarget(this);
    }
    get [dartx.onDragLeave]() {
      return Element.dragLeaveEvent.forTarget(this);
    }
    get [dartx.onDragOver]() {
      return Element.dragOverEvent.forTarget(this);
    }
    get [dartx.onDragStart]() {
      return Element.dragStartEvent.forTarget(this);
    }
    get [dartx.onDrop]() {
      return Element.dropEvent.forTarget(this);
    }
    get [dartx.onDurationChange]() {
      return Element.durationChangeEvent.forTarget(this);
    }
    get [dartx.onEmptied]() {
      return Element.emptiedEvent.forTarget(this);
    }
    get [dartx.onEnded]() {
      return Element.endedEvent.forTarget(this);
    }
    get [dartx.onError]() {
      return Element.errorEvent.forTarget(this);
    }
    get [dartx.onFocus]() {
      return Element.focusEvent.forTarget(this);
    }
    get [dartx.onHashChange]() {
      return Window.hashChangeEvent.forTarget(this);
    }
    get [dartx.onInput]() {
      return Element.inputEvent.forTarget(this);
    }
    get [dartx.onInvalid]() {
      return Element.invalidEvent.forTarget(this);
    }
    get [dartx.onKeyDown]() {
      return Element.keyDownEvent.forTarget(this);
    }
    get [dartx.onKeyPress]() {
      return Element.keyPressEvent.forTarget(this);
    }
    get [dartx.onKeyUp]() {
      return Element.keyUpEvent.forTarget(this);
    }
    get [dartx.onLoad]() {
      return Element.loadEvent.forTarget(this);
    }
    get [dartx.onLoadedData]() {
      return Element.loadedDataEvent.forTarget(this);
    }
    get [dartx.onLoadedMetadata]() {
      return Element.loadedMetadataEvent.forTarget(this);
    }
    get [dartx.onLoadStart]() {
      return Window.loadStartEvent.forTarget(this);
    }
    get [dartx.onMessage]() {
      return Window.messageEvent.forTarget(this);
    }
    get [dartx.onMouseDown]() {
      return Element.mouseDownEvent.forTarget(this);
    }
    get [dartx.onMouseEnter]() {
      return Element.mouseEnterEvent.forTarget(this);
    }
    get [dartx.onMouseLeave]() {
      return Element.mouseLeaveEvent.forTarget(this);
    }
    get [dartx.onMouseMove]() {
      return Element.mouseMoveEvent.forTarget(this);
    }
    get [dartx.onMouseOut]() {
      return Element.mouseOutEvent.forTarget(this);
    }
    get [dartx.onMouseOver]() {
      return Element.mouseOverEvent.forTarget(this);
    }
    get [dartx.onMouseUp]() {
      return Element.mouseUpEvent.forTarget(this);
    }
    get [dartx.onMouseWheel]() {
      return Element.mouseWheelEvent.forTarget(this);
    }
    get [dartx.onOffline]() {
      return Window.offlineEvent.forTarget(this);
    }
    get [dartx.onOnline]() {
      return Window.onlineEvent.forTarget(this);
    }
    get [dartx.onPageHide]() {
      return Window.pageHideEvent.forTarget(this);
    }
    get [dartx.onPageShow]() {
      return Window.pageShowEvent.forTarget(this);
    }
    get [dartx.onPause]() {
      return Element.pauseEvent.forTarget(this);
    }
    get [dartx.onPlay]() {
      return Element.playEvent.forTarget(this);
    }
    get [dartx.onPlaying]() {
      return Element.playingEvent.forTarget(this);
    }
    get [dartx.onPopState]() {
      return Window.popStateEvent.forTarget(this);
    }
    get [dartx.onProgress]() {
      return Window.progressEvent.forTarget(this);
    }
    get [dartx.onRateChange]() {
      return Element.rateChangeEvent.forTarget(this);
    }
    get [dartx.onReset]() {
      return Element.resetEvent.forTarget(this);
    }
    get [dartx.onResize]() {
      return Element.resizeEvent.forTarget(this);
    }
    get [dartx.onScroll]() {
      return Element.scrollEvent.forTarget(this);
    }
    get [dartx.onSearch]() {
      return Element.searchEvent.forTarget(this);
    }
    get [dartx.onSeeked]() {
      return Element.seekedEvent.forTarget(this);
    }
    get [dartx.onSeeking]() {
      return Element.seekingEvent.forTarget(this);
    }
    get [dartx.onSelect]() {
      return Element.selectEvent.forTarget(this);
    }
    get [dartx.onStalled]() {
      return Element.stalledEvent.forTarget(this);
    }
    get [dartx.onStorage]() {
      return Window.storageEvent.forTarget(this);
    }
    get [dartx.onSubmit]() {
      return Element.submitEvent.forTarget(this);
    }
    get [dartx.onSuspend]() {
      return Element.suspendEvent.forTarget(this);
    }
    get [dartx.onTimeUpdate]() {
      return Element.timeUpdateEvent.forTarget(this);
    }
    get [dartx.onTouchCancel]() {
      return Element.touchCancelEvent.forTarget(this);
    }
    get [dartx.onTouchEnd]() {
      return Element.touchEndEvent.forTarget(this);
    }
    get [dartx.onTouchMove]() {
      return Element.touchMoveEvent.forTarget(this);
    }
    get [dartx.onTouchStart]() {
      return Element.touchStartEvent.forTarget(this);
    }
    get [dartx.onTransitionEnd]() {
      return Element.transitionEndEvent.forTarget(this);
    }
    get [dartx.onUnload]() {
      return Window.unloadEvent.forTarget(this);
    }
    get [dartx.onVolumeChange]() {
      return Element.volumeChangeEvent.forTarget(this);
    }
    get [dartx.onWaiting]() {
      return Element.waitingEvent.forTarget(this);
    }
    get [dartx.onAnimationEnd]() {
      return Window.animationEndEvent.forTarget(this);
    }
    get [dartx.onAnimationIteration]() {
      return Window.animationIterationEvent.forTarget(this);
    }
    get [dartx.onAnimationStart]() {
      return Window.animationStartEvent.forTarget(this);
    }
    get [dartx.onBeforeUnload]() {
      return Window.beforeUnloadEvent.forTarget(this);
    }
    [dartx.moveTo](p) {
      this[_moveTo](dart.as(p.x, core.num), dart.as(p.y, core.num));
    }
    get [dartx.pageXOffset]() {
      return this.pageXOffset[dartx.round]();
    }
    get [dartx.pageYOffset]() {
      return this.pageYOffset[dartx.round]();
    }
    get [dartx.scrollX]() {
      return "scrollX" in this ? this.scrollX[dartx.round]() : this[dartx.document][dartx.documentElement][dartx.scrollLeft];
    }
    get [dartx.scrollY]() {
      return "scrollY" in this ? this.scrollY[dartx.round]() : this[dartx.document][dartx.documentElement][dartx.scrollTop];
    }
  }
  Window[dart.implements] = () => [WindowEventHandlers, WindowBase, GlobalEventHandlers, _WindowTimers, WindowBase64];
  dart.setSignature(Window, {
    constructors: () => ({_: [Window, []]}),
    methods: () => ({
      [_open2]: [WindowBase, [dart.dynamic, dart.dynamic]],
      [_open3]: [WindowBase, [dart.dynamic, dart.dynamic, dart.dynamic]],
      [dartx.open]: [WindowBase, [core.String, core.String], [core.String]],
      [dartx.requestAnimationFrame]: [core.int, [RequestAnimationFrameCallback]],
      [dartx.cancelAnimationFrame]: [dart.void, [core.int]],
      [_requestAnimationFrame]: [core.int, [RequestAnimationFrameCallback]],
      [_cancelAnimationFrame]: [dart.void, [core.int]],
      [_ensureRequestAnimationFrame]: [dart.dynamic, []],
      [dartx.requestFileSystem]: [async.Future$(FileSystem), [core.int], {persistent: core.bool}],
      [__getter__]: [WindowBase, [dart.dynamic]],
      [__getter___1]: [dart.dynamic, [core.int]],
      [__getter___2]: [dart.dynamic, [core.String]],
      [dartx.alert]: [dart.void, [], [core.String]],
      [dartx.close]: [dart.void, []],
      [dartx.confirm]: [core.bool, [], [core.String]],
      [dartx.find]: [core.bool, [core.String, core.bool, core.bool, core.bool, core.bool, core.bool, core.bool]],
      [_getComputedStyle]: [CssStyleDeclaration, [Element, core.String]],
      [dartx.getMatchedCssRules]: [core.List$(CssRule), [Element, core.String]],
      [dartx.getSelection]: [Selection, []],
      [dartx.matchMedia]: [MediaQueryList, [core.String]],
      [dartx.moveBy]: [dart.void, [core.num, core.num]],
      [_moveTo]: [dart.void, [core.num, core.num]],
      [dartx.openDatabase]: [web_sql.SqlDatabase, [core.String, core.String, core.String, core.int], [DatabaseCallback]],
      [dartx.postMessage]: [dart.void, [dart.dynamic, core.String], [core.List$(MessagePort)]],
      [_postMessage_1]: [dart.void, [dart.dynamic, dart.dynamic, core.List$(MessagePort)]],
      [_postMessage_2]: [dart.void, [dart.dynamic, dart.dynamic]],
      [dartx.print]: [dart.void, []],
      [dartx.resizeBy]: [dart.void, [core.num, core.num]],
      [dartx.resizeTo]: [dart.void, [core.num, core.num]],
      [dartx.scroll]: [dart.void, [dart.dynamic, dart.dynamic], [core.Map]],
      [_scroll_1]: [dart.void, [core.num, core.num]],
      [_scroll_2]: [dart.void, [core.num, core.num, dart.dynamic]],
      [_scroll_3]: [dart.void, [core.int, core.int]],
      [_scroll_4]: [dart.void, [core.int, core.int, dart.dynamic]],
      [dartx.scrollBy]: [dart.void, [dart.dynamic, dart.dynamic], [core.Map]],
      [_scrollBy_1]: [dart.void, [core.num, core.num]],
      [_scrollBy_2]: [dart.void, [core.num, core.num, dart.dynamic]],
      [_scrollBy_3]: [dart.void, [core.int, core.int]],
      [_scrollBy_4]: [dart.void, [core.int, core.int, dart.dynamic]],
      [dartx.scrollTo]: [dart.void, [dart.dynamic, dart.dynamic], [core.Map]],
      [_scrollTo_1]: [dart.void, [core.num, core.num]],
      [_scrollTo_2]: [dart.void, [core.num, core.num, dart.dynamic]],
      [_scrollTo_3]: [dart.void, [core.int, core.int]],
      [_scrollTo_4]: [dart.void, [core.int, core.int, dart.dynamic]],
      [dartx.showModalDialog]: [core.Object, [core.String], [core.Object, core.String]],
      [dartx.stop]: [dart.void, []],
      [__requestFileSystem]: [dart.void, [core.int, core.int, _FileSystemCallback], [_ErrorCallback]],
      [_requestFileSystem]: [async.Future$(FileSystem), [core.int, core.int]],
      [_resolveLocalFileSystemUrl]: [dart.void, [core.String, _EntryCallback], [_ErrorCallback]],
      [dartx.resolveLocalFileSystemUrl]: [async.Future$(Entry), [core.String]],
      [dartx.atob]: [core.String, [core.String]],
      [dartx.btoa]: [core.String, [core.String]],
      [_clearInterval]: [dart.void, [core.int]],
      [_clearTimeout]: [dart.void, [core.int]],
      [_setInterval]: [core.int, [core.Object, core.int]],
      [_setTimeout]: [core.int, [core.Object, core.int]],
      [dartx.moveTo]: [dart.void, [math.Point]]
    })
  });
  Window[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('Window')), dart.const(new _js_helper.Native("Window,DOMWindow"))];
  Window.PERSISTENT = 1;
  Window.TEMPORARY = 0;
  dart.defineLazyProperties(Window, {
    get contentLoadedEvent() {
      return dart.const(new (EventStreamProvider$(Event))('DOMContentLoaded'));
    },
    get deviceMotionEvent() {
      return dart.const(new (EventStreamProvider$(DeviceMotionEvent))('devicemotion'));
    },
    get deviceOrientationEvent() {
      return dart.const(new (EventStreamProvider$(DeviceOrientationEvent))('deviceorientation'));
    },
    get hashChangeEvent() {
      return dart.const(new (EventStreamProvider$(Event))('hashchange'));
    },
    get loadStartEvent() {
      return dart.const(new (EventStreamProvider$(Event))('loadstart'));
    },
    get messageEvent() {
      return dart.const(new (EventStreamProvider$(MessageEvent))('message'));
    },
    get offlineEvent() {
      return dart.const(new (EventStreamProvider$(Event))('offline'));
    },
    get onlineEvent() {
      return dart.const(new (EventStreamProvider$(Event))('online'));
    },
    get pageHideEvent() {
      return dart.const(new (EventStreamProvider$(Event))('pagehide'));
    },
    get pageShowEvent() {
      return dart.const(new (EventStreamProvider$(Event))('pageshow'));
    },
    get popStateEvent() {
      return dart.const(new (EventStreamProvider$(PopStateEvent))('popstate'));
    },
    get progressEvent() {
      return dart.const(new (EventStreamProvider$(Event))('progress'));
    },
    get storageEvent() {
      return dart.const(new (EventStreamProvider$(StorageEvent))('storage'));
    },
    get unloadEvent() {
      return dart.const(new (EventStreamProvider$(Event))('unload'));
    },
    get animationEndEvent() {
      return dart.const(new (EventStreamProvider$(AnimationEvent))('webkitAnimationEnd'));
    },
    get animationIterationEvent() {
      return dart.const(new (EventStreamProvider$(AnimationEvent))('webkitAnimationIteration'));
    },
    get animationStartEvent() {
      return dart.const(new (EventStreamProvider$(AnimationEvent))('webkitAnimationStart'));
    },
    get beforeUnloadEvent() {
      return dart.const(new _BeforeUnloadEventStreamProvider('beforeunload'));
    }
  });
  dart.registerExtension(dart.global.Window, Window);
  class _WrappedEvent extends core.Object {
    _WrappedEvent(wrapped) {
      this.wrapped = wrapped;
      this[_selector] = null;
    }
    get bubbles() {
      return this.wrapped[dartx.bubbles];
    }
    get cancelable() {
      return this.wrapped[dartx.cancelable];
    }
    get clipboardData() {
      return this.wrapped[dartx.clipboardData];
    }
    get currentTarget() {
      return this.wrapped[dartx.currentTarget];
    }
    get defaultPrevented() {
      return this.wrapped[dartx.defaultPrevented];
    }
    get eventPhase() {
      return this.wrapped[dartx.eventPhase];
    }
    get target() {
      return this.wrapped[dartx.target];
    }
    get timeStamp() {
      return this.wrapped[dartx.timeStamp];
    }
    get type() {
      return this.wrapped[dartx.type];
    }
    [_initEvent](eventTypeArg, canBubbleArg, cancelableArg) {
      dart.throw(new core.UnsupportedError('Cannot initialize this Event.'));
    }
    preventDefault() {
      this.wrapped[dartx.preventDefault]();
    }
    stopImmediatePropagation() {
      this.wrapped[dartx.stopImmediatePropagation]();
    }
    stopPropagation() {
      this.wrapped[dartx.stopPropagation]();
    }
    get matchingTarget() {
      if (this[_selector] == null) {
        dart.throw(new core.UnsupportedError('Cannot call matchingTarget if this Event did' + ' not arise as a result of event delegation.'));
      }
      let currentTarget = this.currentTarget;
      let target = this.target;
      let matchedTarget = null;
      do {
        if (dart.notNull(dart.as(dart.dcall(target[dartx.matches], this[_selector]), core.bool))) return dart.as(target, Element);
        target = dart.as(dart.dload(target, dartx.parent), EventTarget);
      } while (target != null && !dart.equals(target, dart.dload(currentTarget, dartx.parent)));
      dart.throw(new core.StateError('No selector matched for populating matchedTarget.'));
    }
    get path() {
      return this.wrapped[dartx.path];
    }
    get [_get_currentTarget]() {
      return this.wrapped[_get_currentTarget];
    }
    get [_get_target]() {
      return this.wrapped[_get_target];
    }
  }
  _WrappedEvent[dart.implements] = () => [Event];
  dart.setSignature(_WrappedEvent, {
    constructors: () => ({_WrappedEvent: [_WrappedEvent, [Event]]}),
    methods: () => ({
      [_initEvent]: [dart.void, [core.String, core.bool, core.bool]],
      preventDefault: [dart.void, []],
      stopImmediatePropagation: [dart.void, []],
      stopPropagation: [dart.void, []]
    })
  });
  dart.defineExtensionMembers(_WrappedEvent, [
    _initEvent,
    'preventDefault',
    'stopImmediatePropagation',
    'stopPropagation',
    _selector,
    _selector,
    'bubbles',
    'cancelable',
    'clipboardData',
    'currentTarget',
    'defaultPrevented',
    'eventPhase',
    'target',
    'timeStamp',
    'type',
    'matchingTarget',
    'path',
    _get_currentTarget,
    _get_target
  ]);
  const _returnValue = Symbol('_returnValue');
  class _BeforeUnloadEvent extends _WrappedEvent {
    _BeforeUnloadEvent(base) {
      this[_returnValue] = null;
      super._WrappedEvent(base);
    }
    get returnValue() {
      return this[_returnValue];
    }
    set returnValue(value) {
      this[_returnValue] = value;
      if ("returnValue" in this.wrapped) {
        this.wrapped.returnValue = value;
      }
    }
  }
  _BeforeUnloadEvent[dart.implements] = () => [BeforeUnloadEvent];
  dart.setSignature(_BeforeUnloadEvent, {
    constructors: () => ({_BeforeUnloadEvent: [_BeforeUnloadEvent, [Event]]})
  });
  dart.defineExtensionMembers(_BeforeUnloadEvent, ['returnValue', 'returnValue']);
  const _eventType = Symbol('_eventType');
  class _BeforeUnloadEventStreamProvider extends core.Object {
    _BeforeUnloadEventStreamProvider(eventType) {
      this[_eventType] = eventType;
    }
    forTarget(e, opts) {
      let useCapture = opts && 'useCapture' in opts ? opts.useCapture : false;
      let stream = new _EventStream(e, this[_eventType], useCapture);
      let controller = async.StreamController.new({sync: true});
      stream.listen(dart.fn(event => {
        let wrapped = new _BeforeUnloadEvent(dart.as(event, Event));
        controller.add(wrapped);
        return wrapped.returnValue;
      }, dart.void, [dart.dynamic]));
      return dart.as(controller.stream, async.Stream$(BeforeUnloadEvent));
    }
    getEventType(target) {
      return this[_eventType];
    }
    forElement(e, opts) {
      let useCapture = opts && 'useCapture' in opts ? opts.useCapture : false;
      return new (_ElementEventStreamImpl$(BeforeUnloadEvent))(e, this[_eventType], useCapture);
    }
    [_forElementList](e, opts) {
      let useCapture = opts && 'useCapture' in opts ? opts.useCapture : false;
      return new (_ElementListEventStreamImpl$(BeforeUnloadEvent))(dart.as(e, core.Iterable$(Element)), this[_eventType], useCapture);
    }
  }
  _BeforeUnloadEventStreamProvider[dart.implements] = () => [EventStreamProvider$(BeforeUnloadEvent)];
  dart.setSignature(_BeforeUnloadEventStreamProvider, {
    constructors: () => ({_BeforeUnloadEventStreamProvider: [_BeforeUnloadEventStreamProvider, [core.String]]}),
    methods: () => ({
      forTarget: [async.Stream$(BeforeUnloadEvent), [EventTarget], {useCapture: core.bool}],
      getEventType: [core.String, [EventTarget]],
      forElement: [ElementStream$(BeforeUnloadEvent), [Element], {useCapture: core.bool}],
      [_forElementList]: [ElementStream$(BeforeUnloadEvent), [ElementList], {useCapture: core.bool}]
    })
  });
  class WindowBase64 extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
  }
  dart.setSignature(WindowBase64, {
    constructors: () => ({_: [WindowBase64, []]})
  });
  WindowBase64[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('WindowBase64')), dart.const(new _metadata.Experimental())];
  dart.defineExtensionNames([
    'onHashChange',
    'onMessage',
    'onOffline',
    'onOnline',
    'onPopState',
    'onStorage',
    'onUnload'
  ]);
  class WindowEventHandlers extends EventTarget {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.onHashChange]() {
      return WindowEventHandlers.hashChangeEvent.forTarget(this);
    }
    get [dartx.onMessage]() {
      return WindowEventHandlers.messageEvent.forTarget(this);
    }
    get [dartx.onOffline]() {
      return WindowEventHandlers.offlineEvent.forTarget(this);
    }
    get [dartx.onOnline]() {
      return WindowEventHandlers.onlineEvent.forTarget(this);
    }
    get [dartx.onPopState]() {
      return WindowEventHandlers.popStateEvent.forTarget(this);
    }
    get [dartx.onStorage]() {
      return WindowEventHandlers.storageEvent.forTarget(this);
    }
    get [dartx.onUnload]() {
      return WindowEventHandlers.unloadEvent.forTarget(this);
    }
  }
  dart.setSignature(WindowEventHandlers, {
    constructors: () => ({_: [WindowEventHandlers, []]})
  });
  WindowEventHandlers[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('WindowEventHandlers')), dart.const(new _metadata.Experimental())];
  dart.defineLazyProperties(WindowEventHandlers, {
    get hashChangeEvent() {
      return dart.const(new (EventStreamProvider$(Event))('hashchange'));
    },
    get messageEvent() {
      return dart.const(new (EventStreamProvider$(MessageEvent))('message'));
    },
    get offlineEvent() {
      return dart.const(new (EventStreamProvider$(Event))('offline'));
    },
    get onlineEvent() {
      return dart.const(new (EventStreamProvider$(Event))('online'));
    },
    get popStateEvent() {
      return dart.const(new (EventStreamProvider$(PopStateEvent))('popstate'));
    },
    get storageEvent() {
      return dart.const(new (EventStreamProvider$(StorageEvent))('storage'));
    },
    get unloadEvent() {
      return dart.const(new (EventStreamProvider$(Event))('unload'));
    }
  });
  dart.defineExtensionNames([
    'postMessage',
    'terminate',
    'onError',
    'onMessage'
  ]);
  class Worker extends EventTarget {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new(scriptUrl) {
      return Worker._create_1(scriptUrl);
    }
    static _create_1(scriptUrl) {
      return dart.as(new Worker(scriptUrl), Worker);
    }
    static get supported() {
      return typeof window.Worker != "undefined";
    }
    [dartx.postMessage](message, transfer) {
      if (transfer === void 0) transfer = null;
      if (transfer != null) {
        let message_1 = html_common.convertDartToNative_SerializedScriptValue(message);
        this[_postMessage_1](message_1, transfer);
        return;
      }
      let message_1 = html_common.convertDartToNative_SerializedScriptValue(message);
      this[_postMessage_2](message_1);
      return;
    }
    [_postMessage_1](message, transfer) {
      return this.postMessage(message, transfer);
    }
    [_postMessage_2](message) {
      return this.postMessage(message);
    }
    [dartx.terminate]() {
      return this.terminate();
    }
    get [dartx.onError]() {
      return Worker.errorEvent.forTarget(this);
    }
    get [dartx.onMessage]() {
      return Worker.messageEvent.forTarget(this);
    }
  }
  Worker[dart.implements] = () => [AbstractWorker];
  dart.setSignature(Worker, {
    constructors: () => ({
      _: [Worker, []],
      new: [Worker, [core.String]]
    }),
    methods: () => ({
      [dartx.postMessage]: [dart.void, [dart.dynamic], [core.List$(MessagePort)]],
      [_postMessage_1]: [dart.void, [dart.dynamic, core.List$(MessagePort)]],
      [_postMessage_2]: [dart.void, [dart.dynamic]],
      [dartx.terminate]: [dart.void, []]
    }),
    statics: () => ({_create_1: [Worker, [dart.dynamic]]}),
    names: ['_create_1']
  });
  Worker[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('Worker')), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.CHROME)), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.FIREFOX)), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.IE, '10')), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.SAFARI)), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("Worker"))];
  dart.defineLazyProperties(Worker, {
    get errorEvent() {
      return dart.const(new (EventStreamProvider$(Event))('error'));
    },
    get messageEvent() {
      return dart.const(new (EventStreamProvider$(MessageEvent))('message'));
    }
  });
  dart.registerExtension(dart.global.Worker, Worker);
  class WorkerConsole extends ConsoleBase {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
  }
  dart.setSignature(WorkerConsole, {
    constructors: () => ({_: [WorkerConsole, []]})
  });
  WorkerConsole[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('WorkerConsole')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("WorkerConsole"))];
  dart.registerExtension(dart.global.WorkerConsole, WorkerConsole);
  dart.defineExtensionNames([
    'now',
    'memory'
  ]);
  class WorkerPerformance extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.memory]() {
      return this.memory;
    }
    [dartx.now]() {
      return this.now();
    }
  }
  dart.setSignature(WorkerPerformance, {
    constructors: () => ({_: [WorkerPerformance, []]}),
    methods: () => ({[dartx.now]: [core.double, []]})
  });
  WorkerPerformance[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('WorkerPerformance')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("WorkerPerformance"))];
  dart.registerExtension(dart.global.WorkerPerformance, WorkerPerformance);
  dart.defineExtensionNames([
    'createExpression',
    'createNSResolver',
    'evaluate'
  ]);
  class XPathEvaluator extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return XPathEvaluator._create_1();
    }
    static _create_1() {
      return dart.as(new XPathEvaluator(), XPathEvaluator);
    }
    [dartx.createExpression](expression, resolver) {
      return this.createExpression(expression, resolver);
    }
    [dartx.createNSResolver](nodeResolver) {
      return this.createNSResolver(nodeResolver);
    }
    [dartx.evaluate](expression, contextNode, resolver, type, inResult) {
      return this.evaluate(expression, contextNode, resolver, type, inResult);
    }
  }
  dart.setSignature(XPathEvaluator, {
    constructors: () => ({
      _: [XPathEvaluator, []],
      new: [XPathEvaluator, []]
    }),
    methods: () => ({
      [dartx.createExpression]: [XPathExpression, [core.String, XPathNSResolver]],
      [dartx.createNSResolver]: [XPathNSResolver, [Node]],
      [dartx.evaluate]: [XPathResult, [core.String, Node, XPathNSResolver, core.int, XPathResult]]
    }),
    statics: () => ({_create_1: [XPathEvaluator, []]}),
    names: ['_create_1']
  });
  XPathEvaluator[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('XPathEvaluator')), core.deprecated, dart.const(new _js_helper.Native("XPathEvaluator"))];
  dart.registerExtension(dart.global.XPathEvaluator, XPathEvaluator);
  dart.defineExtensionNames([
    'evaluate'
  ]);
  class XPathExpression extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    [dartx.evaluate](contextNode, type, inResult) {
      return this.evaluate(contextNode, type, inResult);
    }
  }
  dart.setSignature(XPathExpression, {
    constructors: () => ({_: [XPathExpression, []]}),
    methods: () => ({[dartx.evaluate]: [XPathResult, [Node, core.int, XPathResult]]})
  });
  XPathExpression[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('XPathExpression')), core.deprecated, dart.const(new _js_helper.Native("XPathExpression"))];
  dart.registerExtension(dart.global.XPathExpression, XPathExpression);
  dart.defineExtensionNames([
    'lookupNamespaceUri'
  ]);
  class XPathNSResolver extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    [dartx.lookupNamespaceUri](prefix) {
      return this.lookupNamespaceURI(prefix);
    }
  }
  dart.setSignature(XPathNSResolver, {
    constructors: () => ({_: [XPathNSResolver, []]}),
    methods: () => ({[dartx.lookupNamespaceUri]: [core.String, [core.String]]})
  });
  XPathNSResolver[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('XPathNSResolver')), core.deprecated, dart.const(new _js_helper.Native("XPathNSResolver"))];
  dart.registerExtension(dart.global.XPathNSResolver, XPathNSResolver);
  dart.defineExtensionNames([
    'iterateNext',
    'snapshotItem',
    'booleanValue',
    'invalidIteratorState',
    'numberValue',
    'resultType',
    'singleNodeValue',
    'snapshotLength',
    'stringValue'
  ]);
  class XPathResult extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.booleanValue]() {
      return this.booleanValue;
    }
    get [dartx.invalidIteratorState]() {
      return this.invalidIteratorState;
    }
    get [dartx.numberValue]() {
      return this.numberValue;
    }
    get [dartx.resultType]() {
      return this.resultType;
    }
    get [dartx.singleNodeValue]() {
      return this.singleNodeValue;
    }
    get [dartx.snapshotLength]() {
      return this.snapshotLength;
    }
    get [dartx.stringValue]() {
      return this.stringValue;
    }
    [dartx.iterateNext]() {
      return this.iterateNext();
    }
    [dartx.snapshotItem](index) {
      return this.snapshotItem(index);
    }
  }
  dart.setSignature(XPathResult, {
    constructors: () => ({_: [XPathResult, []]}),
    methods: () => ({
      [dartx.iterateNext]: [Node, []],
      [dartx.snapshotItem]: [Node, [core.int]]
    })
  });
  XPathResult[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('XPathResult')), core.deprecated, dart.const(new _js_helper.Native("XPathResult"))];
  XPathResult.ANY_TYPE = 0;
  XPathResult.ANY_UNORDERED_NODE_TYPE = 8;
  XPathResult.BOOLEAN_TYPE = 3;
  XPathResult.FIRST_ORDERED_NODE_TYPE = 9;
  XPathResult.NUMBER_TYPE = 1;
  XPathResult.ORDERED_NODE_ITERATOR_TYPE = 5;
  XPathResult.ORDERED_NODE_SNAPSHOT_TYPE = 7;
  XPathResult.STRING_TYPE = 2;
  XPathResult.UNORDERED_NODE_ITERATOR_TYPE = 4;
  XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE = 6;
  dart.registerExtension(dart.global.XPathResult, XPathResult);
  class XmlDocument extends Document {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
  }
  dart.setSignature(XmlDocument, {
    constructors: () => ({_: [XmlDocument, []]})
  });
  XmlDocument[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('XMLDocument')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("XMLDocument"))];
  dart.registerExtension(dart.global.XMLDocument, XmlDocument);
  dart.defineExtensionNames([
    'serializeToString'
  ]);
  class XmlSerializer extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return XmlSerializer._create_1();
    }
    static _create_1() {
      return dart.as(new XMLSerializer(), XmlSerializer);
    }
    [dartx.serializeToString](node) {
      return this.serializeToString(node);
    }
  }
  dart.setSignature(XmlSerializer, {
    constructors: () => ({
      _: [XmlSerializer, []],
      new: [XmlSerializer, []]
    }),
    methods: () => ({[dartx.serializeToString]: [core.String, [Node]]}),
    statics: () => ({_create_1: [XmlSerializer, []]}),
    names: ['_create_1']
  });
  XmlSerializer[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('XMLSerializer')), core.deprecated, dart.const(new _js_helper.Native("XMLSerializer"))];
  dart.registerExtension(dart.global.XMLSerializer, XmlSerializer);
  dart.defineExtensionNames([
    'clearParameters',
    'getParameter',
    'importStylesheet',
    'removeParameter',
    'reset',
    'setParameter',
    'transformToDocument',
    'transformToFragment'
  ]);
  class XsltProcessor extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return XsltProcessor._create_1();
    }
    static _create_1() {
      return dart.as(new XSLTProcessor(), XsltProcessor);
    }
    static get supported() {
      return !!window.XSLTProcessor;
    }
    [dartx.clearParameters]() {
      return this.clearParameters();
    }
    [dartx.getParameter](namespaceURI, localName) {
      return this.getParameter(namespaceURI, localName);
    }
    [dartx.importStylesheet](stylesheet) {
      return this.importStylesheet(stylesheet);
    }
    [dartx.removeParameter](namespaceURI, localName) {
      return this.removeParameter(namespaceURI, localName);
    }
    [dartx.reset]() {
      return this.reset();
    }
    [dartx.setParameter](namespaceURI, localName, value) {
      return this.setParameter(namespaceURI, localName, value);
    }
    [dartx.transformToDocument](source) {
      return this.transformToDocument(source);
    }
    [dartx.transformToFragment](source, docVal) {
      return this.transformToFragment(source, docVal);
    }
  }
  dart.setSignature(XsltProcessor, {
    constructors: () => ({
      _: [XsltProcessor, []],
      new: [XsltProcessor, []]
    }),
    methods: () => ({
      [dartx.clearParameters]: [dart.void, []],
      [dartx.getParameter]: [core.String, [core.String, core.String]],
      [dartx.importStylesheet]: [dart.void, [Node]],
      [dartx.removeParameter]: [dart.void, [core.String, core.String]],
      [dartx.reset]: [dart.void, []],
      [dartx.setParameter]: [dart.void, [core.String, core.String, core.String]],
      [dartx.transformToDocument]: [Document, [Node]],
      [dartx.transformToFragment]: [DocumentFragment, [Node, Document]]
    }),
    statics: () => ({_create_1: [XsltProcessor, []]}),
    names: ['_create_1']
  });
  XsltProcessor[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('XSLTProcessor')), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.CHROME)), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.FIREFOX)), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.SAFARI)), core.deprecated, dart.const(new _js_helper.Native("XSLTProcessor"))];
  dart.registerExtension(dart.global.XSLTProcessor, XsltProcessor);
  dart.defineExtensionNames([
    'text',
    'text',
    'name',
    'value'
  ]);
  class _Attr extends Node {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.name]() {
      return this.name;
    }
    get [dartx.text]() {
      return this.textContent;
    }
    set [dartx.text](value) {
      this.textContent = value;
    }
    get [dartx.value]() {
      return this.value;
    }
    set [dartx.value](value) {
      this.value = value;
    }
  }
  dart.setSignature(_Attr, {
    constructors: () => ({_: [_Attr, []]})
  });
  _Attr[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('Attr')), dart.const(new _js_helper.Native("Attr"))];
  dart.registerExtension(dart.global.Attr, _Attr);
  class _CSSValue extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
  }
  dart.setSignature(_CSSValue, {
    constructors: () => ({_: [_CSSValue, []]})
  });
  _CSSValue[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('CSSValue')), core.deprecated, dart.const(new _js_helper.Native("CSSValue"))];
  dart.registerExtension(dart.global.CSSValue, _CSSValue);
  class _CSSPrimitiveValue extends _CSSValue {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
  }
  dart.setSignature(_CSSPrimitiveValue, {
    constructors: () => ({_: [_CSSPrimitiveValue, []]})
  });
  _CSSPrimitiveValue[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('CSSPrimitiveValue')), core.deprecated, dart.const(new _js_helper.Native("CSSPrimitiveValue"))];
  dart.registerExtension(dart.global.CSSPrimitiveValue, _CSSPrimitiveValue);
  class _CSSUnknownRule extends CssRule {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
  }
  dart.setSignature(_CSSUnknownRule, {
    constructors: () => ({_: [_CSSUnknownRule, []]})
  });
  _CSSUnknownRule[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('CSSUnknownRule')), core.deprecated, dart.const(new _js_helper.Native("CSSUnknownRule"))];
  dart.registerExtension(dart.global.CSSUnknownRule, _CSSUnknownRule);
  class _Cache extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
  }
  dart.setSignature(_Cache, {
    constructors: () => ({_: [_Cache, []]})
  });
  _Cache[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('Cache')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("Cache"))];
  dart.registerExtension(dart.global.Cache, _Cache);
  class _CanvasPathMethods extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
  }
  dart.setSignature(_CanvasPathMethods, {
    constructors: () => ({_: [_CanvasPathMethods, []]})
  });
  _CanvasPathMethods[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('CanvasPathMethods')), dart.const(new _metadata.Experimental())];
  dart.defineExtensionNames([
    'toString',
    '==',
    'hashCode',
    'intersection',
    'intersects',
    'boundingBox',
    'containsRectangle',
    'containsPoint',
    'topLeft',
    'topRight',
    'bottomRight',
    'bottomLeft',
    'bottom',
    'height',
    'left',
    'right',
    'top',
    'width'
  ]);
  class _ClientRect extends _interceptors.Interceptor {
    toString() {
      return `Rectangle (${this[dartx.left]}, ${this[dartx.top]}) ${this[dartx.width]} x ${this[dartx.height]}`;
    }
    ['=='](other) {
      if (!dart.is(other, math.Rectangle)) return false;
      return dart.equals(this[dartx.left], dart.dload(other, 'left')) && dart.equals(this[dartx.top], dart.dload(other, 'top')) && dart.equals(this[dartx.width], dart.dload(other, 'width')) && dart.equals(this[dartx.height], dart.dload(other, 'height'));
    }
    get hashCode() {
      return _JenkinsSmiHash.hash4(dart.hashCode(this[dartx.left]), dart.hashCode(this[dartx.top]), dart.hashCode(this[dartx.width]), dart.hashCode(this[dartx.height]));
    }
    [dartx.intersection](other) {
      let x0 = math.max(this[dartx.left], dart.as(other[dartx.left], core.num));
      let x1 = math.min(dart.notNull(this[dartx.left]) + dart.notNull(this[dartx.width]), dart.as(dart.dsend(other[dartx.left], '+', other[dartx.width]), core.num));
      if (dart.notNull(x0) <= dart.notNull(x1)) {
        let y0 = math.max(this[dartx.top], dart.as(other[dartx.top], core.num));
        let y1 = math.min(dart.notNull(this[dartx.top]) + dart.notNull(this[dartx.height]), dart.as(dart.dsend(other[dartx.top], '+', other[dartx.height]), core.num));
        if (dart.notNull(y0) <= dart.notNull(y1)) {
          return new math.Rectangle(x0, y0, dart.notNull(x1) - dart.notNull(x0), dart.notNull(y1) - dart.notNull(y0));
        }
      }
      return null;
    }
    [dartx.intersects](other) {
      return dart.notNull(this[dartx.left]) <= dart.notNull(other[dartx.left]) + dart.notNull(other[dartx.width]) && dart.notNull(other[dartx.left]) <= dart.notNull(this[dartx.left]) + dart.notNull(this[dartx.width]) && dart.notNull(this[dartx.top]) <= dart.notNull(other[dartx.top]) + dart.notNull(other[dartx.height]) && dart.notNull(other[dartx.top]) <= dart.notNull(this[dartx.top]) + dart.notNull(this[dartx.height]);
    }
    [dartx.boundingBox](other) {
      let right = math.max(dart.notNull(this[dartx.left]) + dart.notNull(this[dartx.width]), dart.as(dart.dsend(other[dartx.left], '+', other[dartx.width]), core.num));
      let bottom = math.max(dart.notNull(this[dartx.top]) + dart.notNull(this[dartx.height]), dart.as(dart.dsend(other[dartx.top], '+', other[dartx.height]), core.num));
      let left = math.min(this[dartx.left], dart.as(other[dartx.left], core.num));
      let top = math.min(this[dartx.top], dart.as(other[dartx.top], core.num));
      return new math.Rectangle(left, top, dart.notNull(right) - dart.notNull(left), dart.notNull(bottom) - dart.notNull(top));
    }
    [dartx.containsRectangle](another) {
      return dart.notNull(this[dartx.left]) <= dart.notNull(another[dartx.left]) && dart.notNull(this[dartx.left]) + dart.notNull(this[dartx.width]) >= dart.notNull(another[dartx.left]) + dart.notNull(another[dartx.width]) && dart.notNull(this[dartx.top]) <= dart.notNull(another[dartx.top]) && dart.notNull(this[dartx.top]) + dart.notNull(this[dartx.height]) >= dart.notNull(another[dartx.top]) + dart.notNull(another[dartx.height]);
    }
    [dartx.containsPoint](another) {
      return dart.notNull(another.x) >= dart.notNull(this[dartx.left]) && dart.notNull(another.x) <= dart.notNull(this[dartx.left]) + dart.notNull(this[dartx.width]) && dart.notNull(another.y) >= dart.notNull(this[dartx.top]) && dart.notNull(another.y) <= dart.notNull(this[dartx.top]) + dart.notNull(this[dartx.height]);
    }
    get [dartx.topLeft]() {
      return new math.Point(this[dartx.left], this[dartx.top]);
    }
    get [dartx.topRight]() {
      return new math.Point(dart.notNull(this[dartx.left]) + dart.notNull(this[dartx.width]), this[dartx.top]);
    }
    get [dartx.bottomRight]() {
      return new math.Point(dart.notNull(this[dartx.left]) + dart.notNull(this[dartx.width]), dart.notNull(this[dartx.top]) + dart.notNull(this[dartx.height]));
    }
    get [dartx.bottomLeft]() {
      return new math.Point(this[dartx.left], dart.notNull(this[dartx.top]) + dart.notNull(this[dartx.height]));
    }
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.bottom]() {
      return this.bottom;
    }
    get [dartx.height]() {
      return this.height;
    }
    get [dartx.left]() {
      return this.left;
    }
    get [dartx.right]() {
      return this.right;
    }
    get [dartx.top]() {
      return this.top;
    }
    get [dartx.width]() {
      return this.width;
    }
  }
  _ClientRect[dart.implements] = () => [math.Rectangle];
  dart.setSignature(_ClientRect, {
    constructors: () => ({_: [_ClientRect, []]}),
    methods: () => ({
      [dartx.intersection]: [math.Rectangle, [math.Rectangle]],
      [dartx.intersects]: [core.bool, [math.Rectangle$(core.num)]],
      [dartx.boundingBox]: [math.Rectangle, [math.Rectangle]],
      [dartx.containsRectangle]: [core.bool, [math.Rectangle$(core.num)]],
      [dartx.containsPoint]: [core.bool, [math.Point$(core.num)]]
    })
  });
  _ClientRect[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('ClientRect')), dart.const(new _js_helper.Native("ClientRect"))];
  dart.registerExtension(dart.global.ClientRect, _ClientRect);
  class _JenkinsSmiHash extends core.Object {
    static combine(hash, value) {
      hash = 536870911 & dart.notNull(hash) + dart.notNull(value);
      hash = 536870911 & dart.notNull(hash) + ((524287 & dart.notNull(hash)) << 10);
      return dart.notNull(hash) ^ dart.notNull(hash) >> 6;
    }
    static finish(hash) {
      hash = 536870911 & dart.notNull(hash) + ((67108863 & dart.notNull(hash)) << 3);
      hash = dart.notNull(hash) ^ dart.notNull(hash) >> 11;
      return 536870911 & dart.notNull(hash) + ((16383 & dart.notNull(hash)) << 15);
    }
    static hash2(a, b) {
      return _JenkinsSmiHash.finish(_JenkinsSmiHash.combine(_JenkinsSmiHash.combine(0, dart.as(a, core.int)), dart.as(b, core.int)));
    }
    static hash4(a, b, c, d) {
      return _JenkinsSmiHash.finish(_JenkinsSmiHash.combine(_JenkinsSmiHash.combine(_JenkinsSmiHash.combine(_JenkinsSmiHash.combine(0, dart.as(a, core.int)), dart.as(b, core.int)), dart.as(c, core.int)), dart.as(d, core.int)));
    }
  }
  dart.setSignature(_JenkinsSmiHash, {
    statics: () => ({
      combine: [core.int, [core.int, core.int]],
      finish: [core.int, [core.int]],
      hash2: [core.int, [dart.dynamic, dart.dynamic]],
      hash4: [core.int, [dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic]]
    }),
    names: ['combine', 'finish', 'hash2', 'hash4']
  });
  dart.defineExtensionNames([
    'length',
    'get',
    'set',
    'length',
    'first',
    'last',
    'single',
    'elementAt',
    'item'
  ]);
  class _ClientRectList extends dart.mixin(_interceptors.Interceptor, collection.ListMixin$(math.Rectangle), ImmutableListMixin$(math.Rectangle)) {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.length]() {
      return this.length;
    }
    [dartx.get](index) {
      if (index >>> 0 !== index || index >= this[dartx.length]) dart.throw(core.RangeError.index(index, this));
      return dart.as(this[index], math.Rectangle);
    }
    [dartx.set](index, value) {
      dart.throw(new core.UnsupportedError("Cannot assign element of immutable List."));
      return value;
    }
    set [dartx.length](value) {
      dart.throw(new core.UnsupportedError("Cannot resize immutable List."));
    }
    get [dartx.first]() {
      if (dart.notNull(this[dartx.length]) > 0) {
        return dart.as(this[0], math.Rectangle);
      }
      dart.throw(new core.StateError("No elements"));
    }
    get [dartx.last]() {
      let len = this[dartx.length];
      if (dart.notNull(len) > 0) {
        return dart.as(this[dart.notNull(len) - 1], math.Rectangle);
      }
      dart.throw(new core.StateError("No elements"));
    }
    get [dartx.single]() {
      let len = this[dartx.length];
      if (len == 1) {
        return dart.as(this[0], math.Rectangle);
      }
      if (len == 0) dart.throw(new core.StateError("No elements"));
      dart.throw(new core.StateError("More than one element"));
    }
    [dartx.elementAt](index) {
      return this[dartx.get](index);
    }
    [dartx.item](index) {
      return this.item(index);
    }
  }
  _ClientRectList[dart.implements] = () => [core.List$(math.Rectangle), _js_helper.JavaScriptIndexingBehavior];
  dart.setSignature(_ClientRectList, {
    constructors: () => ({_: [_ClientRectList, []]}),
    methods: () => ({
      [dartx.get]: [math.Rectangle, [core.int]],
      [dartx.set]: [dart.void, [core.int, math.Rectangle]],
      [dartx.elementAt]: [math.Rectangle, [core.int]],
      [dartx.item]: [math.Rectangle, [core.int]]
    })
  });
  _ClientRectList[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('ClientRectList')), dart.const(new _js_helper.Native("ClientRectList,DOMRectList"))];
  dart.registerExtension(dart.global.ClientRectList, _ClientRectList);
  class _Counter extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
  }
  dart.setSignature(_Counter, {
    constructors: () => ({_: [_Counter, []]})
  });
  _Counter[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('Counter')), core.deprecated, dart.const(new _js_helper.Native("Counter"))];
  dart.registerExtension(dart.global.Counter, _Counter);
  dart.defineExtensionNames([
    'length',
    'get',
    'set',
    'length',
    'first',
    'last',
    'single',
    'elementAt',
    'item'
  ]);
  class _CssRuleList extends dart.mixin(_interceptors.Interceptor, collection.ListMixin$(CssRule), ImmutableListMixin$(CssRule)) {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.length]() {
      return this.length;
    }
    [dartx.get](index) {
      if (index >>> 0 !== index || index >= this[dartx.length]) dart.throw(core.RangeError.index(index, this));
      return dart.as(this[index], CssRule);
    }
    [dartx.set](index, value) {
      dart.throw(new core.UnsupportedError("Cannot assign element of immutable List."));
      return value;
    }
    set [dartx.length](value) {
      dart.throw(new core.UnsupportedError("Cannot resize immutable List."));
    }
    get [dartx.first]() {
      if (dart.notNull(this[dartx.length]) > 0) {
        return dart.as(this[0], CssRule);
      }
      dart.throw(new core.StateError("No elements"));
    }
    get [dartx.last]() {
      let len = this[dartx.length];
      if (dart.notNull(len) > 0) {
        return dart.as(this[dart.notNull(len) - 1], CssRule);
      }
      dart.throw(new core.StateError("No elements"));
    }
    get [dartx.single]() {
      let len = this[dartx.length];
      if (len == 1) {
        return dart.as(this[0], CssRule);
      }
      if (len == 0) dart.throw(new core.StateError("No elements"));
      dart.throw(new core.StateError("More than one element"));
    }
    [dartx.elementAt](index) {
      return this[dartx.get](index);
    }
    [dartx.item](index) {
      return this.item(index);
    }
  }
  _CssRuleList[dart.implements] = () => [_js_helper.JavaScriptIndexingBehavior, core.List$(CssRule)];
  dart.setSignature(_CssRuleList, {
    constructors: () => ({_: [_CssRuleList, []]}),
    methods: () => ({
      [dartx.get]: [CssRule, [core.int]],
      [dartx.set]: [dart.void, [core.int, CssRule]],
      [dartx.elementAt]: [CssRule, [core.int]],
      [dartx.item]: [CssRule, [core.int]]
    })
  });
  _CssRuleList[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('CSSRuleList')), dart.const(new _js_helper.Native("CSSRuleList"))];
  dart.registerExtension(dart.global.CSSRuleList, _CssRuleList);
  dart.defineExtensionNames([
    'length',
    'get',
    'set',
    'length',
    'first',
    'last',
    'single',
    'elementAt',
    'item'
  ]);
  class _CssValueList extends dart.mixin(_CSSValue, collection.ListMixin$(_CSSValue), ImmutableListMixin$(_CSSValue)) {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.length]() {
      return this.length;
    }
    [dartx.get](index) {
      if (index >>> 0 !== index || index >= this[dartx.length]) dart.throw(core.RangeError.index(index, this));
      return dart.as(this[index], _CSSValue);
    }
    [dartx.set](index, value) {
      dart.throw(new core.UnsupportedError("Cannot assign element of immutable List."));
      return value;
    }
    set [dartx.length](value) {
      dart.throw(new core.UnsupportedError("Cannot resize immutable List."));
    }
    get [dartx.first]() {
      if (dart.notNull(this[dartx.length]) > 0) {
        return dart.as(this[0], _CSSValue);
      }
      dart.throw(new core.StateError("No elements"));
    }
    get [dartx.last]() {
      let len = this[dartx.length];
      if (dart.notNull(len) > 0) {
        return dart.as(this[dart.notNull(len) - 1], _CSSValue);
      }
      dart.throw(new core.StateError("No elements"));
    }
    get [dartx.single]() {
      let len = this[dartx.length];
      if (len == 1) {
        return dart.as(this[0], _CSSValue);
      }
      if (len == 0) dart.throw(new core.StateError("No elements"));
      dart.throw(new core.StateError("More than one element"));
    }
    [dartx.elementAt](index) {
      return this[dartx.get](index);
    }
    [dartx.item](index) {
      return this.item(index);
    }
  }
  _CssValueList[dart.implements] = () => [_js_helper.JavaScriptIndexingBehavior, core.List$(_CSSValue)];
  dart.setSignature(_CssValueList, {
    constructors: () => ({_: [_CssValueList, []]}),
    methods: () => ({
      [dartx.get]: [_CSSValue, [core.int]],
      [dartx.set]: [dart.void, [core.int, _CSSValue]],
      [dartx.elementAt]: [_CSSValue, [core.int]],
      [dartx.item]: [_CSSValue, [core.int]]
    })
  });
  _CssValueList[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('CSSValueList')), core.deprecated, dart.const(new _js_helper.Native("CSSValueList"))];
  dart.registerExtension(dart.global.CSSValueList, _CssValueList);
  class _DOMFileSystemSync extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
  }
  dart.setSignature(_DOMFileSystemSync, {
    constructors: () => ({_: [_DOMFileSystemSync, []]})
  });
  _DOMFileSystemSync[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('DOMFileSystemSync')), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.CHROME)), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("DOMFileSystemSync"))];
  dart.registerExtension(dart.global.DOMFileSystemSync, _DOMFileSystemSync);
  class _EntrySync extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
  }
  dart.setSignature(_EntrySync, {
    constructors: () => ({_: [_EntrySync, []]})
  });
  _EntrySync[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('EntrySync')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("EntrySync"))];
  dart.registerExtension(dart.global.EntrySync, _EntrySync);
  class _DirectoryEntrySync extends _EntrySync {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
  }
  dart.setSignature(_DirectoryEntrySync, {
    constructors: () => ({_: [_DirectoryEntrySync, []]})
  });
  _DirectoryEntrySync[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('DirectoryEntrySync')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("DirectoryEntrySync"))];
  dart.registerExtension(dart.global.DirectoryEntrySync, _DirectoryEntrySync);
  class _DirectoryReaderSync extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
  }
  dart.setSignature(_DirectoryReaderSync, {
    constructors: () => ({_: [_DirectoryReaderSync, []]})
  });
  _DirectoryReaderSync[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('DirectoryReaderSync')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("DirectoryReaderSync"))];
  dart.registerExtension(dart.global.DirectoryReaderSync, _DirectoryReaderSync);
  class _DocumentType extends Node {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
  }
  _DocumentType[dart.implements] = () => [ChildNode];
  dart.setSignature(_DocumentType, {
    constructors: () => ({_: [_DocumentType, []]})
  });
  _DocumentType[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('DocumentType')), core.deprecated, dart.const(new _js_helper.Native("DocumentType"))];
  dart.registerExtension(dart.global.DocumentType, _DocumentType);
  dart.defineExtensionNames([
    'height',
    'height',
    'width',
    'width',
    'x',
    'x',
    'y',
    'y'
  ]);
  class _DomRect extends DomRectReadOnly {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new(x, y, width, height) {
      if (x === void 0) x = null;
      if (y === void 0) y = null;
      if (width === void 0) width = null;
      if (height === void 0) height = null;
      if (height != null) {
        return _DomRect._create_1(x, y, width, height);
      }
      if (width != null) {
        return _DomRect._create_2(x, y, width);
      }
      if (y != null) {
        return _DomRect._create_3(x, y);
      }
      if (x != null) {
        return _DomRect._create_4(x);
      }
      return _DomRect._create_5();
    }
    static _create_1(x, y, width, height) {
      return dart.as(new DOMRect(x, y, width, height), _DomRect);
    }
    static _create_2(x, y, width) {
      return dart.as(new DOMRect(x, y, width), _DomRect);
    }
    static _create_3(x, y) {
      return dart.as(new DOMRect(x, y), _DomRect);
    }
    static _create_4(x) {
      return dart.as(new DOMRect(x), _DomRect);
    }
    static _create_5() {
      return dart.as(new DOMRect(), _DomRect);
    }
    get [dartx.height]() {
      return this.height;
    }
    set [dartx.height](value) {
      this.height = value;
    }
    get [dartx.width]() {
      return this.width;
    }
    set [dartx.width](value) {
      this.width = value;
    }
    get [dartx.x]() {
      return this.x;
    }
    set [dartx.x](value) {
      this.x = value;
    }
    get [dartx.y]() {
      return this.y;
    }
    set [dartx.y](value) {
      this.y = value;
    }
  }
  dart.setSignature(_DomRect, {
    constructors: () => ({
      _: [_DomRect, []],
      new: [_DomRect, [], [core.num, core.num, core.num, core.num]]
    }),
    statics: () => ({
      _create_1: [_DomRect, [dart.dynamic, dart.dynamic, dart.dynamic, dart.dynamic]],
      _create_2: [_DomRect, [dart.dynamic, dart.dynamic, dart.dynamic]],
      _create_3: [_DomRect, [dart.dynamic, dart.dynamic]],
      _create_4: [_DomRect, [dart.dynamic]],
      _create_5: [_DomRect, []]
    }),
    names: ['_create_1', '_create_2', '_create_3', '_create_4', '_create_5']
  });
  _DomRect[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('DOMRect')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("DOMRect"))];
  dart.registerExtension(dart.global.DOMRect, _DomRect);
  class _FileEntrySync extends _EntrySync {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
  }
  dart.setSignature(_FileEntrySync, {
    constructors: () => ({_: [_FileEntrySync, []]})
  });
  _FileEntrySync[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('FileEntrySync')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("FileEntrySync"))];
  dart.registerExtension(dart.global.FileEntrySync, _FileEntrySync);
  class _FileReaderSync extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new() {
      return _FileReaderSync._create_1();
    }
    static _create_1() {
      return dart.as(new FileReaderSync(), _FileReaderSync);
    }
  }
  dart.setSignature(_FileReaderSync, {
    constructors: () => ({
      _: [_FileReaderSync, []],
      new: [_FileReaderSync, []]
    }),
    statics: () => ({_create_1: [_FileReaderSync, []]}),
    names: ['_create_1']
  });
  _FileReaderSync[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('FileReaderSync')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("FileReaderSync"))];
  dart.registerExtension(dart.global.FileReaderSync, _FileReaderSync);
  class _FileWriterSync extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
  }
  dart.setSignature(_FileWriterSync, {
    constructors: () => ({_: [_FileWriterSync, []]})
  });
  _FileWriterSync[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('FileWriterSync')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("FileWriterSync"))];
  dart.registerExtension(dart.global.FileWriterSync, _FileWriterSync);
  dart.defineExtensionNames([
    'length',
    'get',
    'set',
    'length',
    'first',
    'last',
    'single',
    'elementAt',
    'item'
  ]);
  class _GamepadList extends dart.mixin(_interceptors.Interceptor, collection.ListMixin$(Gamepad), ImmutableListMixin$(Gamepad)) {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.length]() {
      return this.length;
    }
    [dartx.get](index) {
      if (index >>> 0 !== index || index >= this[dartx.length]) dart.throw(core.RangeError.index(index, this));
      return dart.as(this[index], Gamepad);
    }
    [dartx.set](index, value) {
      dart.throw(new core.UnsupportedError("Cannot assign element of immutable List."));
      return value;
    }
    set [dartx.length](value) {
      dart.throw(new core.UnsupportedError("Cannot resize immutable List."));
    }
    get [dartx.first]() {
      if (dart.notNull(this[dartx.length]) > 0) {
        return dart.as(this[0], Gamepad);
      }
      dart.throw(new core.StateError("No elements"));
    }
    get [dartx.last]() {
      let len = this[dartx.length];
      if (dart.notNull(len) > 0) {
        return dart.as(this[dart.notNull(len) - 1], Gamepad);
      }
      dart.throw(new core.StateError("No elements"));
    }
    get [dartx.single]() {
      let len = this[dartx.length];
      if (len == 1) {
        return dart.as(this[0], Gamepad);
      }
      if (len == 0) dart.throw(new core.StateError("No elements"));
      dart.throw(new core.StateError("More than one element"));
    }
    [dartx.elementAt](index) {
      return this[dartx.get](index);
    }
    [dartx.item](index) {
      return this.item(index);
    }
  }
  _GamepadList[dart.implements] = () => [_js_helper.JavaScriptIndexingBehavior, core.List$(Gamepad)];
  dart.setSignature(_GamepadList, {
    constructors: () => ({_: [_GamepadList, []]}),
    methods: () => ({
      [dartx.get]: [Gamepad, [core.int]],
      [dartx.set]: [dart.void, [core.int, Gamepad]],
      [dartx.elementAt]: [Gamepad, [core.int]],
      [dartx.item]: [Gamepad, [core.int]]
    })
  });
  _GamepadList[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('GamepadList')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("GamepadList"))];
  dart.registerExtension(dart.global.GamepadList, _GamepadList);
  class _HTMLAllCollection extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    [_item](index) {
      return this.item(index);
    }
  }
  dart.setSignature(_HTMLAllCollection, {
    constructors: () => ({_: [_HTMLAllCollection, []]}),
    methods: () => ({[_item]: [Element, [core.int]]})
  });
  _HTMLAllCollection[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('HTMLAllCollection')), core.deprecated, dart.const(new _js_helper.Native("HTMLAllCollection"))];
  dart.registerExtension(dart.global.HTMLAllCollection, _HTMLAllCollection);
  class _HTMLAppletElement extends HtmlElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    created() {
      super.created();
    }
  }
  dart.defineNamedConstructor(_HTMLAppletElement, 'created');
  dart.setSignature(_HTMLAppletElement, {
    constructors: () => ({
      _: [_HTMLAppletElement, []],
      created: [_HTMLAppletElement, []]
    })
  });
  _HTMLAppletElement[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('HTMLAppletElement')), core.deprecated, dart.const(new _js_helper.Native("HTMLAppletElement"))];
  dart.registerExtension(dart.global.HTMLAppletElement, _HTMLAppletElement);
  class _HTMLDirectoryElement extends HtmlElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    created() {
      super.created();
    }
  }
  dart.defineNamedConstructor(_HTMLDirectoryElement, 'created');
  dart.setSignature(_HTMLDirectoryElement, {
    constructors: () => ({
      _: [_HTMLDirectoryElement, []],
      created: [_HTMLDirectoryElement, []]
    })
  });
  _HTMLDirectoryElement[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('HTMLDirectoryElement')), core.deprecated, dart.const(new _js_helper.Native("HTMLDirectoryElement"))];
  dart.registerExtension(dart.global.HTMLDirectoryElement, _HTMLDirectoryElement);
  class _HTMLFontElement extends HtmlElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    created() {
      super.created();
    }
  }
  dart.defineNamedConstructor(_HTMLFontElement, 'created');
  dart.setSignature(_HTMLFontElement, {
    constructors: () => ({
      _: [_HTMLFontElement, []],
      created: [_HTMLFontElement, []]
    })
  });
  _HTMLFontElement[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('HTMLFontElement')), core.deprecated, dart.const(new _js_helper.Native("HTMLFontElement"))];
  dart.registerExtension(dart.global.HTMLFontElement, _HTMLFontElement);
  class _HTMLFrameElement extends HtmlElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    created() {
      super.created();
    }
  }
  dart.defineNamedConstructor(_HTMLFrameElement, 'created');
  dart.setSignature(_HTMLFrameElement, {
    constructors: () => ({
      _: [_HTMLFrameElement, []],
      created: [_HTMLFrameElement, []]
    })
  });
  _HTMLFrameElement[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('HTMLFrameElement')), core.deprecated, dart.const(new _js_helper.Native("HTMLFrameElement"))];
  dart.registerExtension(dart.global.HTMLFrameElement, _HTMLFrameElement);
  class _HTMLFrameSetElement extends HtmlElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    created() {
      super.created();
    }
  }
  _HTMLFrameSetElement[dart.implements] = () => [WindowEventHandlers];
  dart.defineNamedConstructor(_HTMLFrameSetElement, 'created');
  dart.setSignature(_HTMLFrameSetElement, {
    constructors: () => ({
      _: [_HTMLFrameSetElement, []],
      created: [_HTMLFrameSetElement, []]
    })
  });
  _HTMLFrameSetElement[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('HTMLFrameSetElement')), core.deprecated, dart.const(new _js_helper.Native("HTMLFrameSetElement"))];
  dart.registerExtension(dart.global.HTMLFrameSetElement, _HTMLFrameSetElement);
  class _HTMLMarqueeElement extends HtmlElement {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    created() {
      super.created();
    }
  }
  dart.defineNamedConstructor(_HTMLMarqueeElement, 'created');
  dart.setSignature(_HTMLMarqueeElement, {
    constructors: () => ({
      _: [_HTMLMarqueeElement, []],
      created: [_HTMLMarqueeElement, []]
    })
  });
  _HTMLMarqueeElement[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('HTMLMarqueeElement')), core.deprecated, dart.const(new _js_helper.Native("HTMLMarqueeElement"))];
  dart.registerExtension(dart.global.HTMLMarqueeElement, _HTMLMarqueeElement);
  const _initMutationEvent = Symbol('_initMutationEvent');
  class _MutationEvent extends Event {
    static new(type, opts) {
      let canBubble = opts && 'canBubble' in opts ? opts.canBubble : false;
      let cancelable = opts && 'cancelable' in opts ? opts.cancelable : false;
      let relatedNode = opts && 'relatedNode' in opts ? opts.relatedNode : null;
      let prevValue = opts && 'prevValue' in opts ? opts.prevValue : null;
      let newValue = opts && 'newValue' in opts ? opts.newValue : null;
      let attrName = opts && 'attrName' in opts ? opts.attrName : null;
      let attrChange = opts && 'attrChange' in opts ? opts.attrChange : 0;
      let event = exports.document[_createEvent]('MutationEvent');
      dart.dcall(event[_initMutationEvent], type, canBubble, cancelable, relatedNode, prevValue, newValue, attrName, attrChange);
      return dart.as(event, _MutationEvent);
    }
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
  }
  dart.setSignature(_MutationEvent, {
    constructors: () => ({
      new: [_MutationEvent, [core.String], {canBubble: core.bool, cancelable: core.bool, relatedNode: Node, prevValue: core.String, newValue: core.String, attrName: core.String, attrChange: core.int}],
      _: [_MutationEvent, []]
    })
  });
  _MutationEvent[dart.metadata] = () => [dart.const(new _metadata.DomName('MutationEvent')), core.deprecated, dart.const(new _js_helper.Native("MutationEvent"))];
  dart.registerExtension(dart.global.MutationEvent, _MutationEvent);
  dart.defineExtensionNames([
    'length',
    'get',
    'set',
    'length',
    'first',
    'last',
    'single',
    'elementAt',
    'getNamedItem',
    'getNamedItemNS',
    'item',
    'removeNamedItem',
    'removeNamedItemNS',
    'setNamedItem',
    'setNamedItemNS'
  ]);
  class _NamedNodeMap extends dart.mixin(_interceptors.Interceptor, collection.ListMixin$(Node), ImmutableListMixin$(Node)) {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.length]() {
      return this.length;
    }
    [dartx.get](index) {
      if (index >>> 0 !== index || index >= this[dartx.length]) dart.throw(core.RangeError.index(index, this));
      return dart.as(this[index], Node);
    }
    [dartx.set](index, value) {
      dart.throw(new core.UnsupportedError("Cannot assign element of immutable List."));
      return value;
    }
    set [dartx.length](value) {
      dart.throw(new core.UnsupportedError("Cannot resize immutable List."));
    }
    get [dartx.first]() {
      if (dart.notNull(this[dartx.length]) > 0) {
        return dart.as(this[0], Node);
      }
      dart.throw(new core.StateError("No elements"));
    }
    get [dartx.last]() {
      let len = this[dartx.length];
      if (dart.notNull(len) > 0) {
        return dart.as(this[dart.notNull(len) - 1], Node);
      }
      dart.throw(new core.StateError("No elements"));
    }
    get [dartx.single]() {
      let len = this[dartx.length];
      if (len == 1) {
        return dart.as(this[0], Node);
      }
      if (len == 0) dart.throw(new core.StateError("No elements"));
      dart.throw(new core.StateError("More than one element"));
    }
    [dartx.elementAt](index) {
      return this[dartx.get](index);
    }
    [__getter__](name) {
      return this.__getter__(name);
    }
    [dartx.getNamedItem](name) {
      return this.getNamedItem(name);
    }
    [dartx.getNamedItemNS](namespaceURI, localName) {
      return this.getNamedItemNS(namespaceURI, localName);
    }
    [dartx.item](index) {
      return this.item(index);
    }
    [dartx.removeNamedItem](name) {
      return this.removeNamedItem(name);
    }
    [dartx.removeNamedItemNS](namespaceURI, localName) {
      return this.removeNamedItemNS(namespaceURI, localName);
    }
    [dartx.setNamedItem](node) {
      return this.setNamedItem(node);
    }
    [dartx.setNamedItemNS](node) {
      return this.setNamedItemNS(node);
    }
  }
  _NamedNodeMap[dart.implements] = () => [_js_helper.JavaScriptIndexingBehavior, core.List$(Node)];
  dart.setSignature(_NamedNodeMap, {
    constructors: () => ({_: [_NamedNodeMap, []]}),
    methods: () => ({
      [dartx.get]: [Node, [core.int]],
      [dartx.set]: [dart.void, [core.int, Node]],
      [dartx.elementAt]: [Node, [core.int]],
      [__getter__]: [Node, [core.String]],
      [dartx.getNamedItem]: [Node, [core.String]],
      [dartx.getNamedItemNS]: [Node, [core.String, core.String]],
      [dartx.item]: [Node, [core.int]],
      [dartx.removeNamedItem]: [Node, [core.String]],
      [dartx.removeNamedItemNS]: [Node, [core.String, core.String]],
      [dartx.setNamedItem]: [Node, [Node]],
      [dartx.setNamedItemNS]: [Node, [Node]]
    })
  });
  _NamedNodeMap[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('NamedNodeMap')), core.deprecated, dart.const(new _js_helper.Native("NamedNodeMap,MozNamedAttrMap"))];
  dart.registerExtension(dart.global.NamedNodeMap, _NamedNodeMap);
  class _PagePopupController extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
  }
  dart.setSignature(_PagePopupController, {
    constructors: () => ({_: [_PagePopupController, []]})
  });
  _PagePopupController[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('PagePopupController')), core.deprecated, dart.const(new _js_helper.Native("PagePopupController"))];
  dart.registerExtension(dart.global.PagePopupController, _PagePopupController);
  class _RGBColor extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
  }
  dart.setSignature(_RGBColor, {
    constructors: () => ({_: [_RGBColor, []]})
  });
  _RGBColor[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('RGBColor')), core.deprecated, dart.const(new _js_helper.Native("RGBColor"))];
  dart.registerExtension(dart.global.RGBColor, _RGBColor);
  class _Rect extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
  }
  dart.setSignature(_Rect, {
    constructors: () => ({_: [_Rect, []]})
  });
  _Rect[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('Rect')), core.deprecated, dart.const(new _js_helper.Native("Rect"))];
  dart.registerExtension(dart.global.Rect, _Rect);
  dart.defineExtensionNames([
    'clone',
    'credentials',
    'headers',
    'mode',
    'referrer',
    'url'
  ]);
  class _Request extends Body {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new(input, requestInitDict) {
      if (requestInitDict === void 0) requestInitDict = null;
      if ((typeof input == 'string' || input == null) && requestInitDict == null) {
        return _Request._create_1(input);
      }
      if ((dart.is(requestInitDict, core.Map) || requestInitDict == null) && (typeof input == 'string' || input == null)) {
        let requestInitDict_1 = html_common.convertDartToNative_Dictionary(requestInitDict);
        return _Request._create_2(input, requestInitDict_1);
      }
      if ((dart.is(input, _Request) || input == null) && requestInitDict == null) {
        return _Request._create_3(input);
      }
      if ((dart.is(requestInitDict, core.Map) || requestInitDict == null) && (dart.is(input, _Request) || input == null)) {
        let requestInitDict_1 = html_common.convertDartToNative_Dictionary(requestInitDict);
        return _Request._create_4(input, requestInitDict_1);
      }
      dart.throw(new core.ArgumentError("Incorrect number or type of arguments"));
    }
    static _create_1(input) {
      return dart.as(new Request(input), _Request);
    }
    static _create_2(input, requestInitDict) {
      return dart.as(new Request(input, requestInitDict), _Request);
    }
    static _create_3(input) {
      return dart.as(new Request(input), _Request);
    }
    static _create_4(input, requestInitDict) {
      return dart.as(new Request(input, requestInitDict), _Request);
    }
    get [dartx.credentials]() {
      return this.credentials;
    }
    get [dartx.headers]() {
      return this.headers;
    }
    get [dartx.mode]() {
      return this.mode;
    }
    get [dartx.referrer]() {
      return this.referrer;
    }
    get [dartx.url]() {
      return this.url;
    }
    [dartx.clone]() {
      return this.clone();
    }
  }
  dart.setSignature(_Request, {
    constructors: () => ({
      _: [_Request, []],
      new: [_Request, [dart.dynamic], [core.Map]]
    }),
    methods: () => ({[dartx.clone]: [_Request, []]}),
    statics: () => ({
      _create_1: [_Request, [dart.dynamic]],
      _create_2: [_Request, [dart.dynamic, dart.dynamic]],
      _create_3: [_Request, [dart.dynamic]],
      _create_4: [_Request, [dart.dynamic, dart.dynamic]]
    }),
    names: ['_create_1', '_create_2', '_create_3', '_create_4']
  });
  _Request[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('Request')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("Request"))];
  dart.registerExtension(dart.global.Request, _Request);
  class _Response extends Body {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new(body_OR_input, requestInitDict_OR_responseInitDict) {
      if (requestInitDict_OR_responseInitDict === void 0) requestInitDict_OR_responseInitDict = null;
      if ((typeof body_OR_input == 'string' || body_OR_input == null) && requestInitDict_OR_responseInitDict == null) {
        return _Response._create_1(body_OR_input);
      }
      if ((dart.is(requestInitDict_OR_responseInitDict, core.Map) || requestInitDict_OR_responseInitDict == null) && (typeof body_OR_input == 'string' || body_OR_input == null)) {
        let responseInitDict_1 = html_common.convertDartToNative_Dictionary(requestInitDict_OR_responseInitDict);
        return _Response._create_2(body_OR_input, responseInitDict_1);
      }
      if ((dart.is(body_OR_input, Blob) || body_OR_input == null) && requestInitDict_OR_responseInitDict == null) {
        return _Response._create_3(body_OR_input);
      }
      if ((dart.is(requestInitDict_OR_responseInitDict, core.Map) || requestInitDict_OR_responseInitDict == null) && (dart.is(body_OR_input, Blob) || body_OR_input == null)) {
        let responseInitDict_1 = html_common.convertDartToNative_Dictionary(requestInitDict_OR_responseInitDict);
        return _Response._create_4(body_OR_input, responseInitDict_1);
      }
      if ((dart.is(body_OR_input, typed_data.TypedData) || body_OR_input == null) && requestInitDict_OR_responseInitDict == null) {
        return _Response._create_5(body_OR_input);
      }
      if ((dart.is(requestInitDict_OR_responseInitDict, core.Map) || requestInitDict_OR_responseInitDict == null) && (dart.is(body_OR_input, typed_data.TypedData) || body_OR_input == null)) {
        let requestInitDict_1 = html_common.convertDartToNative_Dictionary(requestInitDict_OR_responseInitDict);
        return _Response._create_6(body_OR_input, requestInitDict_1);
      }
      if ((dart.is(body_OR_input, typed_data.ByteBuffer) || body_OR_input == null) && requestInitDict_OR_responseInitDict == null) {
        return _Response._create_7(body_OR_input);
      }
      if ((dart.is(requestInitDict_OR_responseInitDict, core.Map) || requestInitDict_OR_responseInitDict == null) && (dart.is(body_OR_input, typed_data.ByteBuffer) || body_OR_input == null)) {
        let requestInitDict_1 = html_common.convertDartToNative_Dictionary(requestInitDict_OR_responseInitDict);
        return _Response._create_8(body_OR_input, requestInitDict_1);
      }
      dart.throw(new core.ArgumentError("Incorrect number or type of arguments"));
    }
    static _create_1(body_OR_input) {
      return dart.as(new Response(body_OR_input), _Response);
    }
    static _create_2(body_OR_input, requestInitDict_OR_responseInitDict) {
      return dart.as(new Response(body_OR_input, requestInitDict_OR_responseInitDict), _Response);
    }
    static _create_3(body_OR_input) {
      return dart.as(new Response(body_OR_input), _Response);
    }
    static _create_4(body_OR_input, requestInitDict_OR_responseInitDict) {
      return dart.as(new Response(body_OR_input, requestInitDict_OR_responseInitDict), _Response);
    }
    static _create_5(body_OR_input) {
      return dart.as(new Response(body_OR_input), _Response);
    }
    static _create_6(body_OR_input, requestInitDict_OR_responseInitDict) {
      return dart.as(new Response(body_OR_input, requestInitDict_OR_responseInitDict), _Response);
    }
    static _create_7(body_OR_input) {
      return dart.as(new Response(body_OR_input), _Response);
    }
    static _create_8(body_OR_input, requestInitDict_OR_responseInitDict) {
      return dart.as(new Response(body_OR_input, requestInitDict_OR_responseInitDict), _Response);
    }
  }
  dart.setSignature(_Response, {
    constructors: () => ({
      _: [_Response, []],
      new: [_Response, [dart.dynamic], [core.Map]]
    }),
    statics: () => ({
      _create_1: [_Response, [dart.dynamic]],
      _create_2: [_Response, [dart.dynamic, dart.dynamic]],
      _create_3: [_Response, [dart.dynamic]],
      _create_4: [_Response, [dart.dynamic, dart.dynamic]],
      _create_5: [_Response, [dart.dynamic]],
      _create_6: [_Response, [dart.dynamic, dart.dynamic]],
      _create_7: [_Response, [dart.dynamic]],
      _create_8: [_Response, [dart.dynamic, dart.dynamic]]
    }),
    names: ['_create_1', '_create_2', '_create_3', '_create_4', '_create_5', '_create_6', '_create_7', '_create_8']
  });
  _Response[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('Response')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("Response"))];
  dart.registerExtension(dart.global.Response, _Response);
  class _ServiceWorker extends EventTarget {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
  }
  _ServiceWorker[dart.implements] = () => [AbstractWorker];
  dart.setSignature(_ServiceWorker, {
    constructors: () => ({_: [_ServiceWorker, []]})
  });
  _ServiceWorker[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('ServiceWorker')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("ServiceWorker"))];
  dart.registerExtension(dart.global.ServiceWorker, _ServiceWorker);
  dart.defineExtensionNames([
    'length',
    'get',
    'set',
    'length',
    'first',
    'last',
    'single',
    'elementAt',
    'item'
  ]);
  class _SpeechRecognitionResultList extends dart.mixin(_interceptors.Interceptor, collection.ListMixin$(SpeechRecognitionResult), ImmutableListMixin$(SpeechRecognitionResult)) {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.length]() {
      return this.length;
    }
    [dartx.get](index) {
      if (index >>> 0 !== index || index >= this[dartx.length]) dart.throw(core.RangeError.index(index, this));
      return dart.as(this[index], SpeechRecognitionResult);
    }
    [dartx.set](index, value) {
      dart.throw(new core.UnsupportedError("Cannot assign element of immutable List."));
      return value;
    }
    set [dartx.length](value) {
      dart.throw(new core.UnsupportedError("Cannot resize immutable List."));
    }
    get [dartx.first]() {
      if (dart.notNull(this[dartx.length]) > 0) {
        return dart.as(this[0], SpeechRecognitionResult);
      }
      dart.throw(new core.StateError("No elements"));
    }
    get [dartx.last]() {
      let len = this[dartx.length];
      if (dart.notNull(len) > 0) {
        return dart.as(this[dart.notNull(len) - 1], SpeechRecognitionResult);
      }
      dart.throw(new core.StateError("No elements"));
    }
    get [dartx.single]() {
      let len = this[dartx.length];
      if (len == 1) {
        return dart.as(this[0], SpeechRecognitionResult);
      }
      if (len == 0) dart.throw(new core.StateError("No elements"));
      dart.throw(new core.StateError("More than one element"));
    }
    [dartx.elementAt](index) {
      return this[dartx.get](index);
    }
    [dartx.item](index) {
      return this.item(index);
    }
  }
  _SpeechRecognitionResultList[dart.implements] = () => [_js_helper.JavaScriptIndexingBehavior, core.List$(SpeechRecognitionResult)];
  dart.setSignature(_SpeechRecognitionResultList, {
    constructors: () => ({_: [_SpeechRecognitionResultList, []]}),
    methods: () => ({
      [dartx.get]: [SpeechRecognitionResult, [core.int]],
      [dartx.set]: [dart.void, [core.int, SpeechRecognitionResult]],
      [dartx.elementAt]: [SpeechRecognitionResult, [core.int]],
      [dartx.item]: [SpeechRecognitionResult, [core.int]]
    })
  });
  _SpeechRecognitionResultList[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('SpeechRecognitionResultList')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("SpeechRecognitionResultList"))];
  dart.registerExtension(dart.global.SpeechRecognitionResultList, _SpeechRecognitionResultList);
  dart.defineExtensionNames([
    'length',
    'get',
    'set',
    'length',
    'first',
    'last',
    'single',
    'elementAt',
    'item'
  ]);
  class _StyleSheetList extends dart.mixin(_interceptors.Interceptor, collection.ListMixin$(StyleSheet), ImmutableListMixin$(StyleSheet)) {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    get [dartx.length]() {
      return this.length;
    }
    [dartx.get](index) {
      if (index >>> 0 !== index || index >= this[dartx.length]) dart.throw(core.RangeError.index(index, this));
      return dart.as(this[index], StyleSheet);
    }
    [dartx.set](index, value) {
      dart.throw(new core.UnsupportedError("Cannot assign element of immutable List."));
      return value;
    }
    set [dartx.length](value) {
      dart.throw(new core.UnsupportedError("Cannot resize immutable List."));
    }
    get [dartx.first]() {
      if (dart.notNull(this[dartx.length]) > 0) {
        return dart.as(this[0], StyleSheet);
      }
      dart.throw(new core.StateError("No elements"));
    }
    get [dartx.last]() {
      let len = this[dartx.length];
      if (dart.notNull(len) > 0) {
        return dart.as(this[dart.notNull(len) - 1], StyleSheet);
      }
      dart.throw(new core.StateError("No elements"));
    }
    get [dartx.single]() {
      let len = this[dartx.length];
      if (len == 1) {
        return dart.as(this[0], StyleSheet);
      }
      if (len == 0) dart.throw(new core.StateError("No elements"));
      dart.throw(new core.StateError("More than one element"));
    }
    [dartx.elementAt](index) {
      return this[dartx.get](index);
    }
    [__getter__](name) {
      return this.__getter__(name);
    }
    [dartx.item](index) {
      return this.item(index);
    }
  }
  _StyleSheetList[dart.implements] = () => [_js_helper.JavaScriptIndexingBehavior, core.List$(StyleSheet)];
  dart.setSignature(_StyleSheetList, {
    constructors: () => ({_: [_StyleSheetList, []]}),
    methods: () => ({
      [dartx.get]: [StyleSheet, [core.int]],
      [dartx.set]: [dart.void, [core.int, StyleSheet]],
      [dartx.elementAt]: [StyleSheet, [core.int]],
      [__getter__]: [CssStyleSheet, [core.String]],
      [dartx.item]: [StyleSheet, [core.int]]
    })
  });
  _StyleSheetList[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('StyleSheetList')), dart.const(new _js_helper.Native("StyleSheetList"))];
  dart.registerExtension(dart.global.StyleSheetList, _StyleSheetList);
  class _SubtleCrypto extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
  }
  dart.setSignature(_SubtleCrypto, {
    constructors: () => ({_: [_SubtleCrypto, []]})
  });
  _SubtleCrypto[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('SubtleCrypto')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("SubtleCrypto"))];
  dart.registerExtension(dart.global.SubtleCrypto, _SubtleCrypto);
  class _WebKitCSSFilterValue extends _CssValueList {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
  }
  dart.setSignature(_WebKitCSSFilterValue, {
    constructors: () => ({_: [_WebKitCSSFilterValue, []]})
  });
  _WebKitCSSFilterValue[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('WebKitCSSFilterValue')), core.deprecated, dart.const(new _js_helper.Native("WebKitCSSFilterValue"))];
  dart.registerExtension(dart.global.WebKitCSSFilterValue, _WebKitCSSFilterValue);
  class _WebKitCSSMatrix extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
    static new(cssValue) {
      if (cssValue === void 0) cssValue = null;
      if (cssValue != null) {
        return _WebKitCSSMatrix._create_1(cssValue);
      }
      return _WebKitCSSMatrix._create_2();
    }
    static _create_1(cssValue) {
      return dart.as(new WebKitCSSMatrix(cssValue), _WebKitCSSMatrix);
    }
    static _create_2() {
      return dart.as(new WebKitCSSMatrix(), _WebKitCSSMatrix);
    }
  }
  dart.setSignature(_WebKitCSSMatrix, {
    constructors: () => ({
      _: [_WebKitCSSMatrix, []],
      new: [_WebKitCSSMatrix, [], [core.String]]
    }),
    statics: () => ({
      _create_1: [_WebKitCSSMatrix, [dart.dynamic]],
      _create_2: [_WebKitCSSMatrix, []]
    }),
    names: ['_create_1', '_create_2']
  });
  _WebKitCSSMatrix[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('WebKitCSSMatrix')), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.CHROME)), dart.const(new _metadata.SupportedBrowser(_metadata.SupportedBrowser.SAFARI)), dart.const(new _metadata.Experimental()), core.deprecated, dart.const(new _js_helper.Native("WebKitCSSMatrix"))];
  dart.registerExtension(dart.global.WebKitCSSMatrix, _WebKitCSSMatrix);
  class _WebKitCSSTransformValue extends _CssValueList {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
  }
  dart.setSignature(_WebKitCSSTransformValue, {
    constructors: () => ({_: [_WebKitCSSTransformValue, []]})
  });
  _WebKitCSSTransformValue[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('WebKitCSSTransformValue')), core.deprecated, dart.const(new _js_helper.Native("WebKitCSSTransformValue"))];
  dart.registerExtension(dart.global.WebKitCSSTransformValue, _WebKitCSSTransformValue);
  class _WindowTimers extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
  }
  dart.setSignature(_WindowTimers, {
    constructors: () => ({_: [_WindowTimers, []]})
  });
  _WindowTimers[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('WindowTimers')), dart.const(new _metadata.Experimental())];
  class _WorkerLocation extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
  }
  _WorkerLocation[dart.implements] = () => [UrlUtilsReadOnly];
  dart.setSignature(_WorkerLocation, {
    constructors: () => ({_: [_WorkerLocation, []]})
  });
  _WorkerLocation[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('WorkerLocation')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("WorkerLocation"))];
  dart.registerExtension(dart.global.WorkerLocation, _WorkerLocation);
  class _WorkerNavigator extends _interceptors.Interceptor {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
  }
  _WorkerNavigator[dart.implements] = () => [NavigatorCpu, NavigatorOnLine, NavigatorID];
  dart.setSignature(_WorkerNavigator, {
    constructors: () => ({_: [_WorkerNavigator, []]})
  });
  _WorkerNavigator[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('WorkerNavigator')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("WorkerNavigator"))];
  dart.registerExtension(dart.global.WorkerNavigator, _WorkerNavigator);
  class _XMLHttpRequestProgressEvent extends ProgressEvent {
    static _() {
      dart.throw(new core.UnsupportedError("Not supported"));
    }
  }
  dart.setSignature(_XMLHttpRequestProgressEvent, {
    constructors: () => ({_: [_XMLHttpRequestProgressEvent, []]})
  });
  _XMLHttpRequestProgressEvent[dart.metadata] = () => [dart.const(new _metadata.DocsEditable()), dart.const(new _metadata.DomName('XMLHttpRequestProgressEvent')), dart.const(new _metadata.Experimental()), dart.const(new _js_helper.Native("XMLHttpRequestProgressEvent"))];
  dart.registerExtension(dart.global.XMLHttpRequestProgressEvent, _XMLHttpRequestProgressEvent);
  const _matches = Symbol('_matches');
  class _AttributeMap extends core.Object {
    _AttributeMap(element) {
      this[_element] = element;
    }
    addAll(other) {
      other[dartx.forEach](dart.fn((k, v) => {
        this.set(k, v);
      }, dart.void, [core.String, core.String]));
    }
    containsValue(value) {
      for (let v of this.values) {
        if (value == v) {
          return true;
        }
      }
      return false;
    }
    putIfAbsent(key, ifAbsent) {
      if (!dart.notNull(this[dartx.containsKey](key))) {
        this.set(key, ifAbsent());
      }
      return this.get(key);
    }
    clear() {
      for (let key of this.keys) {
        this[dartx.remove](key);
      }
    }
    forEach(f) {
      for (let key of this.keys) {
        let value = this.get(key);
        f(key, value);
      }
    }
    get keys() {
      let attributes = this[_element][_attributes];
      let keys = core.List$(core.String).new();
      for (let i = 0, len = attributes[dartx.length]; i < dart.notNull(len); i++) {
        if (dart.notNull(this[_matches](attributes[dartx.get](i)))) {
          keys[dartx.add](dart.as(dart.dload(attributes[dartx.get](i), dartx.name), core.String));
        }
      }
      return keys;
    }
    get values() {
      let attributes = this[_element][_attributes];
      let values = core.List$(core.String).new();
      for (let i = 0, len = attributes[dartx.length]; i < dart.notNull(len); i++) {
        if (dart.notNull(this[_matches](attributes[dartx.get](i)))) {
          values[dartx.add](dart.as(dart.dload(attributes[dartx.get](i), dartx.value), core.String));
        }
      }
      return values;
    }
    get isEmpty() {
      return this[dartx.length] == 0;
    }
    get isNotEmpty() {
      return !dart.notNull(this.isEmpty);
    }
  }
  _AttributeMap[dart.implements] = () => [core.Map$(core.String, core.String)];
  dart.setSignature(_AttributeMap, {
    constructors: () => ({_AttributeMap: [_AttributeMap, [Element]]}),
    methods: () => ({
      addAll: [dart.void, [core.Map$(core.String, core.String)]],
      containsValue: [core.bool, [core.String]],
      putIfAbsent: [core.String, [core.String, dart.functionType(core.String, [])]],
      clear: [dart.void, []],
      forEach: [dart.void, [dart.functionType(dart.void, [core.String, core.String])]]
    })
  });
  dart.defineExtensionMembers(_AttributeMap, [
    'addAll',
    'containsValue',
    'putIfAbsent',
    'clear',
    'forEach',
    'keys',
    'values',
    'isEmpty',
    'isNotEmpty'
  ]);
  class _ElementAttributeMap extends _AttributeMap {
    _ElementAttributeMap(element) {
      super._AttributeMap(element);
    }
    containsKey(key) {
      return this[_element][_hasAttribute](key);
    }
    get(key) {
      return this[_element][dartx.getAttribute](key);
    }
    set(key, value) {
      this[_element][dartx.setAttribute](key, value);
      return value;
    }
    remove(key) {
      let value = this[_element][dartx.getAttribute](key);
      this[_element][_removeAttribute](key);
      return value;
    }
    get length() {
      return this.keys[dartx.length];
    }
    [_matches](node) {
      return node[_namespaceUri] == null;
    }
  }
  dart.setSignature(_ElementAttributeMap, {
    constructors: () => ({_ElementAttributeMap: [_ElementAttributeMap, [Element]]}),
    methods: () => ({
      containsKey: [core.bool, [core.String]],
      get: [core.String, [core.String]],
      set: [dart.void, [core.String, core.String]],
      remove: [core.String, [core.String]],
      [_matches]: [core.bool, [Node]]
    })
  });
  dart.defineExtensionMembers(_ElementAttributeMap, [
    'containsKey',
    'get',
    'set',
    'remove',
    'length'
  ]);
  const _namespace = Symbol('_namespace');
  class _NamespacedAttributeMap extends _AttributeMap {
    _NamespacedAttributeMap(element, namespace) {
      this[_namespace] = namespace;
      super._AttributeMap(element);
    }
    containsKey(key) {
      return this[_element][_hasAttributeNS](this[_namespace], key);
    }
    get(key) {
      return this[_element][dartx.getAttributeNS](this[_namespace], key);
    }
    set(key, value) {
      this[_element][dartx.setAttributeNS](this[_namespace], key, value);
      return value;
    }
    remove(key) {
      let value = this.get(key);
      this[_element][_removeAttributeNS](this[_namespace], key);
      return value;
    }
    get length() {
      return this.keys[dartx.length];
    }
    [_matches](node) {
      return node[_namespaceUri] == this[_namespace];
    }
  }
  dart.setSignature(_NamespacedAttributeMap, {
    constructors: () => ({_NamespacedAttributeMap: [_NamespacedAttributeMap, [Element, core.String]]}),
    methods: () => ({
      containsKey: [core.bool, [core.String]],
      get: [core.String, [core.String]],
      set: [dart.void, [core.String, core.String]],
      remove: [core.String, [core.String]],
      [_matches]: [core.bool, [Node]]
    })
  });
  dart.defineExtensionMembers(_NamespacedAttributeMap, [
    'containsKey',
    'get',
    'set',
    'remove',
    'length'
  ]);
  const _attr = Symbol('_attr');
  const _strip = Symbol('_strip');
  const _toHyphenedName = Symbol('_toHyphenedName');
  const _toCamelCase = Symbol('_toCamelCase');
  class _DataAttributeMap extends core.Object {
    _DataAttributeMap(attributes) {
      this[_attributes] = attributes;
    }
    addAll(other) {
      other[dartx.forEach](dart.fn((k, v) => {
        this.set(k, v);
      }, dart.void, [core.String, core.String]));
    }
    containsValue(value) {
      return this.values[dartx.any](dart.fn(v => v == value, core.bool, [core.String]));
    }
    containsKey(key) {
      return this[_attributes][dartx.containsKey](this[_attr](key));
    }
    get(key) {
      return this[_attributes][dartx.get](this[_attr](key));
    }
    set(key, value) {
      this[_attributes][dartx.set](this[_attr](key), value);
      return value;
    }
    putIfAbsent(key, ifAbsent) {
      return this[_attributes][dartx.putIfAbsent](this[_attr](key), ifAbsent);
    }
    remove(key) {
      return this[_attributes][dartx.remove](this[_attr](key));
    }
    clear() {
      for (let key of this.keys) {
        this.remove(key);
      }
    }
    forEach(f) {
      this[_attributes][dartx.forEach](dart.fn((key, value) => {
        if (dart.notNull(this[_matches](key))) {
          f(this[_strip](key), value);
        }
      }, dart.void, [core.String, core.String]));
    }
    get keys() {
      let keys = core.List$(core.String).new();
      this[_attributes][dartx.forEach](dart.fn((key, value) => {
        if (dart.notNull(this[_matches](key))) {
          keys[dartx.add](this[_strip](key));
        }
      }, dart.void, [core.String, core.String]));
      return keys;
    }
    get values() {
      let values = core.List$(core.String).new();
      this[_attributes][dartx.forEach](dart.fn((key, value) => {
        if (dart.notNull(this[_matches](key))) {
          values[dartx.add](value);
        }
      }, dart.void, [core.String, core.String]));
      return values;
    }
    get length() {
      return this.keys[dartx.length];
    }
    get isEmpty() {
      return this.length == 0;
    }
    get isNotEmpty() {
      return !dart.notNull(this.isEmpty);
    }
    [_attr](key) {
      return `data-${this[_toHyphenedName](key)}`;
    }
    [_matches](key) {
      return key[dartx.startsWith]('data-');
    }
    [_strip](key) {
      return this[_toCamelCase](key[dartx.substring](5));
    }
    [_toCamelCase](hyphenedName, opts) {
      let startUppercase = opts && 'startUppercase' in opts ? opts.startUppercase : false;
      let segments = hyphenedName[dartx.split]('-');
      let start = dart.notNull(startUppercase) ? 0 : 1;
      for (let i = start; i < dart.notNull(segments[dartx.length]); i++) {
        let segment = segments[dartx.get](i);
        if (dart.notNull(segment[dartx.length]) > 0) {
          segments[dartx.set](i, `${segment[dartx.get](0)[dartx.toUpperCase]()}${segment[dartx.substring](1)}`);
        }
      }
      return segments[dartx.join]('');
    }
    [_toHyphenedName](word) {
      let sb = new core.StringBuffer();
      for (let i = 0; i < dart.notNull(word[dartx.length]); i++) {
        let lower = word[dartx.get](i)[dartx.toLowerCase]();
        if (word[dartx.get](i) != lower && i > 0) sb.write('-');
        sb.write(lower);
      }
      return sb.toString();
    }
  }
  _DataAttributeMap[dart.implements] = () => [core.Map$(core.String, core.String)];
  dart.setSignature(_DataAttributeMap, {
    constructors: () => ({_DataAttributeMap: [_DataAttributeMap, [core.Map$(core.String, core.String)]]}),
    methods: () => ({
      addAll: [dart.void, [core.Map$(core.String, core.String)]],
      containsValue: [core.bool, [core.String]],
      containsKey: [core.bool, [core.String]],
      get: [core.String, [core.String]],
      set: [dart.void, [core.String, core.String]],
      putIfAbsent: [core.String, [core.String, dart.functionType(core.String, [])]],
      remove: [core.String, [core.String]],
      clear: [dart.void, []],
      forEach: [dart.void, [dart.functionType(dart.void, [core.String, core.String])]],
      [_attr]: [core.String, [core.String]],
      [_matches]: [core.bool, [core.String]],
      [_strip]: [core.String, [core.String]],
      [_toCamelCase]: [core.String, [core.String], {startUppercase: core.bool}],
      [_toHyphenedName]: [core.String, [core.String]]
    })
  });
  dart.defineExtensionMembers(_DataAttributeMap, [
    'addAll',
    'containsValue',
    'containsKey',
    'get',
    'set',
    'putIfAbsent',
    'remove',
    'clear',
    'forEach',
    'keys',
    'values',
    'length',
    'isEmpty',
    'isNotEmpty'
  ]);
  class CanvasImageSource extends core.Object {}
  class WindowBase extends core.Object {}
  WindowBase[dart.implements] = () => [EventTarget];
  class LocationBase extends core.Object {}
  class HistoryBase extends core.Object {}
  class CssClassSet extends core.Object {}
  CssClassSet[dart.implements] = () => [core.Set$(core.String)];
  const _addOrSubtractToBoxModel = Symbol('_addOrSubtractToBoxModel');
  class CssRect extends math.MutableRectangle$(core.num) {
    CssRect(element) {
      this[_element] = element;
      super.MutableRectangle(0, 0, 0, 0);
    }
    set height(newHeight) {
      dart.throw(new core.UnsupportedError("Can only set height for content rect."));
    }
    set width(newWidth) {
      dart.throw(new core.UnsupportedError("Can only set width for content rect."));
    }
    [_addOrSubtractToBoxModel](dimensions, augmentingMeasurement) {
      let styles = this[_element][dartx.getComputedStyle]();
      let val = 0;
      for (let measurement of dimensions) {
        if (augmentingMeasurement == exports._MARGIN) {
          val = dart.notNull(val) + dart.notNull(dart.asInt(new Dimension.css(styles[dartx.getPropertyValue](`${augmentingMeasurement}-${measurement}`)).value));
        }
        if (augmentingMeasurement == exports._CONTENT) {
          val = dart.notNull(val) - dart.notNull(dart.asInt(new Dimension.css(styles[dartx.getPropertyValue](`${exports._PADDING}-${measurement}`)).value));
        }
        if (augmentingMeasurement != exports._MARGIN) {
          val = dart.notNull(val) - dart.notNull(dart.asInt(new Dimension.css(styles[dartx.getPropertyValue](`border-${measurement}-width`)).value));
        }
      }
      return val;
    }
  }
  dart.setSignature(CssRect, {
    constructors: () => ({CssRect: [CssRect, [Element]]}),
    methods: () => ({[_addOrSubtractToBoxModel]: [core.num, [core.List$(core.String), core.String]]})
  });
  class _ContentCssRect extends CssRect {
    _ContentCssRect(element) {
      super.CssRect(dart.as(element, Element));
    }
    get height() {
      return dart.notNull(this[_element][dartx.offsetHeight]) + dart.notNull(this[_addOrSubtractToBoxModel](exports._HEIGHT, exports._CONTENT));
    }
    get width() {
      return dart.notNull(this[_element][dartx.offsetWidth]) + dart.notNull(this[_addOrSubtractToBoxModel](exports._WIDTH, exports._CONTENT));
    }
    set height(newHeight) {
      if (dart.is(newHeight, Dimension)) {
        if (dart.notNull(dart.as(dart.dsend(dart.dload(newHeight, dartx.value), '<', 0), core.bool))) newHeight = new Dimension.px(0);
        this[_element][dartx.style][dartx.height] = dart.toString(newHeight);
      } else {
        if (dart.notNull(newHeight) < 0) newHeight = 0;
        this[_element][dartx.style][dartx.height] = `${newHeight}px`;
      }
    }
    set width(newWidth) {
      if (dart.is(newWidth, Dimension)) {
        if (dart.notNull(dart.as(dart.dsend(dart.dload(newWidth, dartx.value), '<', 0), core.bool))) newWidth = new Dimension.px(0);
        this[_element][dartx.style][dartx.width] = dart.toString(newWidth);
      } else {
        if (dart.notNull(newWidth) < 0) newWidth = 0;
        this[_element][dartx.style][dartx.width] = `${newWidth}px`;
      }
    }
    get left() {
      return dart.as(dart.dsend(this[_element][dartx.getBoundingClientRect]()[dartx.left], '-', this[_addOrSubtractToBoxModel](dart.list(['left'], core.String), exports._CONTENT)), core.num);
    }
    get top() {
      return dart.as(dart.dsend(this[_element][dartx.getBoundingClientRect]()[dartx.top], '-', this[_addOrSubtractToBoxModel](dart.list(['top'], core.String), exports._CONTENT)), core.num);
    }
  }
  dart.setSignature(_ContentCssRect, {
    constructors: () => ({_ContentCssRect: [_ContentCssRect, [dart.dynamic]]})
  });
  dart.defineExtensionMembers(_ContentCssRect, ['height', 'width', 'left', 'top']);
  const _elementList = Symbol('_elementList');
  class _ContentCssListRect extends _ContentCssRect {
    _ContentCssListRect(elementList) {
      this[_elementList] = null;
      super._ContentCssRect(dart.dload(elementList, 'first'));
      this[_elementList] = dart.as(elementList, core.List$(Element));
    }
    set height(newHeight) {
      this[_elementList][dartx.forEach](dart.fn(e => e[dartx.contentEdge].height = newHeight, core.num, [Element]));
    }
    set width(newWidth) {
      this[_elementList][dartx.forEach](dart.fn(e => e[dartx.contentEdge].width = newWidth, core.num, [Element]));
    }
  }
  dart.setSignature(_ContentCssListRect, {
    constructors: () => ({_ContentCssListRect: [_ContentCssListRect, [dart.dynamic]]})
  });
  class _PaddingCssRect extends CssRect {
    _PaddingCssRect(element) {
      super.CssRect(dart.as(element, Element));
    }
    get height() {
      return dart.notNull(this[_element][dartx.offsetHeight]) + dart.notNull(this[_addOrSubtractToBoxModel](exports._HEIGHT, exports._PADDING));
    }
    get width() {
      return dart.notNull(this[_element][dartx.offsetWidth]) + dart.notNull(this[_addOrSubtractToBoxModel](exports._WIDTH, exports._PADDING));
    }
    get left() {
      return dart.as(dart.dsend(this[_element][dartx.getBoundingClientRect]()[dartx.left], '-', this[_addOrSubtractToBoxModel](dart.list(['left'], core.String), exports._PADDING)), core.num);
    }
    get top() {
      return dart.as(dart.dsend(this[_element][dartx.getBoundingClientRect]()[dartx.top], '-', this[_addOrSubtractToBoxModel](dart.list(['top'], core.String), exports._PADDING)), core.num);
    }
  }
  dart.setSignature(_PaddingCssRect, {
    constructors: () => ({_PaddingCssRect: [_PaddingCssRect, [dart.dynamic]]})
  });
  dart.defineExtensionMembers(_PaddingCssRect, ['height', 'width', 'left', 'top']);
  class _BorderCssRect extends CssRect {
    _BorderCssRect(element) {
      super.CssRect(dart.as(element, Element));
    }
    get height() {
      return this[_element][dartx.offsetHeight];
    }
    get width() {
      return this[_element][dartx.offsetWidth];
    }
    get left() {
      return dart.as(this[_element][dartx.getBoundingClientRect]()[dartx.left], core.num);
    }
    get top() {
      return dart.as(this[_element][dartx.getBoundingClientRect]()[dartx.top], core.num);
    }
  }
  dart.setSignature(_BorderCssRect, {
    constructors: () => ({_BorderCssRect: [_BorderCssRect, [dart.dynamic]]})
  });
  dart.defineExtensionMembers(_BorderCssRect, ['height', 'width', 'left', 'top']);
  class _MarginCssRect extends CssRect {
    _MarginCssRect(element) {
      super.CssRect(dart.as(element, Element));
    }
    get height() {
      return dart.notNull(this[_element][dartx.offsetHeight]) + dart.notNull(this[_addOrSubtractToBoxModel](exports._HEIGHT, exports._MARGIN));
    }
    get width() {
      return dart.notNull(this[_element][dartx.offsetWidth]) + dart.notNull(this[_addOrSubtractToBoxModel](exports._WIDTH, exports._MARGIN));
    }
    get left() {
      return dart.as(dart.dsend(this[_element][dartx.getBoundingClientRect]()[dartx.left], '-', this[_addOrSubtractToBoxModel](dart.list(['left'], core.String), exports._MARGIN)), core.num);
    }
    get top() {
      return dart.as(dart.dsend(this[_element][dartx.getBoundingClientRect]()[dartx.top], '-', this[_addOrSubtractToBoxModel](dart.list(['top'], core.String), exports._MARGIN)), core.num);
    }
  }
  dart.setSignature(_MarginCssRect, {
    constructors: () => ({_MarginCssRect: [_MarginCssRect, [dart.dynamic]]})
  });
  dart.defineExtensionMembers(_MarginCssRect, ['height', 'width', 'left', 'top']);
  dart.defineLazyProperties(exports, {
    get _HEIGHT() {
      return dart.list(['top', 'bottom'], core.String);
    }
  });
  dart.defineLazyProperties(exports, {
    get _WIDTH() {
      return dart.list(['right', 'left'], core.String);
    }
  });
  exports._CONTENT = 'content';
  exports._PADDING = 'padding';
  exports._MARGIN = 'margin';
  const _sets = Symbol('_sets');
  dart.defineLazyClass(exports, {
    get _MultiElementCssClassSet() {
      class _MultiElementCssClassSet extends html_common.CssClassSetImpl {
        static new(elements) {
          return new exports._MultiElementCssClassSet._(elements, dart.as(elements[dartx.map](dart.fn(e => e[dartx.classes], CssClassSet, [Element]))[dartx.toList](), core.List$(html_common.CssClassSetImpl)));
        }
        _(elementIterable, sets) {
          this[_elementIterable] = elementIterable;
          this[_sets] = sets;
        }
        readClasses() {
          let s = collection.LinkedHashSet$(core.String).new();
          this[_sets][dartx.forEach](dart.fn(e => s.addAll(e.readClasses()), dart.void, [html_common.CssClassSetImpl]));
          return s;
        }
        writeClasses(s) {
          let classes = s.join(' ');
          for (let e of this[_elementIterable]) {
            e[dartx.className] = classes;
          }
        }
        modify(f) {
          this[_sets][dartx.forEach](dart.fn(e => e.modify(f), dart.void, [html_common.CssClassSetImpl]));
        }
        toggle(value, shouldAdd) {
          if (shouldAdd === void 0) shouldAdd = null;
          return this[_sets][dartx.fold](false, dart.fn((changed, e) => dart.notNull(e.toggle(value, shouldAdd)) || dart.notNull(changed), core.bool, [core.bool, html_common.CssClassSetImpl]));
        }
        remove(value) {
          return this[_sets][dartx.fold](false, dart.fn((changed, e) => dart.notNull(e.remove(value)) || dart.notNull(changed), core.bool, [core.bool, html_common.CssClassSetImpl]));
        }
      }
      dart.defineNamedConstructor(_MultiElementCssClassSet, '_');
      dart.setSignature(_MultiElementCssClassSet, {
        constructors: () => ({
          new: [exports._MultiElementCssClassSet, [core.Iterable$(Element)]],
          _: [exports._MultiElementCssClassSet, [core.Iterable$(Element), core.List$(html_common.CssClassSetImpl)]]
        }),
        methods: () => ({
          readClasses: [core.Set$(core.String), []],
          writeClasses: [dart.void, [core.Set$(core.String)]]
        })
      });
      return _MultiElementCssClassSet;
    }
  });
  dart.defineLazyClass(exports, {
    get _ElementCssClassSet() {
      class _ElementCssClassSet extends html_common.CssClassSetImpl {
        _ElementCssClassSet(element) {
          this[_element] = element;
        }
        readClasses() {
          let s = collection.LinkedHashSet$(core.String).new();
          let classname = this[_element][dartx.className];
          for (let name of classname[dartx.split](' ')) {
            let trimmed = name[dartx.trim]();
            if (!dart.notNull(trimmed[dartx.isEmpty])) {
              s.add(trimmed);
            }
          }
          return s;
        }
        writeClasses(s) {
          this[_element][dartx.className] = s.join(' ');
        }
        get length() {
          return exports._ElementCssClassSet._classListLength(exports._ElementCssClassSet._classListOf(this[_element]));
        }
        get isEmpty() {
          return this.length == 0;
        }
        get isNotEmpty() {
          return this.length != 0;
        }
        clear() {
          this[_element][dartx.className] = '';
        }
        contains(value) {
          return exports._ElementCssClassSet._contains(this[_element], value);
        }
        add(value) {
          return exports._ElementCssClassSet._add(this[_element], value);
        }
        remove(value) {
          return typeof value == 'string' && dart.notNull(exports._ElementCssClassSet._remove(this[_element], value));
        }
        toggle(value, shouldAdd) {
          if (shouldAdd === void 0) shouldAdd = null;
          return exports._ElementCssClassSet._toggle(this[_element], value, shouldAdd);
        }
        addAll(iterable) {
          exports._ElementCssClassSet._addAll(this[_element], iterable);
        }
        removeAll(iterable) {
          exports._ElementCssClassSet._removeAll(this[_element], iterable);
        }
        retainAll(iterable) {
          exports._ElementCssClassSet._removeWhere(this[_element], dart.bind(iterable[dartx.toSet](), 'contains'), false);
        }
        removeWhere(test) {
          exports._ElementCssClassSet._removeWhere(this[_element], test, true);
        }
        retainWhere(test) {
          exports._ElementCssClassSet._removeWhere(this[_element], test, false);
        }
        static _contains(_element, value) {
          return typeof value == 'string' && dart.notNull(exports._ElementCssClassSet._classListContains(exports._ElementCssClassSet._classListOf(_element), value));
        }
        static _add(_element, value) {
          let list = exports._ElementCssClassSet._classListOf(_element);
          let added = !dart.notNull(exports._ElementCssClassSet._classListContainsBeforeAddOrRemove(list, value));
          exports._ElementCssClassSet._classListAdd(list, value);
          return added;
        }
        static _remove(_element, value) {
          let list = exports._ElementCssClassSet._classListOf(_element);
          let removed = exports._ElementCssClassSet._classListContainsBeforeAddOrRemove(list, value);
          exports._ElementCssClassSet._classListRemove(list, value);
          return removed;
        }
        static _toggle(_element, value, shouldAdd) {
          return shouldAdd == null ? exports._ElementCssClassSet._toggleDefault(_element, value) : exports._ElementCssClassSet._toggleOnOff(_element, value, shouldAdd);
        }
        static _toggleDefault(_element, value) {
          let list = exports._ElementCssClassSet._classListOf(_element);
          return exports._ElementCssClassSet._classListToggle1(list, value);
        }
        static _toggleOnOff(_element, value, shouldAdd) {
          let list = exports._ElementCssClassSet._classListOf(_element);
          if (dart.notNull(shouldAdd)) {
            exports._ElementCssClassSet._classListAdd(list, value);
            return true;
          } else {
            exports._ElementCssClassSet._classListRemove(list, value);
            return false;
          }
        }
        static _addAll(_element, iterable) {
          let list = exports._ElementCssClassSet._classListOf(_element);
          for (let value of iterable) {
            exports._ElementCssClassSet._classListAdd(list, value);
          }
        }
        static _removeAll(_element, iterable) {
          let list = exports._ElementCssClassSet._classListOf(_element);
          for (let value of iterable) {
            exports._ElementCssClassSet._classListRemove(list, value);
          }
        }
        static _removeWhere(_element, test, doRemove) {
          let list = exports._ElementCssClassSet._classListOf(_element);
          let i = 0;
          while (i < dart.notNull(exports._ElementCssClassSet._classListLength(list))) {
            let item = list[dartx.item](i);
            if (doRemove == test(item)) {
              exports._ElementCssClassSet._classListRemove(list, item);
            } else {
              ++i;
            }
          }
        }
        static _classListOf(e) {
          return dart.as(e.classList, DomTokenList);
        }
        static _classListLength(list) {
          return dart.as(list.length, core.int);
        }
        static _classListContains(list, value) {
          return dart.as(list.contains(value), core.bool);
        }
        static _classListContainsBeforeAddOrRemove(list, value) {
          return dart.as(list.contains(value), core.bool);
        }
        static _classListAdd(list, value) {
          list.add(value);
        }
        static _classListRemove(list, value) {
          list.remove(value);
        }
        static _classListToggle1(list, value) {
          return list.toggle(value);
        }
        static _classListToggle2(list, value, shouldAdd) {
          return list.toggle(value, shouldAdd);
        }
      }
      dart.setSignature(_ElementCssClassSet, {
        constructors: () => ({_ElementCssClassSet: [exports._ElementCssClassSet, [Element]]}),
        methods: () => ({
          readClasses: [core.Set$(core.String), []],
          writeClasses: [dart.void, [core.Set$(core.String)]],
          removeAll: [dart.void, [core.Iterable$(core.String)]],
          retainAll: [dart.void, [core.Iterable$(core.String)]]
        }),
        statics: () => ({
          _contains: [core.bool, [Element, core.Object]],
          _add: [core.bool, [Element, core.String]],
          _remove: [core.bool, [Element, core.String]],
          _toggle: [core.bool, [Element, core.String, core.bool]],
          _toggleDefault: [core.bool, [Element, core.String]],
          _toggleOnOff: [core.bool, [Element, core.String, core.bool]],
          _addAll: [dart.void, [Element, core.Iterable$(core.String)]],
          _removeAll: [dart.void, [Element, core.Iterable$(core.String)]],
          _removeWhere: [dart.void, [Element, dart.functionType(core.bool, [core.String]), core.bool]],
          _classListOf: [DomTokenList, [Element]],
          _classListLength: [core.int, [DomTokenList]],
          _classListContains: [core.bool, [DomTokenList, core.String]],
          _classListContainsBeforeAddOrRemove: [core.bool, [DomTokenList, core.String]],
          _classListAdd: [dart.void, [DomTokenList, core.String]],
          _classListRemove: [dart.void, [DomTokenList, core.String]],
          _classListToggle1: [core.bool, [DomTokenList, core.String]],
          _classListToggle2: [core.bool, [DomTokenList, core.String, core.bool]]
        }),
        names: ['_contains', '_add', '_remove', '_toggle', '_toggleDefault', '_toggleOnOff', '_addAll', '_removeAll', '_removeWhere', '_classListOf', '_classListLength', '_classListContains', '_classListContainsBeforeAddOrRemove', '_classListAdd', '_classListRemove', '_classListToggle1', '_classListToggle2']
      });
      dart.defineExtensionMembers(_ElementCssClassSet, ['contains', 'length', 'isEmpty', 'isNotEmpty']);
      return _ElementCssClassSet;
    }
  });
  const _unit = Symbol('_unit');
  class Dimension extends core.Object {
    percent(value) {
      this[_value] = value;
      this[_unit] = '%';
    }
    px(value) {
      this[_value] = value;
      this[_unit] = 'px';
    }
    pc(value) {
      this[_value] = value;
      this[_unit] = 'pc';
    }
    pt(value) {
      this[_value] = value;
      this[_unit] = 'pt';
    }
    inch(value) {
      this[_value] = value;
      this[_unit] = 'in';
    }
    cm(value) {
      this[_value] = value;
      this[_unit] = 'cm';
    }
    mm(value) {
      this[_value] = value;
      this[_unit] = 'mm';
    }
    em(value) {
      this[_value] = value;
      this[_unit] = 'em';
    }
    ex(value) {
      this[_value] = value;
      this[_unit] = 'ex';
    }
    css(cssValue) {
      this[_value] = null;
      this[_unit] = null;
      if (cssValue == '') cssValue = '0px';
      if (dart.notNull(cssValue[dartx.endsWith]('%'))) {
        this[_unit] = '%';
      } else {
        this[_unit] = cssValue[dartx.substring](dart.notNull(cssValue[dartx.length]) - 2);
      }
      if (dart.notNull(cssValue[dartx.contains]('.'))) {
        this[_value] = core.double.parse(cssValue[dartx.substring](0, dart.notNull(cssValue[dartx.length]) - dart.notNull(this[_unit][dartx.length])));
      } else {
        this[_value] = core.int.parse(cssValue[dartx.substring](0, dart.notNull(cssValue[dartx.length]) - dart.notNull(this[_unit][dartx.length])));
      }
    }
    toString() {
      return `${this[_value]}${this[_unit]}`;
    }
    get value() {
      return this[_value];
    }
  }
  dart.defineNamedConstructor(Dimension, 'percent');
  dart.defineNamedConstructor(Dimension, 'px');
  dart.defineNamedConstructor(Dimension, 'pc');
  dart.defineNamedConstructor(Dimension, 'pt');
  dart.defineNamedConstructor(Dimension, 'inch');
  dart.defineNamedConstructor(Dimension, 'cm');
  dart.defineNamedConstructor(Dimension, 'mm');
  dart.defineNamedConstructor(Dimension, 'em');
  dart.defineNamedConstructor(Dimension, 'ex');
  dart.defineNamedConstructor(Dimension, 'css');
  dart.setSignature(Dimension, {
    constructors: () => ({
      percent: [Dimension, [core.num]],
      px: [Dimension, [core.num]],
      pc: [Dimension, [core.num]],
      pt: [Dimension, [core.num]],
      inch: [Dimension, [core.num]],
      cm: [Dimension, [core.num]],
      mm: [Dimension, [core.num]],
      em: [Dimension, [core.num]],
      ex: [Dimension, [core.num]],
      css: [Dimension, [core.String]]
    })
  });
  Dimension[dart.metadata] = () => [dart.const(new _metadata.Experimental())];
  const EventListener = dart.typedef('EventListener', () => dart.functionType(dart.dynamic, [Event]));
  const EventStreamProvider$ = dart.generic(function(T) {
    class EventStreamProvider extends core.Object {
      EventStreamProvider(eventType) {
        this[_eventType] = eventType;
      }
      forTarget(e, opts) {
        let useCapture = opts && 'useCapture' in opts ? opts.useCapture : false;
        return new (_EventStream$(T))(e, this[_eventType], useCapture);
      }
      forElement(e, opts) {
        let useCapture = opts && 'useCapture' in opts ? opts.useCapture : false;
        return new (_ElementEventStreamImpl$(T))(e, this[_eventType], useCapture);
      }
      [_forElementList](e, opts) {
        let useCapture = opts && 'useCapture' in opts ? opts.useCapture : false;
        return new (_ElementListEventStreamImpl$(T))(dart.as(e, core.Iterable$(Element)), this[_eventType], useCapture);
      }
      getEventType(target) {
        return this[_eventType];
      }
    }
    dart.setSignature(EventStreamProvider, {
      constructors: () => ({EventStreamProvider: [EventStreamProvider$(T), [core.String]]}),
      methods: () => ({
        forTarget: [async.Stream$(T), [EventTarget], {useCapture: core.bool}],
        forElement: [ElementStream$(T), [Element], {useCapture: core.bool}],
        [_forElementList]: [ElementStream$(T), [ElementList], {useCapture: core.bool}],
        getEventType: [core.String, [EventTarget]]
      })
    });
    return EventStreamProvider;
  });
  let EventStreamProvider = EventStreamProvider$();
  const ElementStream$ = dart.generic(function(T) {
    class ElementStream extends core.Object {}
    ElementStream[dart.implements] = () => [async.Stream$(T)];
    return ElementStream;
  });
  let ElementStream = ElementStream$();
  const _target = Symbol('_target');
  const _useCapture = Symbol('_useCapture');
  const _EventStream$ = dart.generic(function(T) {
    class _EventStream extends async.Stream$(T) {
      _EventStream(target, eventType, useCapture) {
        this[_target] = target;
        this[_eventType] = eventType;
        this[_useCapture] = useCapture;
        super.Stream();
      }
      asBroadcastStream(opts) {
        let onListen = opts && 'onListen' in opts ? opts.onListen : null;
        dart.as(onListen, dart.functionType(dart.void, [async.StreamSubscription]));
        let onCancel = opts && 'onCancel' in opts ? opts.onCancel : null;
        dart.as(onCancel, dart.functionType(dart.void, [async.StreamSubscription]));
        return this;
      }
      get isBroadcast() {
        return true;
      }
      listen(onData, opts) {
        dart.as(onData, dart.functionType(dart.void, [T]));
        let onError = opts && 'onError' in opts ? opts.onError : null;
        let onDone = opts && 'onDone' in opts ? opts.onDone : null;
        dart.as(onDone, dart.functionType(dart.void, []));
        let cancelOnError = opts && 'cancelOnError' in opts ? opts.cancelOnError : null;
        return new (_EventStreamSubscription$(T))(this[_target], this[_eventType], onData, this[_useCapture]);
      }
    }
    dart.setSignature(_EventStream, {
      constructors: () => ({_EventStream: [_EventStream$(T), [EventTarget, core.String, core.bool]]}),
      methods: () => ({
        asBroadcastStream: [async.Stream$(T), [], {onListen: dart.functionType(dart.void, [async.StreamSubscription]), onCancel: dart.functionType(dart.void, [async.StreamSubscription])}],
        listen: [async.StreamSubscription$(T), [dart.functionType(dart.void, [T])], {onError: core.Function, onDone: dart.functionType(dart.void, []), cancelOnError: core.bool}]
      })
    });
    return _EventStream;
  });
  let _EventStream = _EventStream$();
  const _ElementEventStreamImpl$ = dart.generic(function(T) {
    class _ElementEventStreamImpl extends _EventStream$(T) {
      _ElementEventStreamImpl(target, eventType, useCapture) {
        super._EventStream(dart.as(target, EventTarget), dart.as(eventType, core.String), dart.as(useCapture, core.bool));
      }
      matches(selector) {
        return this.where(dart.fn(event => {
          dart.as(event, T);
          return dart.as(dart.dcall(event[dartx.target][dartx.matchesWithAncestors], selector), core.bool);
        }, core.bool, [T])).map(dart.fn(e => {
          dart.as(e, T);
          e[_selector] = selector;
          return e;
        }, T, [T]));
      }
      capture(onData) {
        dart.as(onData, dart.functionType(dart.void, [T]));
        return new (_EventStreamSubscription$(T))(this[_target], this[_eventType], onData, true);
      }
    }
    _ElementEventStreamImpl[dart.implements] = () => [ElementStream$(T)];
    dart.setSignature(_ElementEventStreamImpl, {
      constructors: () => ({_ElementEventStreamImpl: [_ElementEventStreamImpl$(T), [dart.dynamic, dart.dynamic, dart.dynamic]]}),
      methods: () => ({
        matches: [async.Stream$(T), [core.String]],
        capture: [async.StreamSubscription$(T), [dart.functionType(dart.void, [T])]]
      })
    });
    return _ElementEventStreamImpl;
  });
  let _ElementEventStreamImpl = _ElementEventStreamImpl$();
  const _targetList = Symbol('_targetList');
  const _ElementListEventStreamImpl$ = dart.generic(function(T) {
    class _ElementListEventStreamImpl extends async.Stream$(T) {
      _ElementListEventStreamImpl(targetList, eventType, useCapture) {
        this[_targetList] = targetList;
        this[_eventType] = eventType;
        this[_useCapture] = useCapture;
        super.Stream();
      }
      matches(selector) {
        return this.where(dart.fn(event => {
          dart.as(event, T);
          return dart.as(dart.dcall(event[dartx.target][dartx.matchesWithAncestors], selector), core.bool);
        }, core.bool, [T])).map(dart.fn(e => {
          dart.as(e, T);
          e[_selector] = selector;
          return e;
        }, T, [T]));
      }
      listen(onData, opts) {
        dart.as(onData, dart.functionType(dart.void, [T]));
        let onError = opts && 'onError' in opts ? opts.onError : null;
        let onDone = opts && 'onDone' in opts ? opts.onDone : null;
        dart.as(onDone, dart.functionType(dart.void, []));
        let cancelOnError = opts && 'cancelOnError' in opts ? opts.cancelOnError : null;
        let pool = new _StreamPool.broadcast();
        for (let target of this[_targetList]) {
          pool.add(new _EventStream(target, this[_eventType], this[_useCapture]));
        }
        return dart.as(pool.stream.listen(onData, {onError: onError, onDone: onDone, cancelOnError: cancelOnError}), async.StreamSubscription$(T));
      }
      capture(onData) {
        dart.as(onData, dart.functionType(dart.void, [T]));
        let pool = new _StreamPool.broadcast();
        for (let target of this[_targetList]) {
          pool.add(new _EventStream(target, this[_eventType], true));
        }
        return dart.as(pool.stream.listen(onData), async.StreamSubscription$(T));
      }
      asBroadcastStream(opts) {
        let onListen = opts && 'onListen' in opts ? opts.onListen : null;
        dart.as(onListen, dart.functionType(dart.void, [async.StreamSubscription]));
        let onCancel = opts && 'onCancel' in opts ? opts.onCancel : null;
        dart.as(onCancel, dart.functionType(dart.void, [async.StreamSubscription]));
        return this;
      }
      get isBroadcast() {
        return true;
      }
    }
    _ElementListEventStreamImpl[dart.implements] = () => [ElementStream$(T)];
    dart.setSignature(_ElementListEventStreamImpl, {
      constructors: () => ({_ElementListEventStreamImpl: [_ElementListEventStreamImpl$(T), [core.Iterable$(Element), core.String, core.bool]]}),
      methods: () => ({
        matches: [async.Stream$(T), [core.String]],
        listen: [async.StreamSubscription$(T), [dart.functionType(dart.void, [T])], {onError: core.Function, onDone: dart.functionType(dart.void, []), cancelOnError: core.bool}],
        capture: [async.StreamSubscription$(T), [dart.functionType(dart.void, [T])]],
        asBroadcastStream: [async.Stream$(T), [], {onListen: dart.functionType(dart.void, [async.StreamSubscription]), onCancel: dart.functionType(dart.void, [async.StreamSubscription])}]
      })
    });
    return _ElementListEventStreamImpl;
  });
  let _ElementListEventStreamImpl = _ElementListEventStreamImpl$();
  const _onData = Symbol('_onData');
  const _pauseCount = Symbol('_pauseCount');
  const _tryResume = Symbol('_tryResume');
  const _canceled = Symbol('_canceled');
  const _unlisten = Symbol('_unlisten');
  const _EventStreamSubscription$ = dart.generic(function(T) {
    class _EventStreamSubscription extends async.StreamSubscription$(T) {
      _EventStreamSubscription(target, eventType, onData, useCapture) {
        this[_target] = target;
        this[_eventType] = eventType;
        this[_useCapture] = useCapture;
        this[_onData] = _wrapZone(dart.as(onData, __CastType2));
        this[_pauseCount] = 0;
        this[_tryResume]();
      }
      cancel() {
        if (dart.notNull(this[_canceled])) return null;
        this[_unlisten]();
        this[_target] = null;
        this[_onData] = null;
        return null;
      }
      get [_canceled]() {
        return this[_target] == null;
      }
      onData(handleData) {
        dart.as(handleData, dart.functionType(dart.void, [T]));
        if (dart.notNull(this[_canceled])) {
          dart.throw(new core.StateError("Subscription has been canceled."));
        }
        this[_unlisten]();
        this[_onData] = _wrapZone(handleData);
        this[_tryResume]();
      }
      onError(handleError) {}
      onDone(handleDone) {
        dart.as(handleDone, dart.functionType(dart.void, []));
      }
      pause(resumeSignal) {
        if (resumeSignal === void 0) resumeSignal = null;
        if (dart.notNull(this[_canceled])) return;
        this[_pauseCount] = dart.notNull(this[_pauseCount]) + 1;
        this[_unlisten]();
        if (resumeSignal != null) {
          resumeSignal.whenComplete(dart.bind(this, 'resume'));
        }
      }
      get isPaused() {
        return dart.notNull(this[_pauseCount]) > 0;
      }
      resume() {
        if (dart.notNull(this[_canceled]) || !dart.notNull(this.isPaused)) return;
        this[_pauseCount] = dart.notNull(this[_pauseCount]) - 1;
        this[_tryResume]();
      }
      [_tryResume]() {
        if (this[_onData] != null && !dart.notNull(this.isPaused)) {
          this[_target][dartx.addEventListener](this[_eventType], dart.as(this[_onData], EventListener), this[_useCapture]);
        }
      }
      [_unlisten]() {
        if (this[_onData] != null) {
          this[_target][dartx.removeEventListener](this[_eventType], dart.as(this[_onData], EventListener), this[_useCapture]);
        }
      }
      asFuture(futureValue) {
        if (futureValue === void 0) futureValue = null;
        let completer = async.Completer.new();
        return completer.future;
      }
    }
    dart.setSignature(_EventStreamSubscription, {
      constructors: () => ({_EventStreamSubscription: [_EventStreamSubscription$(T), [EventTarget, core.String, dart.dynamic, core.bool]]}),
      methods: () => ({
        cancel: [async.Future, []],
        onData: [dart.void, [dart.functionType(dart.void, [T])]],
        onError: [dart.void, [core.Function]],
        onDone: [dart.void, [dart.functionType(dart.void, [])]],
        pause: [dart.void, [], [async.Future]],
        resume: [dart.void, []],
        [_tryResume]: [dart.void, []],
        [_unlisten]: [dart.void, []],
        asFuture: [async.Future, [], [dart.dynamic]]
      })
    });
    return _EventStreamSubscription;
  });
  let _EventStreamSubscription = _EventStreamSubscription$();
  const CustomStream$ = dart.generic(function(T) {
    class CustomStream extends core.Object {}
    CustomStream[dart.implements] = () => [async.Stream$(T)];
    return CustomStream;
  });
  let CustomStream = CustomStream$();
  const _streamController = Symbol('_streamController');
  const _type = Symbol('_type');
  const _CustomEventStreamImpl$ = dart.generic(function(T) {
    class _CustomEventStreamImpl extends async.Stream$(T) {
      _CustomEventStreamImpl(type) {
        this[_streamController] = null;
        this[_type] = null;
        super.Stream();
        this[_type] = type;
        this[_streamController] = async.StreamController$(T).broadcast({sync: true});
      }
      listen(onData, opts) {
        dart.as(onData, dart.functionType(dart.void, [T]));
        let onError = opts && 'onError' in opts ? opts.onError : null;
        let onDone = opts && 'onDone' in opts ? opts.onDone : null;
        dart.as(onDone, dart.functionType(dart.void, []));
        let cancelOnError = opts && 'cancelOnError' in opts ? opts.cancelOnError : null;
        return this[_streamController].stream.listen(onData, {onError: onError, onDone: onDone, cancelOnError: cancelOnError});
      }
      asBroadcastStream(opts) {
        let onListen = opts && 'onListen' in opts ? opts.onListen : null;
        dart.as(onListen, dart.functionType(dart.void, [async.StreamSubscription]));
        let onCancel = opts && 'onCancel' in opts ? opts.onCancel : null;
        dart.as(onCancel, dart.functionType(dart.void, [async.StreamSubscription]));
        return this[_streamController].stream;
      }
      get isBroadcast() {
        return true;
      }
      add(event) {
        dart.as(event, T);
        if (event[dartx.type] == this[_type]) this[_streamController].add(event);
      }
    }
    _CustomEventStreamImpl[dart.implements] = () => [CustomStream$(T)];
    dart.setSignature(_CustomEventStreamImpl, {
      constructors: () => ({_CustomEventStreamImpl: [_CustomEventStreamImpl$(T), [core.String]]}),
      methods: () => ({
        listen: [async.StreamSubscription$(T), [dart.functionType(dart.void, [T])], {onError: core.Function, onDone: dart.functionType(dart.void, []), cancelOnError: core.bool}],
        asBroadcastStream: [async.Stream$(T), [], {onListen: dart.functionType(dart.void, [async.StreamSubscription]), onCancel: dart.functionType(dart.void, [async.StreamSubscription])}],
        add: [dart.void, [T]]
      })
    });
    return _CustomEventStreamImpl;
  });
  let _CustomEventStreamImpl = _CustomEventStreamImpl$();
  const _shadowKeyCode = Symbol('_shadowKeyCode');
  const _shadowCharCode = Symbol('_shadowCharCode');
  const _shadowAltKey = Symbol('_shadowAltKey');
  const _parent = Symbol('_parent');
  const _realKeyCode = Symbol('_realKeyCode');
  const _realCharCode = Symbol('_realCharCode');
  const _realAltKey = Symbol('_realAltKey');
  const _currentTarget = Symbol('_currentTarget');
  const _shadowKeyIdentifier = Symbol('_shadowKeyIdentifier');
  class KeyEvent extends _WrappedEvent {
    get keyCode() {
      return this[_shadowKeyCode];
    }
    get charCode() {
      return this.type == 'keypress' ? this[_shadowCharCode] : 0;
    }
    get altKey() {
      return this[_shadowAltKey];
    }
    get which() {
      return this.keyCode;
    }
    get [_realKeyCode]() {
      return this[_parent].keyCode;
    }
    get [_realCharCode]() {
      return this[_parent].charCode;
    }
    get [_realAltKey]() {
      return this[_parent].altKey;
    }
    static _makeRecord() {
      let interceptor = _foreign_helper.JS_INTERCEPTOR_CONSTANT(KeyboardEvent);
      return dart.dcall(/* Unimplemented unknown name */makeLeafDispatchRecord, interceptor);
    }
    wrap(parent) {
      this[_parent] = null;
      this[_shadowAltKey] = null;
      this[_shadowCharCode] = null;
      this[_shadowKeyCode] = null;
      this[_currentTarget] = null;
      super._WrappedEvent(parent);
      this[_parent] = parent;
      this[_shadowAltKey] = this[_realAltKey];
      this[_shadowCharCode] = this[_realCharCode];
      this[_shadowKeyCode] = this[_realKeyCode];
      this[_currentTarget] = this[_parent][dartx.currentTarget];
    }
    static new(type, opts) {
      let view = opts && 'view' in opts ? opts.view : null;
      let canBubble = opts && 'canBubble' in opts ? opts.canBubble : true;
      let cancelable = opts && 'cancelable' in opts ? opts.cancelable : true;
      let keyCode = opts && 'keyCode' in opts ? opts.keyCode : 0;
      let charCode = opts && 'charCode' in opts ? opts.charCode : 0;
      let keyLocation = opts && 'keyLocation' in opts ? opts.keyLocation : 1;
      let ctrlKey = opts && 'ctrlKey' in opts ? opts.ctrlKey : false;
      let altKey = opts && 'altKey' in opts ? opts.altKey : false;
      let shiftKey = opts && 'shiftKey' in opts ? opts.shiftKey : false;
      let metaKey = opts && 'metaKey' in opts ? opts.metaKey : false;
      let currentTarget = opts && 'currentTarget' in opts ? opts.currentTarget : null;
      if (view == null) {
        view = exports.window;
      }
      let eventObj = null;
      if (dart.notNull(KeyEvent.canUseDispatchEvent)) {
        eventObj = Event.eventType('Event', type, {canBubble: canBubble, cancelable: cancelable});
        eventObj.keyCode = keyCode;
        eventObj.which = keyCode;
        eventObj.charCode = charCode;
        eventObj.keyLocation = keyLocation;
        eventObj.ctrlKey = ctrlKey;
        eventObj.altKey = altKey;
        eventObj.shiftKey = shiftKey;
        eventObj.metaKey = metaKey;
      } else {
        eventObj = Event.eventType('KeyboardEvent', type, {canBubble: canBubble, cancelable: cancelable});
        Object.defineProperty(eventObj, 'keyCode', {
          get: function() {
            return this.keyCodeVal;
          }
        });
        Object.defineProperty(eventObj, 'which', {
          get: function() {
            return this.keyCodeVal;
          }
        });
        Object.defineProperty(eventObj, 'charCode', {
          get: function() {
            return this.charCodeVal;
          }
        });
        let keyIdentifier = KeyEvent._convertToHexString(charCode, keyCode);
        dart.dsend(eventObj, _initKeyboardEvent, type, canBubble, cancelable, view, keyIdentifier, keyLocation, ctrlKey, altKey, shiftKey, metaKey);
        eventObj.keyCodeVal = keyCode;
        eventObj.charCodeVal = charCode;
      }
      dart.dcall(/* Unimplemented unknown name */setDispatchProperty, eventObj, KeyEvent._keyboardEventDispatchRecord);
      let keyEvent = new KeyEvent.wrap(dart.as(eventObj, KeyboardEvent));
      if (keyEvent[_currentTarget] == null) {
        keyEvent[_currentTarget] = currentTarget == null ? exports.window : currentTarget;
      }
      return keyEvent;
    }
    static get canUseDispatchEvent() {
      return typeof document.body.dispatchEvent == "function" && document.body.dispatchEvent.length > 0;
    }
    get currentTarget() {
      return this[_currentTarget];
    }
    static _convertToHexString(charCode, keyCode) {
      if (charCode != -1) {
        let hex = charCode[dartx.toRadixString](16);
        let sb = new core.StringBuffer('U+');
        for (let i = 0; i < 4 - dart.notNull(hex[dartx.length]); i++)
          sb.write('0');
        sb.write(hex);
        return sb.toString();
      } else {
        return KeyCode._convertKeyCodeToKeyName(keyCode);
      }
    }
    get clipboardData() {
      return this[_parent][dartx.clipboardData];
    }
    get ctrlKey() {
      return this[_parent][dartx.ctrlKey];
    }
    get detail() {
      return this[_parent][dartx.detail];
    }
    get keyLocation() {
      return this[_parent][dartx.keyLocation];
    }
    get layer() {
      return this[_parent][dartx.layer];
    }
    get metaKey() {
      return this[_parent][dartx.metaKey];
    }
    get page() {
      return this[_parent][dartx.page];
    }
    get shiftKey() {
      return this[_parent][dartx.shiftKey];
    }
    get view() {
      return dart.as(this[_parent][dartx.view], Window);
    }
    [_initUIEvent](type, canBubble, cancelable, view, detail) {
      dart.throw(new core.UnsupportedError("Cannot initialize a UI Event from a KeyEvent."));
    }
    get [_shadowKeyIdentifier]() {
      return this[_parent].keyIdentifier;
    }
    get [_charCode]() {
      return this.charCode;
    }
    get [_keyCode]() {
      return this.keyCode;
    }
    get [_keyIdentifier]() {
      dart.throw(new core.UnsupportedError("keyIdentifier is unsupported."));
    }
    [_initKeyboardEvent](type, canBubble, cancelable, view, keyIdentifier, keyLocation, ctrlKey, altKey, shiftKey, metaKey) {
      dart.throw(new core.UnsupportedError("Cannot initialize a KeyboardEvent from a KeyEvent."));
    }
    get [_layerX]() {
      return dart.throw(new core.UnsupportedError('Not applicable to KeyEvent'));
    }
    get [_layerY]() {
      return dart.throw(new core.UnsupportedError('Not applicable to KeyEvent'));
    }
    get [_pageX]() {
      return dart.throw(new core.UnsupportedError('Not applicable to KeyEvent'));
    }
    get [_pageY]() {
      return dart.throw(new core.UnsupportedError('Not applicable to KeyEvent'));
    }
    getModifierState(keyArgument) {
      return dart.throw(new core.UnimplementedError());
    }
    get location() {
      return dart.throw(new core.UnimplementedError());
    }
    get repeat() {
      return dart.throw(new core.UnimplementedError());
    }
    get [_get_view]() {
      return dart.throw(new core.UnimplementedError());
    }
  }
  KeyEvent[dart.implements] = () => [KeyboardEvent];
  dart.defineNamedConstructor(KeyEvent, 'wrap');
  dart.setSignature(KeyEvent, {
    constructors: () => ({
      wrap: [KeyEvent, [KeyboardEvent]],
      new: [KeyEvent, [core.String], {view: Window, canBubble: core.bool, cancelable: core.bool, keyCode: core.int, charCode: core.int, keyLocation: core.int, ctrlKey: core.bool, altKey: core.bool, shiftKey: core.bool, metaKey: core.bool, currentTarget: EventTarget}]
    }),
    methods: () => ({
      [_initUIEvent]: [dart.void, [core.String, core.bool, core.bool, Window, core.int]],
      [_initKeyboardEvent]: [dart.void, [core.String, core.bool, core.bool, Window, core.String, core.int, core.bool, core.bool, core.bool, core.bool]],
      getModifierState: [core.bool, [core.String]]
    }),
    statics: () => ({
      _makeRecord: [dart.dynamic, []],
      _convertToHexString: [core.String, [core.int, core.int]]
    }),
    names: ['_makeRecord', '_convertToHexString']
  });
  dart.defineExtensionMembers(KeyEvent, [
    _initUIEvent,
    _initKeyboardEvent,
    'getModifierState',
    'keyCode',
    'charCode',
    'altKey',
    'which',
    'currentTarget',
    'clipboardData',
    'ctrlKey',
    'detail',
    'keyLocation',
    'layer',
    'metaKey',
    'page',
    'shiftKey',
    'view',
    _charCode,
    _keyCode,
    _keyIdentifier,
    _layerX,
    _layerY,
    _pageX,
    _pageY,
    'location',
    'repeat',
    _get_view
  ]);
  KeyEvent[dart.metadata] = () => [dart.const(new _metadata.Experimental())];
  dart.defineLazyProperties(KeyEvent, {
    get _keyboardEventDispatchRecord() {
      return KeyEvent._makeRecord();
    },
    get keyDownEvent() {
      return new _KeyboardEventHandler('keydown');
    },
    set keyDownEvent(_) {},
    get keyUpEvent() {
      return new _KeyboardEventHandler('keyup');
    },
    set keyUpEvent(_) {},
    get keyPressEvent() {
      return new _KeyboardEventHandler('keypress');
    },
    set keyPressEvent(_) {}
  });
  class _CustomKeyEventStreamImpl extends _CustomEventStreamImpl$(KeyEvent) {
    _CustomKeyEventStreamImpl(type) {
      super._CustomEventStreamImpl(type);
    }
    add(event) {
      if (event.type == this[_type]) {
        event.currentTarget[dartx.dispatchEvent](event[_parent]);
        this[_streamController].add(event);
      }
    }
  }
  _CustomKeyEventStreamImpl[dart.implements] = () => [CustomStream$(KeyEvent)];
  dart.setSignature(_CustomKeyEventStreamImpl, {
    constructors: () => ({_CustomKeyEventStreamImpl: [_CustomKeyEventStreamImpl, [core.String]]}),
    methods: () => ({add: [dart.void, [KeyEvent]]})
  });
  const _subscriptions = Symbol('_subscriptions');
  const _controller = Symbol('_controller');
  const _StreamPool$ = dart.generic(function(T) {
    class _StreamPool extends core.Object {
      broadcast() {
        this[_subscriptions] = core.Map$(async.Stream$(T), async.StreamSubscription$(T)).new();
        this[_controller] = null;
        this[_controller] = async.StreamController$(T).broadcast({sync: true, onCancel: dart.bind(this, 'close')});
      }
      get stream() {
        return this[_controller].stream;
      }
      add(stream) {
        dart.as(stream, async.Stream$(T));
        if (dart.notNull(this[_subscriptions][dartx.containsKey](stream))) return;
        this[_subscriptions][dartx.set](stream, stream.listen(dart.bind(this[_controller], 'add'), {onError: dart.bind(this[_controller], 'addError'), onDone: dart.fn(() => this.remove(stream), dart.void, [])}));
      }
      remove(stream) {
        dart.as(stream, async.Stream$(T));
        let subscription = this[_subscriptions][dartx.remove](stream);
        if (subscription != null) subscription.cancel();
      }
      close() {
        for (let subscription of this[_subscriptions][dartx.values]) {
          subscription.cancel();
        }
        this[_subscriptions][dartx.clear]();
        this[_controller].close();
      }
    }
    dart.defineNamedConstructor(_StreamPool, 'broadcast');
    dart.setSignature(_StreamPool, {
      constructors: () => ({broadcast: [_StreamPool$(T), []]}),
      methods: () => ({
        add: [dart.void, [async.Stream$(T)]],
        remove: [dart.void, [async.Stream$(T)]],
        close: [dart.void, []]
      })
    });
    return _StreamPool;
  });
  let _StreamPool = _StreamPool$();
  const _eventTypeGetter = Symbol('_eventTypeGetter');
  const _CustomEventStreamProvider$ = dart.generic(function(T) {
    class _CustomEventStreamProvider extends core.Object {
      _CustomEventStreamProvider(eventTypeGetter) {
        this[_eventTypeGetter] = eventTypeGetter;
      }
      forTarget(e, opts) {
        let useCapture = opts && 'useCapture' in opts ? opts.useCapture : false;
        return new (_EventStream$(T))(e, dart.as(dart.dcall(this[_eventTypeGetter], e), core.String), useCapture);
      }
      forElement(e, opts) {
        let useCapture = opts && 'useCapture' in opts ? opts.useCapture : false;
        return new (_ElementEventStreamImpl$(T))(e, dart.dcall(this[_eventTypeGetter], e), useCapture);
      }
      [_forElementList](e, opts) {
        let useCapture = opts && 'useCapture' in opts ? opts.useCapture : false;
        return new (_ElementListEventStreamImpl$(T))(dart.as(e, core.Iterable$(Element)), dart.as(dart.dcall(this[_eventTypeGetter], e), core.String), useCapture);
      }
      getEventType(target) {
        return dart.as(dart.dcall(this[_eventTypeGetter], target), core.String);
      }
      get [_eventType]() {
        return dart.throw(new core.UnsupportedError('Access type through getEventType method.'));
      }
    }
    _CustomEventStreamProvider[dart.implements] = () => [EventStreamProvider$(T)];
    dart.setSignature(_CustomEventStreamProvider, {
      constructors: () => ({_CustomEventStreamProvider: [_CustomEventStreamProvider$(T), [dart.dynamic]]}),
      methods: () => ({
        forTarget: [async.Stream$(T), [EventTarget], {useCapture: core.bool}],
        forElement: [ElementStream$(T), [Element], {useCapture: core.bool}],
        [_forElementList]: [ElementStream$(T), [ElementList], {useCapture: core.bool}],
        getEventType: [core.String, [EventTarget]]
      })
    });
    return _CustomEventStreamProvider;
  });
  let _CustomEventStreamProvider = _CustomEventStreamProvider$();
  class _Html5NodeValidator extends core.Object {
    _Html5NodeValidator(opts) {
      let uriPolicy = opts && 'uriPolicy' in opts ? opts.uriPolicy : null;
      this.uriPolicy = uriPolicy != null ? uriPolicy : UriPolicy.new();
      if (dart.notNull(_Html5NodeValidator._attributeValidators[dartx.isEmpty])) {
        for (let attr of _Html5NodeValidator._standardAttributes) {
          _Html5NodeValidator._attributeValidators[dartx.set](attr, _Html5NodeValidator._standardAttributeValidator);
        }
        for (let attr of _Html5NodeValidator._uriAttributes) {
          _Html5NodeValidator._attributeValidators[dartx.set](attr, _Html5NodeValidator._uriAttributeValidator);
        }
      }
    }
    allowsElement(element) {
      return _Html5NodeValidator._allowedElements.contains(Element._safeTagName(element));
    }
    allowsAttribute(element, attributeName, value) {
      let tagName = Element._safeTagName(element);
      let validator = _Html5NodeValidator._attributeValidators[dartx.get](`${tagName}::${attributeName}`);
      if (validator == null) {
        validator = _Html5NodeValidator._attributeValidators[dartx.get](`*::${attributeName}`);
      }
      if (validator == null) {
        return false;
      }
      return dart.as(dart.dcall(validator, element, attributeName, value, this), core.bool);
    }
    static _standardAttributeValidator(element, attributeName, value, context) {
      return true;
    }
    static _uriAttributeValidator(element, attributeName, value, context) {
      return context.uriPolicy.allowsUri(value);
    }
  }
  _Html5NodeValidator[dart.implements] = () => [NodeValidator];
  dart.setSignature(_Html5NodeValidator, {
    constructors: () => ({_Html5NodeValidator: [_Html5NodeValidator, [], {uriPolicy: UriPolicy}]}),
    methods: () => ({
      allowsElement: [core.bool, [Element]],
      allowsAttribute: [core.bool, [Element, core.String, core.String]]
    }),
    statics: () => ({
      _standardAttributeValidator: [core.bool, [Element, core.String, core.String, _Html5NodeValidator]],
      _uriAttributeValidator: [core.bool, [Element, core.String, core.String, _Html5NodeValidator]]
    }),
    names: ['_standardAttributeValidator', '_uriAttributeValidator']
  });
  _Html5NodeValidator._standardAttributes = dart.const(dart.list(['*::class', '*::dir', '*::draggable', '*::hidden', '*::id', '*::inert', '*::itemprop', '*::itemref', '*::itemscope', '*::lang', '*::spellcheck', '*::title', '*::translate', 'A::accesskey', 'A::coords', 'A::hreflang', 'A::name', 'A::shape', 'A::tabindex', 'A::target', 'A::type', 'AREA::accesskey', 'AREA::alt', 'AREA::coords', 'AREA::nohref', 'AREA::shape', 'AREA::tabindex', 'AREA::target', 'AUDIO::controls', 'AUDIO::loop', 'AUDIO::mediagroup', 'AUDIO::muted', 'AUDIO::preload', 'BDO::dir', 'BODY::alink', 'BODY::bgcolor', 'BODY::link', 'BODY::text', 'BODY::vlink', 'BR::clear', 'BUTTON::accesskey', 'BUTTON::disabled', 'BUTTON::name', 'BUTTON::tabindex', 'BUTTON::type', 'BUTTON::value', 'CANVAS::height', 'CANVAS::width', 'CAPTION::align', 'COL::align', 'COL::char', 'COL::charoff', 'COL::span', 'COL::valign', 'COL::width', 'COLGROUP::align', 'COLGROUP::char', 'COLGROUP::charoff', 'COLGROUP::span', 'COLGROUP::valign', 'COLGROUP::width', 'COMMAND::checked', 'COMMAND::command', 'COMMAND::disabled', 'COMMAND::label', 'COMMAND::radiogroup', 'COMMAND::type', 'DATA::value', 'DEL::datetime', 'DETAILS::open', 'DIR::compact', 'DIV::align', 'DL::compact', 'FIELDSET::disabled', 'FONT::color', 'FONT::face', 'FONT::size', 'FORM::accept', 'FORM::autocomplete', 'FORM::enctype', 'FORM::method', 'FORM::name', 'FORM::novalidate', 'FORM::target', 'FRAME::name', 'H1::align', 'H2::align', 'H3::align', 'H4::align', 'H5::align', 'H6::align', 'HR::align', 'HR::noshade', 'HR::size', 'HR::width', 'HTML::version', 'IFRAME::align', 'IFRAME::frameborder', 'IFRAME::height', 'IFRAME::marginheight', 'IFRAME::marginwidth', 'IFRAME::width', 'IMG::align', 'IMG::alt', 'IMG::border', 'IMG::height', 'IMG::hspace', 'IMG::ismap', 'IMG::name', 'IMG::usemap', 'IMG::vspace', 'IMG::width', 'INPUT::accept', 'INPUT::accesskey', 'INPUT::align', 'INPUT::alt', 'INPUT::autocomplete', 'INPUT::autofocus', 'INPUT::checked', 'INPUT::disabled', 'INPUT::inputmode', 'INPUT::ismap', 'INPUT::list', 'INPUT::max', 'INPUT::maxlength', 'INPUT::min', 'INPUT::multiple', 'INPUT::name', 'INPUT::placeholder', 'INPUT::readonly', 'INPUT::required', 'INPUT::size', 'INPUT::step', 'INPUT::tabindex', 'INPUT::type', 'INPUT::usemap', 'INPUT::value', 'INS::datetime', 'KEYGEN::disabled', 'KEYGEN::keytype', 'KEYGEN::name', 'LABEL::accesskey', 'LABEL::for', 'LEGEND::accesskey', 'LEGEND::align', 'LI::type', 'LI::value', 'LINK::sizes', 'MAP::name', 'MENU::compact', 'MENU::label', 'MENU::type', 'METER::high', 'METER::low', 'METER::max', 'METER::min', 'METER::value', 'OBJECT::typemustmatch', 'OL::compact', 'OL::reversed', 'OL::start', 'OL::type', 'OPTGROUP::disabled', 'OPTGROUP::label', 'OPTION::disabled', 'OPTION::label', 'OPTION::selected', 'OPTION::value', 'OUTPUT::for', 'OUTPUT::name', 'P::align', 'PRE::width', 'PROGRESS::max', 'PROGRESS::min', 'PROGRESS::value', 'SELECT::autocomplete', 'SELECT::disabled', 'SELECT::multiple', 'SELECT::name', 'SELECT::required', 'SELECT::size', 'SELECT::tabindex', 'SOURCE::type', 'TABLE::align', 'TABLE::bgcolor', 'TABLE::border', 'TABLE::cellpadding', 'TABLE::cellspacing', 'TABLE::frame', 'TABLE::rules', 'TABLE::summary', 'TABLE::width', 'TBODY::align', 'TBODY::char', 'TBODY::charoff', 'TBODY::valign', 'TD::abbr', 'TD::align', 'TD::axis', 'TD::bgcolor', 'TD::char', 'TD::charoff', 'TD::colspan', 'TD::headers', 'TD::height', 'TD::nowrap', 'TD::rowspan', 'TD::scope', 'TD::valign', 'TD::width', 'TEXTAREA::accesskey', 'TEXTAREA::autocomplete', 'TEXTAREA::cols', 'TEXTAREA::disabled', 'TEXTAREA::inputmode', 'TEXTAREA::name', 'TEXTAREA::placeholder', 'TEXTAREA::readonly', 'TEXTAREA::required', 'TEXTAREA::rows', 'TEXTAREA::tabindex', 'TEXTAREA::wrap', 'TFOOT::align', 'TFOOT::char', 'TFOOT::charoff', 'TFOOT::valign', 'TH::abbr', 'TH::align', 'TH::axis', 'TH::bgcolor', 'TH::char', 'TH::charoff', 'TH::colspan', 'TH::headers', 'TH::height', 'TH::nowrap', 'TH::rowspan', 'TH::scope', 'TH::valign', 'TH::width', 'THEAD::align', 'THEAD::char', 'THEAD::charoff', 'THEAD::valign', 'TR::align', 'TR::bgcolor', 'TR::char', 'TR::charoff', 'TR::valign', 'TRACK::default', 'TRACK::kind', 'TRACK::label', 'TRACK::srclang', 'UL::compact', 'UL::type', 'VIDEO::controls', 'VIDEO::height', 'VIDEO::loop', 'VIDEO::mediagroup', 'VIDEO::muted', 'VIDEO::preload', 'VIDEO::width'], core.String));
  _Html5NodeValidator._uriAttributes = dart.const(dart.list(['A::href', 'AREA::href', 'BLOCKQUOTE::cite', 'BODY::background', 'COMMAND::icon', 'DEL::cite', 'FORM::action', 'IMG::src', 'INPUT::src', 'INS::cite', 'Q::cite', 'VIDEO::poster'], core.String));
  dart.defineLazyProperties(_Html5NodeValidator, {
    get _allowedElements() {
      return core.Set$(core.String).from(dart.list(['A', 'ABBR', 'ACRONYM', 'ADDRESS', 'AREA', 'ARTICLE', 'ASIDE', 'AUDIO', 'B', 'BDI', 'BDO', 'BIG', 'BLOCKQUOTE', 'BR', 'BUTTON', 'CANVAS', 'CAPTION', 'CENTER', 'CITE', 'CODE', 'COL', 'COLGROUP', 'COMMAND', 'DATA', 'DATALIST', 'DD', 'DEL', 'DETAILS', 'DFN', 'DIR', 'DIV', 'DL', 'DT', 'EM', 'FIELDSET', 'FIGCAPTION', 'FIGURE', 'FONT', 'FOOTER', 'FORM', 'H1', 'H2', 'H3', 'H4', 'H5', 'H6', 'HEADER', 'HGROUP', 'HR', 'I', 'IFRAME', 'IMG', 'INPUT', 'INS', 'KBD', 'LABEL', 'LEGEND', 'LI', 'MAP', 'MARK', 'MENU', 'METER', 'NAV', 'NOBR', 'OL', 'OPTGROUP', 'OPTION', 'OUTPUT', 'P', 'PRE', 'PROGRESS', 'Q', 'S', 'SAMP', 'SECTION', 'SELECT', 'SMALL', 'SOURCE', 'SPAN', 'STRIKE', 'STRONG', 'SUB', 'SUMMARY', 'SUP', 'TABLE', 'TBODY', 'TD', 'TEXTAREA', 'TFOOT', 'TH', 'THEAD', 'TIME', 'TR', 'TRACK', 'TT', 'U', 'UL', 'VAR', 'VIDEO', 'WBR'], core.String));
    },
    get _attributeValidators() {
      return dart.map();
    }
  });
  class KeyCode extends core.Object {
    static isCharacterKey(keyCode) {
      if (dart.notNull(keyCode) >= dart.notNull(KeyCode.ZERO) && dart.notNull(keyCode) <= dart.notNull(KeyCode.NINE) || dart.notNull(keyCode) >= dart.notNull(KeyCode.NUM_ZERO) && dart.notNull(keyCode) <= dart.notNull(KeyCode.NUM_MULTIPLY) || dart.notNull(keyCode) >= dart.notNull(KeyCode.A) && dart.notNull(keyCode) <= dart.notNull(KeyCode.Z)) {
        return true;
      }
      if (dart.notNull(html_common.Device.isWebKit) && keyCode == 0) {
        return true;
      }
      return keyCode == KeyCode.SPACE || keyCode == KeyCode.QUESTION_MARK || keyCode == KeyCode.NUM_PLUS || keyCode == KeyCode.NUM_MINUS || keyCode == KeyCode.NUM_PERIOD || keyCode == KeyCode.NUM_DIVISION || keyCode == KeyCode.SEMICOLON || keyCode == KeyCode.FF_SEMICOLON || keyCode == KeyCode.DASH || keyCode == KeyCode.EQUALS || keyCode == KeyCode.FF_EQUALS || keyCode == KeyCode.COMMA || keyCode == KeyCode.PERIOD || keyCode == KeyCode.SLASH || keyCode == KeyCode.APOSTROPHE || keyCode == KeyCode.SINGLE_QUOTE || keyCode == KeyCode.OPEN_SQUARE_BRACKET || keyCode == KeyCode.BACKSLASH || keyCode == KeyCode.CLOSE_SQUARE_BRACKET;
    }
    static _convertKeyCodeToKeyName(keyCode) {
      switch (keyCode) {
        case KeyCode.ALT:
        {
          return _KeyName.ALT;
        }
        case KeyCode.BACKSPACE:
        {
          return _KeyName.BACKSPACE;
        }
        case KeyCode.CAPS_LOCK:
        {
          return _KeyName.CAPS_LOCK;
        }
        case KeyCode.CTRL:
        {
          return _KeyName.CONTROL;
        }
        case KeyCode.DELETE:
        {
          return _KeyName.DEL;
        }
        case KeyCode.DOWN:
        {
          return _KeyName.DOWN;
        }
        case KeyCode.END:
        {
          return _KeyName.END;
        }
        case KeyCode.ENTER:
        {
          return _KeyName.ENTER;
        }
        case KeyCode.ESC:
        {
          return _KeyName.ESC;
        }
        case KeyCode.F1:
        {
          return _KeyName.F1;
        }
        case KeyCode.F2:
        {
          return _KeyName.F2;
        }
        case KeyCode.F3:
        {
          return _KeyName.F3;
        }
        case KeyCode.F4:
        {
          return _KeyName.F4;
        }
        case KeyCode.F5:
        {
          return _KeyName.F5;
        }
        case KeyCode.F6:
        {
          return _KeyName.F6;
        }
        case KeyCode.F7:
        {
          return _KeyName.F7;
        }
        case KeyCode.F8:
        {
          return _KeyName.F8;
        }
        case KeyCode.F9:
        {
          return _KeyName.F9;
        }
        case KeyCode.F10:
        {
          return _KeyName.F10;
        }
        case KeyCode.F11:
        {
          return _KeyName.F11;
        }
        case KeyCode.F12:
        {
          return _KeyName.F12;
        }
        case KeyCode.HOME:
        {
          return _KeyName.HOME;
        }
        case KeyCode.INSERT:
        {
          return _KeyName.INSERT;
        }
        case KeyCode.LEFT:
        {
          return _KeyName.LEFT;
        }
        case KeyCode.META:
        {
          return _KeyName.META;
        }
        case KeyCode.NUMLOCK:
        {
          return _KeyName.NUM_LOCK;
        }
        case KeyCode.PAGE_DOWN:
        {
          return _KeyName.PAGE_DOWN;
        }
        case KeyCode.PAGE_UP:
        {
          return _KeyName.PAGE_UP;
        }
        case KeyCode.PAUSE:
        {
          return _KeyName.PAUSE;
        }
        case KeyCode.PRINT_SCREEN:
        {
          return _KeyName.PRINT_SCREEN;
        }
        case KeyCode.RIGHT:
        {
          return _KeyName.RIGHT;
        }
        case KeyCode.SCROLL_LOCK:
        {
          return _KeyName.SCROLL;
        }
        case KeyCode.SHIFT:
        {
          return _KeyName.SHIFT;
        }
        case KeyCode.SPACE:
        {
          return _KeyName.SPACEBAR;
        }
        case KeyCode.TAB:
        {
          return _KeyName.TAB;
        }
        case KeyCode.UP:
        {
          return _KeyName.UP;
        }
        case KeyCode.WIN_IME:
        case KeyCode.WIN_KEY:
        case KeyCode.WIN_KEY_LEFT:
        case KeyCode.WIN_KEY_RIGHT:
        {
          return _KeyName.WIN;
        }
        default:
        {
          return _KeyName.UNIDENTIFIED;
        }
      }
      return _KeyName.UNIDENTIFIED;
    }
  }
  dart.setSignature(KeyCode, {
    statics: () => ({
      isCharacterKey: [core.bool, [core.int]],
      _convertKeyCodeToKeyName: [core.String, [core.int]]
    }),
    names: ['isCharacterKey', '_convertKeyCodeToKeyName']
  });
  KeyCode.WIN_KEY_FF_LINUX = 0;
  KeyCode.MAC_ENTER = 3;
  KeyCode.BACKSPACE = 8;
  KeyCode.TAB = 9;
  KeyCode.NUM_CENTER = 12;
  KeyCode.ENTER = 13;
  KeyCode.SHIFT = 16;
  KeyCode.CTRL = 17;
  KeyCode.ALT = 18;
  KeyCode.PAUSE = 19;
  KeyCode.CAPS_LOCK = 20;
  KeyCode.ESC = 27;
  KeyCode.SPACE = 32;
  KeyCode.PAGE_UP = 33;
  KeyCode.PAGE_DOWN = 34;
  KeyCode.END = 35;
  KeyCode.HOME = 36;
  KeyCode.LEFT = 37;
  KeyCode.UP = 38;
  KeyCode.RIGHT = 39;
  KeyCode.DOWN = 40;
  KeyCode.NUM_NORTH_EAST = 33;
  KeyCode.NUM_SOUTH_EAST = 34;
  KeyCode.NUM_SOUTH_WEST = 35;
  KeyCode.NUM_NORTH_WEST = 36;
  KeyCode.NUM_WEST = 37;
  KeyCode.NUM_NORTH = 38;
  KeyCode.NUM_EAST = 39;
  KeyCode.NUM_SOUTH = 40;
  KeyCode.PRINT_SCREEN = 44;
  KeyCode.INSERT = 45;
  KeyCode.NUM_INSERT = 45;
  KeyCode.DELETE = 46;
  KeyCode.NUM_DELETE = 46;
  KeyCode.ZERO = 48;
  KeyCode.ONE = 49;
  KeyCode.TWO = 50;
  KeyCode.THREE = 51;
  KeyCode.FOUR = 52;
  KeyCode.FIVE = 53;
  KeyCode.SIX = 54;
  KeyCode.SEVEN = 55;
  KeyCode.EIGHT = 56;
  KeyCode.NINE = 57;
  KeyCode.FF_SEMICOLON = 59;
  KeyCode.FF_EQUALS = 61;
  KeyCode.QUESTION_MARK = 63;
  KeyCode.A = 65;
  KeyCode.B = 66;
  KeyCode.C = 67;
  KeyCode.D = 68;
  KeyCode.E = 69;
  KeyCode.F = 70;
  KeyCode.G = 71;
  KeyCode.H = 72;
  KeyCode.I = 73;
  KeyCode.J = 74;
  KeyCode.K = 75;
  KeyCode.L = 76;
  KeyCode.M = 77;
  KeyCode.N = 78;
  KeyCode.O = 79;
  KeyCode.P = 80;
  KeyCode.Q = 81;
  KeyCode.R = 82;
  KeyCode.S = 83;
  KeyCode.T = 84;
  KeyCode.U = 85;
  KeyCode.V = 86;
  KeyCode.W = 87;
  KeyCode.X = 88;
  KeyCode.Y = 89;
  KeyCode.Z = 90;
  KeyCode.META = 91;
  KeyCode.WIN_KEY_LEFT = 91;
  KeyCode.WIN_KEY_RIGHT = 92;
  KeyCode.CONTEXT_MENU = 93;
  KeyCode.NUM_ZERO = 96;
  KeyCode.NUM_ONE = 97;
  KeyCode.NUM_TWO = 98;
  KeyCode.NUM_THREE = 99;
  KeyCode.NUM_FOUR = 100;
  KeyCode.NUM_FIVE = 101;
  KeyCode.NUM_SIX = 102;
  KeyCode.NUM_SEVEN = 103;
  KeyCode.NUM_EIGHT = 104;
  KeyCode.NUM_NINE = 105;
  KeyCode.NUM_MULTIPLY = 106;
  KeyCode.NUM_PLUS = 107;
  KeyCode.NUM_MINUS = 109;
  KeyCode.NUM_PERIOD = 110;
  KeyCode.NUM_DIVISION = 111;
  KeyCode.F1 = 112;
  KeyCode.F2 = 113;
  KeyCode.F3 = 114;
  KeyCode.F4 = 115;
  KeyCode.F5 = 116;
  KeyCode.F6 = 117;
  KeyCode.F7 = 118;
  KeyCode.F8 = 119;
  KeyCode.F9 = 120;
  KeyCode.F10 = 121;
  KeyCode.F11 = 122;
  KeyCode.F12 = 123;
  KeyCode.NUMLOCK = 144;
  KeyCode.SCROLL_LOCK = 145;
  KeyCode.FIRST_MEDIA_KEY = 166;
  KeyCode.LAST_MEDIA_KEY = 183;
  KeyCode.SEMICOLON = 186;
  KeyCode.DASH = 189;
  KeyCode.EQUALS = 187;
  KeyCode.COMMA = 188;
  KeyCode.PERIOD = 190;
  KeyCode.SLASH = 191;
  KeyCode.APOSTROPHE = 192;
  KeyCode.TILDE = 192;
  KeyCode.SINGLE_QUOTE = 222;
  KeyCode.OPEN_SQUARE_BRACKET = 219;
  KeyCode.BACKSLASH = 220;
  KeyCode.CLOSE_SQUARE_BRACKET = 221;
  KeyCode.WIN_KEY = 224;
  KeyCode.MAC_FF_META = 224;
  KeyCode.WIN_IME = 229;
  KeyCode.UNKNOWN = -1;
  class KeyLocation extends core.Object {}
  KeyLocation.STANDARD = 0;
  KeyLocation.LEFT = 1;
  KeyLocation.RIGHT = 2;
  KeyLocation.NUMPAD = 3;
  KeyLocation.MOBILE = 4;
  KeyLocation.JOYSTICK = 5;
  class _KeyName extends core.Object {}
  _KeyName.ACCEPT = "Accept";
  _KeyName.ADD = "Add";
  _KeyName.AGAIN = "Again";
  _KeyName.ALL_CANDIDATES = "AllCandidates";
  _KeyName.ALPHANUMERIC = "Alphanumeric";
  _KeyName.ALT = "Alt";
  _KeyName.ALT_GRAPH = "AltGraph";
  _KeyName.APPS = "Apps";
  _KeyName.ATTN = "Attn";
  _KeyName.BROWSER_BACK = "BrowserBack";
  _KeyName.BROWSER_FAVORTIES = "BrowserFavorites";
  _KeyName.BROWSER_FORWARD = "BrowserForward";
  _KeyName.BROWSER_NAME = "BrowserHome";
  _KeyName.BROWSER_REFRESH = "BrowserRefresh";
  _KeyName.BROWSER_SEARCH = "BrowserSearch";
  _KeyName.BROWSER_STOP = "BrowserStop";
  _KeyName.CAMERA = "Camera";
  _KeyName.CAPS_LOCK = "CapsLock";
  _KeyName.CLEAR = "Clear";
  _KeyName.CODE_INPUT = "CodeInput";
  _KeyName.COMPOSE = "Compose";
  _KeyName.CONTROL = "Control";
  _KeyName.CRSEL = "Crsel";
  _KeyName.CONVERT = "Convert";
  _KeyName.COPY = "Copy";
  _KeyName.CUT = "Cut";
  _KeyName.DECIMAL = "Decimal";
  _KeyName.DIVIDE = "Divide";
  _KeyName.DOWN = "Down";
  _KeyName.DOWN_LEFT = "DownLeft";
  _KeyName.DOWN_RIGHT = "DownRight";
  _KeyName.EJECT = "Eject";
  _KeyName.END = "End";
  _KeyName.ENTER = "Enter";
  _KeyName.ERASE_EOF = "EraseEof";
  _KeyName.EXECUTE = "Execute";
  _KeyName.EXSEL = "Exsel";
  _KeyName.FN = "Fn";
  _KeyName.F1 = "F1";
  _KeyName.F2 = "F2";
  _KeyName.F3 = "F3";
  _KeyName.F4 = "F4";
  _KeyName.F5 = "F5";
  _KeyName.F6 = "F6";
  _KeyName.F7 = "F7";
  _KeyName.F8 = "F8";
  _KeyName.F9 = "F9";
  _KeyName.F10 = "F10";
  _KeyName.F11 = "F11";
  _KeyName.F12 = "F12";
  _KeyName.F13 = "F13";
  _KeyName.F14 = "F14";
  _KeyName.F15 = "F15";
  _KeyName.F16 = "F16";
  _KeyName.F17 = "F17";
  _KeyName.F18 = "F18";
  _KeyName.F19 = "F19";
  _KeyName.F20 = "F20";
  _KeyName.F21 = "F21";
  _KeyName.F22 = "F22";
  _KeyName.F23 = "F23";
  _KeyName.F24 = "F24";
  _KeyName.FINAL_MODE = "FinalMode";
  _KeyName.FIND = "Find";
  _KeyName.FULL_WIDTH = "FullWidth";
  _KeyName.HALF_WIDTH = "HalfWidth";
  _KeyName.HANGUL_MODE = "HangulMode";
  _KeyName.HANJA_MODE = "HanjaMode";
  _KeyName.HELP = "Help";
  _KeyName.HIRAGANA = "Hiragana";
  _KeyName.HOME = "Home";
  _KeyName.INSERT = "Insert";
  _KeyName.JAPANESE_HIRAGANA = "JapaneseHiragana";
  _KeyName.JAPANESE_KATAKANA = "JapaneseKatakana";
  _KeyName.JAPANESE_ROMAJI = "JapaneseRomaji";
  _KeyName.JUNJA_MODE = "JunjaMode";
  _KeyName.KANA_MODE = "KanaMode";
  _KeyName.KANJI_MODE = "KanjiMode";
  _KeyName.KATAKANA = "Katakana";
  _KeyName.LAUNCH_APPLICATION_1 = "LaunchApplication1";
  _KeyName.LAUNCH_APPLICATION_2 = "LaunchApplication2";
  _KeyName.LAUNCH_MAIL = "LaunchMail";
  _KeyName.LEFT = "Left";
  _KeyName.MENU = "Menu";
  _KeyName.META = "Meta";
  _KeyName.MEDIA_NEXT_TRACK = "MediaNextTrack";
  _KeyName.MEDIA_PAUSE_PLAY = "MediaPlayPause";
  _KeyName.MEDIA_PREVIOUS_TRACK = "MediaPreviousTrack";
  _KeyName.MEDIA_STOP = "MediaStop";
  _KeyName.MODE_CHANGE = "ModeChange";
  _KeyName.NEXT_CANDIDATE = "NextCandidate";
  _KeyName.NON_CONVERT = "Nonconvert";
  _KeyName.NUM_LOCK = "NumLock";
  _KeyName.PAGE_DOWN = "PageDown";
  _KeyName.PAGE_UP = "PageUp";
  _KeyName.PASTE = "Paste";
  _KeyName.PAUSE = "Pause";
  _KeyName.PLAY = "Play";
  _KeyName.POWER = "Power";
  _KeyName.PREVIOUS_CANDIDATE = "PreviousCandidate";
  _KeyName.PRINT_SCREEN = "PrintScreen";
  _KeyName.PROCESS = "Process";
  _KeyName.PROPS = "Props";
  _KeyName.RIGHT = "Right";
  _KeyName.ROMAN_CHARACTERS = "RomanCharacters";
  _KeyName.SCROLL = "Scroll";
  _KeyName.SELECT = "Select";
  _KeyName.SELECT_MEDIA = "SelectMedia";
  _KeyName.SEPARATOR = "Separator";
  _KeyName.SHIFT = "Shift";
  _KeyName.SOFT_1 = "Soft1";
  _KeyName.SOFT_2 = "Soft2";
  _KeyName.SOFT_3 = "Soft3";
  _KeyName.SOFT_4 = "Soft4";
  _KeyName.STOP = "Stop";
  _KeyName.SUBTRACT = "Subtract";
  _KeyName.SYMBOL_LOCK = "SymbolLock";
  _KeyName.UP = "Up";
  _KeyName.UP_LEFT = "UpLeft";
  _KeyName.UP_RIGHT = "UpRight";
  _KeyName.UNDO = "Undo";
  _KeyName.VOLUME_DOWN = "VolumeDown";
  _KeyName.VOLUMN_MUTE = "VolumeMute";
  _KeyName.VOLUMN_UP = "VolumeUp";
  _KeyName.WIN = "Win";
  _KeyName.ZOOM = "Zoom";
  _KeyName.BACKSPACE = "Backspace";
  _KeyName.TAB = "Tab";
  _KeyName.CANCEL = "Cancel";
  _KeyName.ESC = "Esc";
  _KeyName.SPACEBAR = "Spacebar";
  _KeyName.DEL = "Del";
  _KeyName.DEAD_GRAVE = "DeadGrave";
  _KeyName.DEAD_EACUTE = "DeadEacute";
  _KeyName.DEAD_CIRCUMFLEX = "DeadCircumflex";
  _KeyName.DEAD_TILDE = "DeadTilde";
  _KeyName.DEAD_MACRON = "DeadMacron";
  _KeyName.DEAD_BREVE = "DeadBreve";
  _KeyName.DEAD_ABOVE_DOT = "DeadAboveDot";
  _KeyName.DEAD_UMLAUT = "DeadUmlaut";
  _KeyName.DEAD_ABOVE_RING = "DeadAboveRing";
  _KeyName.DEAD_DOUBLEACUTE = "DeadDoubleacute";
  _KeyName.DEAD_CARON = "DeadCaron";
  _KeyName.DEAD_CEDILLA = "DeadCedilla";
  _KeyName.DEAD_OGONEK = "DeadOgonek";
  _KeyName.DEAD_IOTA = "DeadIota";
  _KeyName.DEAD_VOICED_SOUND = "DeadVoicedSound";
  _KeyName.DEC_SEMIVOICED_SOUND = "DeadSemivoicedSound";
  _KeyName.UNIDENTIFIED = "Unidentified";
  const _stream = Symbol('_stream');
  const _keyDownList = Symbol('_keyDownList');
  const _capsLockOn = Symbol('_capsLockOn');
  const _determineKeyCodeForKeypress = Symbol('_determineKeyCodeForKeypress');
  const _findCharCodeKeyDown = Symbol('_findCharCodeKeyDown');
  const _firesKeyPressEvent = Symbol('_firesKeyPressEvent');
  const _normalizeKeyCodes = Symbol('_normalizeKeyCodes');
  class _KeyboardEventHandler extends EventStreamProvider$(KeyEvent) {
    forTarget(e, opts) {
      let useCapture = opts && 'useCapture' in opts ? opts.useCapture : false;
      let handler = new _KeyboardEventHandler.initializeAllEventListeners(this[_type], e);
      return handler[_stream];
    }
    _KeyboardEventHandler(type) {
      this[_keyDownList] = dart.list([], KeyboardEvent);
      this[_type] = type;
      this[_stream] = new _CustomKeyEventStreamImpl('event');
      this[_target] = null;
      super.EventStreamProvider(_KeyboardEventHandler._EVENT_TYPE);
    }
    initializeAllEventListeners(type, target) {
      this[_keyDownList] = dart.list([], KeyboardEvent);
      this[_type] = type;
      this[_target] = target;
      this[_stream] = null;
      super.EventStreamProvider(_KeyboardEventHandler._EVENT_TYPE);
      Element.keyDownEvent.forTarget(this[_target], {useCapture: true}).listen(dart.bind(this, 'processKeyDown'));
      Element.keyPressEvent.forTarget(this[_target], {useCapture: true}).listen(dart.bind(this, 'processKeyPress'));
      Element.keyUpEvent.forTarget(this[_target], {useCapture: true}).listen(dart.bind(this, 'processKeyUp'));
      this[_stream] = new _CustomKeyEventStreamImpl(this[_type]);
    }
    get [_capsLockOn]() {
      return this[_keyDownList][dartx.any](dart.fn(element => element[dartx.keyCode] == KeyCode.CAPS_LOCK, core.bool, [KeyboardEvent]));
    }
    [_determineKeyCodeForKeypress](event) {
      for (let prevEvent of this[_keyDownList]) {
        if (dart.equals(dart.dload(prevEvent, _shadowCharCode), event[dartx.charCode])) {
          return prevEvent[dartx.keyCode];
        }
        if ((dart.notNull(event[dartx.shiftKey]) || dart.notNull(this[_capsLockOn])) && dart.notNull(event[dartx.charCode]) >= dart.notNull("A"[dartx.codeUnits][dartx.get](0)) && dart.notNull(event[dartx.charCode]) <= dart.notNull("Z"[dartx.codeUnits][dartx.get](0)) && dart.equals(dart.notNull(event[dartx.charCode]) + dart.notNull(_KeyboardEventHandler._ROMAN_ALPHABET_OFFSET), dart.dload(prevEvent, _shadowCharCode))) {
          return prevEvent[dartx.keyCode];
        }
      }
      return KeyCode.UNKNOWN;
    }
    [_findCharCodeKeyDown](event) {
      if (event[dartx.keyLocation] == 3) {
        switch (event[dartx.keyCode]) {
          case KeyCode.NUM_ZERO:
          {
            return KeyCode.ZERO;
          }
          case KeyCode.NUM_ONE:
          {
            return KeyCode.ONE;
          }
          case KeyCode.NUM_TWO:
          {
            return KeyCode.TWO;
          }
          case KeyCode.NUM_THREE:
          {
            return KeyCode.THREE;
          }
          case KeyCode.NUM_FOUR:
          {
            return KeyCode.FOUR;
          }
          case KeyCode.NUM_FIVE:
          {
            return KeyCode.FIVE;
          }
          case KeyCode.NUM_SIX:
          {
            return KeyCode.SIX;
          }
          case KeyCode.NUM_SEVEN:
          {
            return KeyCode.SEVEN;
          }
          case KeyCode.NUM_EIGHT:
          {
            return KeyCode.EIGHT;
          }
          case KeyCode.NUM_NINE:
          {
            return KeyCode.NINE;
          }
          case KeyCode.NUM_MULTIPLY:
          {
            return 42;
          }
          case KeyCode.NUM_PLUS:
          {
            return 43;
          }
          case KeyCode.NUM_MINUS:
          {
            return 45;
          }
          case KeyCode.NUM_PERIOD:
          {
            return 46;
          }
          case KeyCode.NUM_DIVISION:
          {
            return 47;
          }
        }
      } else if (dart.notNull(event[dartx.keyCode]) >= 65 && dart.notNull(event[dartx.keyCode]) <= 90) {
        return dart.notNull(event[dartx.keyCode]) + dart.notNull(_KeyboardEventHandler._ROMAN_ALPHABET_OFFSET);
      }
      switch (event[dartx.keyCode]) {
        case KeyCode.SEMICOLON:
        {
          return KeyCode.FF_SEMICOLON;
        }
        case KeyCode.EQUALS:
        {
          return KeyCode.FF_EQUALS;
        }
        case KeyCode.COMMA:
        {
          return 44;
        }
        case KeyCode.DASH:
        {
          return 45;
        }
        case KeyCode.PERIOD:
        {
          return 46;
        }
        case KeyCode.SLASH:
        {
          return 47;
        }
        case KeyCode.APOSTROPHE:
        {
          return 96;
        }
        case KeyCode.OPEN_SQUARE_BRACKET:
        {
          return 91;
        }
        case KeyCode.BACKSLASH:
        {
          return 92;
        }
        case KeyCode.CLOSE_SQUARE_BRACKET:
        {
          return 93;
        }
        case KeyCode.SINGLE_QUOTE:
        {
          return 39;
        }
      }
      return event[dartx.keyCode];
    }
    [_firesKeyPressEvent](event) {
      if (!dart.notNull(html_common.Device.isIE) && !dart.notNull(html_common.Device.isWebKit)) {
        return true;
      }
      if (dart.notNull(html_common.Device.userAgent[dartx.contains]('Mac')) && dart.notNull(event.altKey)) {
        return KeyCode.isCharacterKey(event.keyCode);
      }
      if (dart.notNull(event.altKey) && !dart.notNull(event.ctrlKey)) {
        return false;
      }
      if (!dart.notNull(event.shiftKey) && (this[_keyDownList][dartx.last][dartx.keyCode] == KeyCode.CTRL || this[_keyDownList][dartx.last][dartx.keyCode] == KeyCode.ALT || dart.notNull(html_common.Device.userAgent[dartx.contains]('Mac')) && this[_keyDownList][dartx.last][dartx.keyCode] == KeyCode.META)) {
        return false;
      }
      if (dart.notNull(html_common.Device.isWebKit) && dart.notNull(event.ctrlKey) && dart.notNull(event.shiftKey) && (event.keyCode == KeyCode.BACKSLASH || event.keyCode == KeyCode.OPEN_SQUARE_BRACKET || event.keyCode == KeyCode.CLOSE_SQUARE_BRACKET || event.keyCode == KeyCode.TILDE || event.keyCode == KeyCode.SEMICOLON || event.keyCode == KeyCode.DASH || event.keyCode == KeyCode.EQUALS || event.keyCode == KeyCode.COMMA || event.keyCode == KeyCode.PERIOD || event.keyCode == KeyCode.SLASH || event.keyCode == KeyCode.APOSTROPHE || event.keyCode == KeyCode.SINGLE_QUOTE)) {
        return false;
      }
      switch (event.keyCode) {
        case KeyCode.ENTER:
        {
          return !dart.notNull(html_common.Device.isIE);
        }
        case KeyCode.ESC:
        {
          return !dart.notNull(html_common.Device.isWebKit);
        }
      }
      return KeyCode.isCharacterKey(event.keyCode);
    }
    [_normalizeKeyCodes](event) {
      if (dart.notNull(html_common.Device.isFirefox)) {
        switch (event[dartx.keyCode]) {
          case KeyCode.FF_EQUALS:
          {
            return KeyCode.EQUALS;
          }
          case KeyCode.FF_SEMICOLON:
          {
            return KeyCode.SEMICOLON;
          }
          case KeyCode.MAC_FF_META:
          {
            return KeyCode.META;
          }
          case KeyCode.WIN_KEY_FF_LINUX:
          {
            return KeyCode.WIN_KEY;
          }
        }
      }
      return event[dartx.keyCode];
    }
    processKeyDown(e) {
      if (dart.notNull(this[_keyDownList][dartx.length]) > 0 && (this[_keyDownList][dartx.last][dartx.keyCode] == KeyCode.CTRL && !dart.notNull(e[dartx.ctrlKey]) || this[_keyDownList][dartx.last][dartx.keyCode] == KeyCode.ALT && !dart.notNull(e[dartx.altKey]) || dart.notNull(html_common.Device.userAgent[dartx.contains]('Mac')) && this[_keyDownList][dartx.last][dartx.keyCode] == KeyCode.META && !dart.notNull(e[dartx.metaKey]))) {
        this[_keyDownList][dartx.clear]();
      }
      let event = new KeyEvent.wrap(e);
      event[_shadowKeyCode] = this[_normalizeKeyCodes](event);
      event[_shadowCharCode] = this[_findCharCodeKeyDown](event);
      if (dart.notNull(this[_keyDownList][dartx.length]) > 0 && event.keyCode != this[_keyDownList][dartx.last][dartx.keyCode] && !dart.notNull(this[_firesKeyPressEvent](event))) {
        this.processKeyPress(e);
      }
      this[_keyDownList][dartx.add](event);
      this[_stream].add(event);
    }
    processKeyPress(event) {
      let e = new KeyEvent.wrap(event);
      if (dart.notNull(html_common.Device.isIE)) {
        if (e.keyCode == KeyCode.ENTER || e.keyCode == KeyCode.ESC) {
          e[_shadowCharCode] = 0;
        } else {
          e[_shadowCharCode] = e.keyCode;
        }
      } else if (dart.notNull(html_common.Device.isOpera)) {
        e[_shadowCharCode] = dart.notNull(KeyCode.isCharacterKey(e.keyCode)) ? e.keyCode : 0;
      }
      e[_shadowKeyCode] = this[_determineKeyCodeForKeypress](e);
      if (e[_shadowKeyIdentifier] != null && dart.notNull(_KeyboardEventHandler._keyIdentifier[dartx.containsKey](e[_shadowKeyIdentifier]))) {
        e[_shadowKeyCode] = _KeyboardEventHandler._keyIdentifier[dartx.get](e[_shadowKeyIdentifier]);
      }
      e[_shadowAltKey] = this[_keyDownList][dartx.any](dart.fn(element => element[dartx.altKey], core.bool, [KeyboardEvent]));
      this[_stream].add(e);
    }
    processKeyUp(event) {
      let e = new KeyEvent.wrap(event);
      let toRemove = null;
      for (let key of this[_keyDownList]) {
        if (key[dartx.keyCode] == e.keyCode) {
          toRemove = key;
        }
      }
      if (toRemove != null) {
        this[_keyDownList][dartx.removeWhere](dart.fn(element => dart.equals(element, toRemove), core.bool, [KeyboardEvent]));
      } else if (dart.notNull(this[_keyDownList][dartx.length]) > 0) {
        this[_keyDownList][dartx.removeLast]();
      }
      this[_stream].add(e);
    }
  }
  dart.defineNamedConstructor(_KeyboardEventHandler, 'initializeAllEventListeners');
  dart.setSignature(_KeyboardEventHandler, {
    constructors: () => ({
      _KeyboardEventHandler: [_KeyboardEventHandler, [core.String]],
      initializeAllEventListeners: [_KeyboardEventHandler, [core.String, EventTarget]]
    }),
    methods: () => ({
      forTarget: [CustomStream$(KeyEvent), [EventTarget], {useCapture: core.bool}],
      [_determineKeyCodeForKeypress]: [core.int, [KeyboardEvent]],
      [_findCharCodeKeyDown]: [core.int, [KeyboardEvent]],
      [_firesKeyPressEvent]: [core.bool, [KeyEvent]],
      [_normalizeKeyCodes]: [core.int, [KeyboardEvent]],
      processKeyDown: [dart.void, [KeyboardEvent]],
      processKeyPress: [dart.void, [KeyboardEvent]],
      processKeyUp: [dart.void, [KeyboardEvent]]
    })
  });
  _KeyboardEventHandler._EVENT_TYPE = 'KeyEvent';
  _KeyboardEventHandler._keyIdentifier = dart.const(dart.map({Up: KeyCode.UP, Down: KeyCode.DOWN, Left: KeyCode.LEFT, Right: KeyCode.RIGHT, Enter: KeyCode.ENTER, F1: KeyCode.F1, F2: KeyCode.F2, F3: KeyCode.F3, F4: KeyCode.F4, F5: KeyCode.F5, F6: KeyCode.F6, F7: KeyCode.F7, F8: KeyCode.F8, F9: KeyCode.F9, F10: KeyCode.F10, F11: KeyCode.F11, F12: KeyCode.F12, 'U+007F': KeyCode.DELETE, Home: KeyCode.HOME, End: KeyCode.END, PageUp: KeyCode.PAGE_UP, PageDown: KeyCode.PAGE_DOWN, Insert: KeyCode.INSERT}));
  dart.defineLazyProperties(_KeyboardEventHandler, {
    get _ROMAN_ALPHABET_OFFSET() {
      return dart.notNull("a"[dartx.codeUnits][dartx.get](0)) - dart.notNull("A"[dartx.codeUnits][dartx.get](0));
    }
  });
  class KeyboardEventStream extends core.Object {
    static onKeyPress(target) {
      return new _KeyboardEventHandler('keypress').forTarget(target);
    }
    static onKeyUp(target) {
      return new _KeyboardEventHandler('keyup').forTarget(target);
    }
    static onKeyDown(target) {
      return new _KeyboardEventHandler('keydown').forTarget(target);
    }
  }
  dart.setSignature(KeyboardEventStream, {
    statics: () => ({
      onKeyPress: [CustomStream$(KeyEvent), [EventTarget]],
      onKeyUp: [CustomStream$(KeyEvent), [EventTarget]],
      onKeyDown: [CustomStream$(KeyEvent), [EventTarget]]
    }),
    names: ['onKeyPress', 'onKeyUp', 'onKeyDown']
  });
  const _validators = Symbol('_validators');
  class NodeValidatorBuilder extends core.Object {
    NodeValidatorBuilder() {
      this[_validators] = dart.list([], NodeValidator);
    }
    common() {
      this[_validators] = dart.list([], NodeValidator);
      this.allowHtml5();
      this.allowTemplating();
    }
    allowNavigation(uriPolicy) {
      if (uriPolicy === void 0) uriPolicy = null;
      if (uriPolicy == null) {
        uriPolicy = UriPolicy.new();
      }
      this.add(_SimpleNodeValidator.allowNavigation(uriPolicy));
    }
    allowImages(uriPolicy) {
      if (uriPolicy === void 0) uriPolicy = null;
      if (uriPolicy == null) {
        uriPolicy = UriPolicy.new();
      }
      this.add(_SimpleNodeValidator.allowImages(uriPolicy));
    }
    allowTextElements() {
      this.add(_SimpleNodeValidator.allowTextElements());
    }
    allowInlineStyles(opts) {
      let tagName = opts && 'tagName' in opts ? opts.tagName : null;
      if (tagName == null) {
        tagName = '*';
      } else {
        tagName = tagName[dartx.toUpperCase]();
      }
      this.add(new _SimpleNodeValidator(null, {allowedAttributes: dart.list([`${tagName}::style`], core.String)}));
    }
    allowHtml5(opts) {
      let uriPolicy = opts && 'uriPolicy' in opts ? opts.uriPolicy : null;
      this.add(new _Html5NodeValidator({uriPolicy: uriPolicy}));
    }
    allowSvg() {
      this.add(new _SvgNodeValidator());
    }
    allowCustomElement(tagName, opts) {
      let uriPolicy = opts && 'uriPolicy' in opts ? opts.uriPolicy : null;
      let attributes = opts && 'attributes' in opts ? opts.attributes : null;
      let uriAttributes = opts && 'uriAttributes' in opts ? opts.uriAttributes : null;
      let tagNameUpper = tagName[dartx.toUpperCase]();
      let attrs = null;
      if (attributes != null) {
        attrs = attributes[dartx.map](dart.fn(name => `${tagNameUpper}::${name[dartx.toLowerCase]()}`, core.String, [core.String]));
      }
      let uriAttrs = null;
      if (uriAttributes != null) {
        uriAttrs = uriAttributes[dartx.map](dart.fn(name => `${tagNameUpper}::${name[dartx.toLowerCase]()}`, core.String, [core.String]));
      }
      if (uriPolicy == null) {
        uriPolicy = UriPolicy.new();
      }
      this.add(new _CustomElementNodeValidator(uriPolicy, dart.list([tagNameUpper], core.String), dart.as(attrs, core.Iterable$(core.String)), dart.as(uriAttrs, core.Iterable$(core.String)), false, true));
    }
    allowTagExtension(tagName, baseName, opts) {
      let uriPolicy = opts && 'uriPolicy' in opts ? opts.uriPolicy : null;
      let attributes = opts && 'attributes' in opts ? opts.attributes : null;
      let uriAttributes = opts && 'uriAttributes' in opts ? opts.uriAttributes : null;
      let baseNameUpper = baseName[dartx.toUpperCase]();
      let tagNameUpper = tagName[dartx.toUpperCase]();
      let attrs = null;
      if (attributes != null) {
        attrs = attributes[dartx.map](dart.fn(name => `${baseNameUpper}::${name[dartx.toLowerCase]()}`, core.String, [core.String]));
      }
      let uriAttrs = null;
      if (uriAttributes != null) {
        uriAttrs = uriAttributes[dartx.map](dart.fn(name => `${baseNameUpper}::${name[dartx.toLowerCase]()}`, core.String, [core.String]));
      }
      if (uriPolicy == null) {
        uriPolicy = UriPolicy.new();
      }
      this.add(new _CustomElementNodeValidator(uriPolicy, dart.list([tagNameUpper, baseNameUpper], core.String), dart.as(attrs, core.Iterable$(core.String)), dart.as(uriAttrs, core.Iterable$(core.String)), true, false));
    }
    allowElement(tagName, opts) {
      let uriPolicy = opts && 'uriPolicy' in opts ? opts.uriPolicy : null;
      let attributes = opts && 'attributes' in opts ? opts.attributes : null;
      let uriAttributes = opts && 'uriAttributes' in opts ? opts.uriAttributes : null;
      this.allowCustomElement(tagName, {uriPolicy: uriPolicy, attributes: attributes, uriAttributes: uriAttributes});
    }
    allowTemplating() {
      this.add(new _TemplatingNodeValidator());
    }
    add(validator) {
      this[_validators][dartx.add](validator);
    }
    allowsElement(element) {
      return this[_validators][dartx.any](dart.fn(v => v.allowsElement(element), core.bool, [NodeValidator]));
    }
    allowsAttribute(element, attributeName, value) {
      return this[_validators][dartx.any](dart.fn(v => v.allowsAttribute(element, attributeName, value), core.bool, [NodeValidator]));
    }
  }
  NodeValidatorBuilder[dart.implements] = () => [NodeValidator];
  dart.defineNamedConstructor(NodeValidatorBuilder, 'common');
  dart.setSignature(NodeValidatorBuilder, {
    constructors: () => ({
      NodeValidatorBuilder: [NodeValidatorBuilder, []],
      common: [NodeValidatorBuilder, []]
    }),
    methods: () => ({
      allowNavigation: [dart.void, [], [UriPolicy]],
      allowImages: [dart.void, [], [UriPolicy]],
      allowTextElements: [dart.void, []],
      allowInlineStyles: [dart.void, [], {tagName: core.String}],
      allowHtml5: [dart.void, [], {uriPolicy: UriPolicy}],
      allowSvg: [dart.void, []],
      allowCustomElement: [dart.void, [core.String], {uriPolicy: UriPolicy, attributes: core.Iterable$(core.String), uriAttributes: core.Iterable$(core.String)}],
      allowTagExtension: [dart.void, [core.String, core.String], {uriPolicy: UriPolicy, attributes: core.Iterable$(core.String), uriAttributes: core.Iterable$(core.String)}],
      allowElement: [dart.void, [core.String], {uriPolicy: UriPolicy, attributes: core.Iterable$(core.String), uriAttributes: core.Iterable$(core.String)}],
      allowTemplating: [dart.void, []],
      add: [dart.void, [NodeValidator]],
      allowsElement: [core.bool, [Element]],
      allowsAttribute: [core.bool, [Element, core.String, core.String]]
    })
  });
  class _SimpleNodeValidator extends core.Object {
    static allowNavigation(uriPolicy) {
      return new _SimpleNodeValidator(uriPolicy, {allowedElements: dart.const(dart.list(['A', 'FORM'], core.String)), allowedAttributes: dart.const(dart.list(['A::accesskey', 'A::coords', 'A::hreflang', 'A::name', 'A::shape', 'A::tabindex', 'A::target', 'A::type', 'FORM::accept', 'FORM::autocomplete', 'FORM::enctype', 'FORM::method', 'FORM::name', 'FORM::novalidate', 'FORM::target'], core.String)), allowedUriAttributes: dart.const(dart.list(['A::href', 'FORM::action'], core.String))});
    }
    static allowImages(uriPolicy) {
      return new _SimpleNodeValidator(uriPolicy, {allowedElements: dart.const(dart.list(['IMG'], core.String)), allowedAttributes: dart.const(dart.list(['IMG::align', 'IMG::alt', 'IMG::border', 'IMG::height', 'IMG::hspace', 'IMG::ismap', 'IMG::name', 'IMG::usemap', 'IMG::vspace', 'IMG::width'], core.String)), allowedUriAttributes: dart.const(dart.list(['IMG::src'], core.String))});
    }
    static allowTextElements() {
      return new _SimpleNodeValidator(null, {allowedElements: dart.const(dart.list(['B', 'BLOCKQUOTE', 'BR', 'EM', 'H1', 'H2', 'H3', 'H4', 'H5', 'H6', 'HR', 'I', 'LI', 'OL', 'P', 'SPAN', 'UL'], core.String))});
    }
    _SimpleNodeValidator(uriPolicy, opts) {
      let allowedElements = opts && 'allowedElements' in opts ? opts.allowedElements : null;
      let allowedAttributes = opts && 'allowedAttributes' in opts ? opts.allowedAttributes : null;
      let allowedUriAttributes = opts && 'allowedUriAttributes' in opts ? opts.allowedUriAttributes : null;
      this.allowedElements = core.Set$(core.String).new();
      this.allowedAttributes = core.Set$(core.String).new();
      this.allowedUriAttributes = core.Set$(core.String).new();
      this.uriPolicy = uriPolicy;
      this.allowedElements.addAll((allowedElements != null ? allowedElements : dart.const(dart.list([], core.String))));
      allowedAttributes = allowedAttributes != null ? allowedAttributes : dart.const(dart.list([], core.String));
      allowedUriAttributes = allowedUriAttributes != null ? allowedUriAttributes : dart.const(dart.list([], core.String));
      let legalAttributes = allowedAttributes[dartx.where](dart.fn(x => !dart.notNull(_Html5NodeValidator._uriAttributes[dartx.contains](x)), core.bool, [core.String]));
      let extraUriAttributes = allowedAttributes[dartx.where](dart.fn(x => _Html5NodeValidator._uriAttributes[dartx.contains](x), core.bool, [core.String]));
      this.allowedAttributes.addAll(legalAttributes);
      this.allowedUriAttributes.addAll(allowedUriAttributes);
      this.allowedUriAttributes.addAll(extraUriAttributes);
    }
    allowsElement(element) {
      return this.allowedElements.contains(Element._safeTagName(element));
    }
    allowsAttribute(element, attributeName, value) {
      let tagName = Element._safeTagName(element);
      if (dart.notNull(this.allowedUriAttributes.contains(`${tagName}::${attributeName}`))) {
        return this.uriPolicy.allowsUri(value);
      } else if (dart.notNull(this.allowedUriAttributes.contains(`*::${attributeName}`))) {
        return this.uriPolicy.allowsUri(value);
      } else if (dart.notNull(this.allowedAttributes.contains(`${tagName}::${attributeName}`))) {
        return true;
      } else if (dart.notNull(this.allowedAttributes.contains(`*::${attributeName}`))) {
        return true;
      } else if (dart.notNull(this.allowedAttributes.contains(`${tagName}::*`))) {
        return true;
      } else if (dart.notNull(this.allowedAttributes.contains('*::*'))) {
        return true;
      }
      return false;
    }
  }
  _SimpleNodeValidator[dart.implements] = () => [NodeValidator];
  dart.setSignature(_SimpleNodeValidator, {
    constructors: () => ({
      allowNavigation: [_SimpleNodeValidator, [UriPolicy]],
      allowImages: [_SimpleNodeValidator, [UriPolicy]],
      allowTextElements: [_SimpleNodeValidator, []],
      _SimpleNodeValidator: [_SimpleNodeValidator, [UriPolicy], {allowedElements: core.Iterable$(core.String), allowedAttributes: core.Iterable$(core.String), allowedUriAttributes: core.Iterable$(core.String)}]
    }),
    methods: () => ({
      allowsElement: [core.bool, [Element]],
      allowsAttribute: [core.bool, [Element, core.String, core.String]]
    })
  });
  class _CustomElementNodeValidator extends _SimpleNodeValidator {
    _CustomElementNodeValidator(uriPolicy, allowedElements, allowedAttributes, allowedUriAttributes, allowTypeExtension, allowCustomTag) {
      this.allowTypeExtension = allowTypeExtension == true;
      this.allowCustomTag = allowCustomTag == true;
      super._SimpleNodeValidator(uriPolicy, {allowedElements: allowedElements, allowedAttributes: allowedAttributes, allowedUriAttributes: allowedUriAttributes});
    }
    allowsElement(element) {
      if (dart.notNull(this.allowTypeExtension)) {
        let isAttr = element[dartx.attributes][dartx.get]('is');
        if (isAttr != null) {
          return dart.notNull(this.allowedElements.contains(isAttr[dartx.toUpperCase]())) && dart.notNull(this.allowedElements.contains(Element._safeTagName(element)));
        }
      }
      return dart.notNull(this.allowCustomTag) && dart.notNull(this.allowedElements.contains(Element._safeTagName(element)));
    }
    allowsAttribute(element, attributeName, value) {
      if (dart.notNull(this.allowsElement(element))) {
        if (dart.notNull(this.allowTypeExtension) && attributeName == 'is' && dart.notNull(this.allowedElements.contains(value[dartx.toUpperCase]()))) {
          return true;
        }
        return super.allowsAttribute(element, attributeName, value);
      }
      return false;
    }
  }
  dart.setSignature(_CustomElementNodeValidator, {
    constructors: () => ({_CustomElementNodeValidator: [_CustomElementNodeValidator, [UriPolicy, core.Iterable$(core.String), core.Iterable$(core.String), core.Iterable$(core.String), core.bool, core.bool]]})
  });
  const _templateAttrs = Symbol('_templateAttrs');
  class _TemplatingNodeValidator extends _SimpleNodeValidator {
    _TemplatingNodeValidator() {
      this[_templateAttrs] = core.Set$(core.String).from(_TemplatingNodeValidator._TEMPLATE_ATTRS);
      super._SimpleNodeValidator(null, {allowedElements: dart.list(['TEMPLATE'], core.String), allowedAttributes: _TemplatingNodeValidator._TEMPLATE_ATTRS[dartx.map](dart.fn(attr => `TEMPLATE::${attr}`, core.String, [core.String]))});
    }
    allowsAttribute(element, attributeName, value) {
      if (dart.notNull(super.allowsAttribute(element, attributeName, value))) {
        return true;
      }
      if (attributeName == 'template' && value == "") {
        return true;
      }
      if (element[dartx.attributes][dartx.get]('template') == "") {
        return this[_templateAttrs].contains(attributeName);
      }
      return false;
    }
  }
  dart.setSignature(_TemplatingNodeValidator, {
    constructors: () => ({_TemplatingNodeValidator: [_TemplatingNodeValidator, []]})
  });
  _TemplatingNodeValidator._TEMPLATE_ATTRS = dart.const(dart.list(['bind', 'if', 'ref', 'repeat', 'syntax'], core.String));
  class _SvgNodeValidator extends core.Object {
    allowsElement(element) {
      if (dart.is(element, svg.ScriptElement)) {
        return false;
      }
      if (dart.is(element, svg.SvgElement) && Element._safeTagName(element) == 'foreignObject') {
        return false;
      }
      if (dart.is(element, svg.SvgElement)) {
        return true;
      }
      return false;
    }
    allowsAttribute(element, attributeName, value) {
      if (attributeName == 'is' || dart.notNull(attributeName[dartx.startsWith]('on'))) {
        return false;
      }
      return this.allowsElement(element);
    }
  }
  _SvgNodeValidator[dart.implements] = () => [NodeValidator];
  dart.setSignature(_SvgNodeValidator, {
    methods: () => ({
      allowsElement: [core.bool, [Element]],
      allowsAttribute: [core.bool, [Element, core.String, core.String]]
    })
  });
  class ReadyState extends core.Object {}
  ReadyState.LOADING = "loading";
  ReadyState.INTERACTIVE = "interactive";
  ReadyState.COMPLETE = "complete";
  const _list = Symbol('_list');
  const _WrappedList$ = dart.generic(function(E) {
    class _WrappedList extends collection.ListBase$(E) {
      _WrappedList(list) {
        this[_list] = list;
      }
      get iterator() {
        return new (_WrappedIterator$(E))(this[_list][dartx.iterator]);
      }
      get length() {
        return this[_list][dartx.length];
      }
      add(element) {
        dart.as(element, E);
        this[_list][dartx.add](element);
      }
      remove(element) {
        return this[_list][dartx.remove](element);
      }
      clear() {
        this[_list][dartx.clear]();
      }
      get(index) {
        return dart.as(this[_list][dartx.get](index), E);
      }
      set(index, value) {
        dart.as(value, E);
        this[_list][dartx.set](index, value);
        return value;
      }
      set length(newLength) {
        this[_list][dartx.length] = newLength;
      }
      sort(compare) {
        if (compare === void 0) compare = null;
        dart.as(compare, dart.functionType(core.int, [E, E]));
        this[_list][dartx.sort](compare);
      }
      indexOf(element, start) {
        if (start === void 0) start = 0;
        return this[_list][dartx.indexOf](element, start);
      }
      lastIndexOf(element, start) {
        if (start === void 0) start = null;
        return this[_list][dartx.lastIndexOf](element, start);
      }
      insert(index, element) {
        dart.as(element, E);
        return this[_list][dartx.insert](index, element);
      }
      removeAt(index) {
        return dart.as(this[_list][dartx.removeAt](index), E);
      }
      setRange(start, end, iterable, skipCount) {
        dart.as(iterable, core.Iterable$(E));
        if (skipCount === void 0) skipCount = 0;
        this[_list][dartx.setRange](start, end, iterable, skipCount);
      }
      removeRange(start, end) {
        this[_list][dartx.removeRange](start, end);
      }
      replaceRange(start, end, iterable) {
        dart.as(iterable, core.Iterable$(E));
        this[_list][dartx.replaceRange](start, end, iterable);
      }
      fillRange(start, end, fillValue) {
        if (fillValue === void 0) fillValue = null;
        dart.as(fillValue, E);
        this[_list][dartx.fillRange](start, end, fillValue);
      }
      get rawList() {
        return dart.as(this[_list], core.List$(Node));
      }
    }
    _WrappedList[dart.implements] = () => [html_common.NodeListWrapper];
    dart.setSignature(_WrappedList, {
      constructors: () => ({_WrappedList: [_WrappedList$(E), [core.List]]}),
      methods: () => ({
        add: [dart.void, [E]],
        get: [E, [core.int]],
        set: [dart.void, [core.int, E]],
        sort: [dart.void, [], [dart.functionType(core.int, [E, E])]],
        insert: [dart.void, [core.int, E]],
        removeAt: [E, [core.int]],
        setRange: [dart.void, [core.int, core.int, core.Iterable$(E)], [core.int]],
        replaceRange: [dart.void, [core.int, core.int, core.Iterable$(E)]],
        fillRange: [dart.void, [core.int, core.int], [E]]
      })
    });
    dart.defineExtensionMembers(_WrappedList, [
      'add',
      'remove',
      'clear',
      'get',
      'set',
      'sort',
      'indexOf',
      'lastIndexOf',
      'insert',
      'removeAt',
      'setRange',
      'removeRange',
      'replaceRange',
      'fillRange',
      'iterator',
      'length',
      'length'
    ]);
    return _WrappedList;
  });
  let _WrappedList = _WrappedList$();
  const _iterator = Symbol('_iterator');
  const _WrappedIterator$ = dart.generic(function(E) {
    class _WrappedIterator extends core.Object {
      _WrappedIterator(iterator) {
        this[_iterator] = iterator;
      }
      moveNext() {
        return this[_iterator].moveNext();
      }
      get current() {
        return dart.as(this[_iterator].current, E);
      }
    }
    _WrappedIterator[dart.implements] = () => [core.Iterator$(E)];
    dart.setSignature(_WrappedIterator, {
      constructors: () => ({_WrappedIterator: [_WrappedIterator$(E), [core.Iterator]]}),
      methods: () => ({moveNext: [core.bool, []]})
    });
    return _WrappedIterator;
  });
  let _WrappedIterator = _WrappedIterator$();
  class _HttpRequestUtils extends core.Object {
    static get(url, onComplete, withCredentials) {
      let request = HttpRequest.new();
      request[dartx.open]('GET', url, {async: true});
      request[dartx.withCredentials] = withCredentials;
      request[dartx.onReadyStateChange].listen(dart.fn(e => {
        if (request[dartx.readyState] == HttpRequest.DONE) {
          onComplete(request);
        }
      }, dart.void, [ProgressEvent]));
      request[dartx.send]();
      return request;
    }
  }
  dart.setSignature(_HttpRequestUtils, {
    statics: () => ({get: [HttpRequest, [core.String, dart.functionType(dart.dynamic, [HttpRequest]), core.bool]]}),
    names: ['get']
  });
  const _array = Symbol('_array');
  const _current = Symbol('_current');
  const FixedSizeListIterator$ = dart.generic(function(T) {
    class FixedSizeListIterator extends core.Object {
      FixedSizeListIterator(array) {
        this[_array] = array;
        this[_position] = -1;
        this[_length] = array[dartx.length];
        this[_current] = null;
      }
      moveNext() {
        let nextPosition = dart.notNull(this[_position]) + 1;
        if (nextPosition < dart.notNull(this[_length])) {
          this[_current] = this[_array][dartx.get](nextPosition);
          this[_position] = nextPosition;
          return true;
        }
        this[_current] = null;
        this[_position] = this[_length];
        return false;
      }
      get current() {
        return this[_current];
      }
    }
    FixedSizeListIterator[dart.implements] = () => [core.Iterator$(T)];
    dart.setSignature(FixedSizeListIterator, {
      constructors: () => ({FixedSizeListIterator: [FixedSizeListIterator$(T), [core.List$(T)]]}),
      methods: () => ({moveNext: [core.bool, []]})
    });
    return FixedSizeListIterator;
  });
  let FixedSizeListIterator = FixedSizeListIterator$();
  const _VariableSizeListIterator$ = dart.generic(function(T) {
    class _VariableSizeListIterator extends core.Object {
      _VariableSizeListIterator(array) {
        this[_array] = array;
        this[_position] = -1;
        this[_current] = null;
      }
      moveNext() {
        let nextPosition = dart.notNull(this[_position]) + 1;
        if (nextPosition < dart.notNull(this[_array][dartx.length])) {
          this[_current] = this[_array][dartx.get](nextPosition);
          this[_position] = nextPosition;
          return true;
        }
        this[_current] = null;
        this[_position] = this[_array][dartx.length];
        return false;
      }
      get current() {
        return this[_current];
      }
    }
    _VariableSizeListIterator[dart.implements] = () => [core.Iterator$(T)];
    dart.setSignature(_VariableSizeListIterator, {
      constructors: () => ({_VariableSizeListIterator: [_VariableSizeListIterator$(T), [core.List$(T)]]}),
      methods: () => ({moveNext: [core.bool, []]})
    });
    return _VariableSizeListIterator;
  });
  let _VariableSizeListIterator = _VariableSizeListIterator$();
  function _convertNativeToDart_Window(win) {
    if (win == null) return null;
    return _DOMWindowCrossFrame._createSafe(win);
  }
  dart.fn(_convertNativeToDart_Window, WindowBase, [dart.dynamic]);
  function _convertNativeToDart_EventTarget(e) {
    if (e == null) {
      return null;
    }
    if ("postMessage" in e) {
      let window = _DOMWindowCrossFrame._createSafe(e);
      if (dart.is(window, EventTarget)) {
        return window;
      }
      return null;
    } else
      return dart.as(e, EventTarget);
  }
  dart.fn(_convertNativeToDart_EventTarget, EventTarget, [dart.dynamic]);
  const _window = Symbol('_window');
  function _convertDartToNative_EventTarget(e) {
    if (dart.is(e, _DOMWindowCrossFrame)) {
      return dart.as(e[_window], EventTarget);
    } else {
      return dart.as(e, EventTarget);
    }
  }
  dart.fn(_convertDartToNative_EventTarget, EventTarget, [dart.dynamic]);
  function _convertNativeToDart_XHR_Response(o) {
    if (dart.is(o, Document)) {
      return o;
    }
    return html_common.convertNativeToDart_SerializedScriptValue(o);
  }
  dart.fn(_convertNativeToDart_XHR_Response);
  function _callConstructor(constructor, interceptor) {
    return dart.fn(receiver => {
      dart.dcall(/* Unimplemented unknown name */setNativeSubclassDispatchRecord, receiver, interceptor);
      receiver.constructor = receiver.__proto__.constructor;
      return constructor(receiver);
    });
  }
  dart.fn(_callConstructor);
  function _callAttached(receiver) {
    return dart.dsend(receiver, 'attached');
  }
  dart.fn(_callAttached);
  function _callDetached(receiver) {
    return dart.dsend(receiver, 'detached');
  }
  dart.fn(_callDetached);
  function _callAttributeChanged(receiver, name, oldValue, newValue) {
    return dart.dsend(receiver, 'attributeChanged', name, oldValue, newValue);
  }
  dart.fn(_callAttributeChanged);
  function _makeCallbackMethod(callback) {
    return (function(invokeCallback) {
      return function() {
        return invokeCallback(this);
      };
    })(dart.dcall(/* Unimplemented unknown name */convertDartClosureToJS, callback, 1));
  }
  dart.fn(_makeCallbackMethod);
  function _makeCallbackMethod3(callback) {
    return (function(invokeCallback) {
      return function(arg1, arg2, arg3) {
        return invokeCallback(this, arg1, arg2, arg3);
      };
    })(dart.dcall(/* Unimplemented unknown name */convertDartClosureToJS, callback, 4));
  }
  dart.fn(_makeCallbackMethod3);
  function _registerCustomElement(context, document, tag, type, extendsTagName) {
    let interceptorClass = dart.dcall(/* Unimplemented unknown name */findInterceptorConstructorForType, type);
    if (interceptorClass == null) {
      dart.throw(new core.ArgumentError(type));
    }
    let interceptor = interceptorClass.prototype;
    let constructor = dart.dcall(/* Unimplemented unknown name */findConstructorForNativeSubclassType, type, 'created');
    if (constructor == null) {
      dart.throw(new core.ArgumentError(`${type} has no constructor called 'created'`));
    }
    dart.dcall(/* Unimplemented unknown name */getNativeInterceptor, Element.tag('article'));
    let baseClassName = dart.as(dart.dcall(/* Unimplemented unknown name */findDispatchTagForInterceptorClass, interceptorClass), core.String);
    if (baseClassName == null) {
      dart.throw(new core.ArgumentError(type));
    }
    if (extendsTagName == null) {
      if (baseClassName != 'HTMLElement') {
        dart.throw(new core.UnsupportedError('Class must provide extendsTag if base ' + 'native class is not HtmlElement'));
      }
    } else {
      if (!(document.createElement(extendsTagName) instanceof window[baseClassName])) {
        dart.throw(new core.UnsupportedError('extendsTag does not match base native class'));
      }
    }
    let baseConstructor = context[baseClassName];
    let properties = {};
    properties.createdCallback = {value: _makeCallbackMethod(_callConstructor(constructor, interceptor))};
    properties.attachedCallback = {value: _makeCallbackMethod(_callAttached)};
    properties.detachedCallback = {value: _makeCallbackMethod(_callDetached)};
    properties.attributeChangedCallback = {value: _makeCallbackMethod3(_callAttributeChanged)};
    let baseProto = baseConstructor.prototype;
    let proto = Object.create(baseProto, properties);
    dart.dcall(/* Unimplemented unknown name */setNativeSubclassDispatchRecord, proto, interceptor);
    let options = {prototype: proto};
    if (extendsTagName != null) {
      options.extends = extendsTagName;
    }
    document.registerElement(tag, options);
  }
  dart.fn(_registerCustomElement, dart.void, [dart.dynamic, dart.dynamic, core.String, core.Type, core.String]);
  function _initializeCustomElement(e) {
  }
  dart.fn(_initializeCustomElement, dart.void, [Element]);
  const _interceptor = Symbol('_interceptor');
  const _constructor = Symbol('_constructor');
  const _nativeType = Symbol('_nativeType');
  class _JSElementUpgrader extends core.Object {
    _JSElementUpgrader(document, type, extendsTag) {
      this[_interceptor] = null;
      this[_constructor] = null;
      this[_nativeType] = null;
      let interceptorClass = dart.dcall(/* Unimplemented unknown name */findInterceptorConstructorForType, type);
      if (interceptorClass == null) {
        dart.throw(new core.ArgumentError(type));
      }
      this[_constructor] = dart.dcall(/* Unimplemented unknown name */findConstructorForNativeSubclassType, type, 'created');
      if (this[_constructor] == null) {
        dart.throw(new core.ArgumentError(`${type} has no constructor called 'created'`));
      }
      dart.dcall(/* Unimplemented unknown name */getNativeInterceptor, Element.tag('article'));
      let baseClassName = dart.dcall(/* Unimplemented unknown name */findDispatchTagForInterceptorClass, interceptorClass);
      if (baseClassName == null) {
        dart.throw(new core.ArgumentError(type));
      }
      if (extendsTag == null) {
        if (!dart.equals(baseClassName, 'HTMLElement')) {
          dart.throw(new core.UnsupportedError('Class must provide extendsTag if base ' + 'native class is not HtmlElement'));
        }
        this[_nativeType] = HtmlElement;
      } else {
        let element = document[dartx.createElement](extendsTag);
        if (!(element instanceof window[baseClassName])) {
          dart.throw(new core.UnsupportedError('extendsTag does not match base native class'));
        }
        this[_nativeType] = dart.runtimeType(element);
      }
      this[_interceptor] = interceptorClass.prototype;
    }
    upgrade(element) {
      if (!dart.equals(dart.runtimeType(element), this[_nativeType])) {
        dart.throw(new core.ArgumentError(`element is not subclass of ${this[_nativeType]}`));
      }
      dart.dcall(/* Unimplemented unknown name */setNativeSubclassDispatchRecord, element, this[_interceptor]);
      this[_constructor](element);
      return element;
    }
  }
  _JSElementUpgrader[dart.implements] = () => [ElementUpgrader];
  dart.setSignature(_JSElementUpgrader, {
    constructors: () => ({_JSElementUpgrader: [_JSElementUpgrader, [Document, core.Type, core.String]]}),
    methods: () => ({upgrade: [Element, [Element]]})
  });
  class _DOMWindowCrossFrame extends core.Object {
    get history() {
      return _HistoryCrossFrame._createSafe(this[_window].history);
    }
    get location() {
      return _LocationCrossFrame._createSafe(this[_window].location);
    }
    get closed() {
      return this[_window].closed;
    }
    get opener() {
      return _DOMWindowCrossFrame._createSafe(this[_window].opener);
    }
    get parent() {
      return _DOMWindowCrossFrame._createSafe(this[_window].parent);
    }
    get top() {
      return _DOMWindowCrossFrame._createSafe(this[_window].top);
    }
    close() {
      return this[_window].close();
    }
    postMessage(message, targetOrigin, messagePorts) {
      if (messagePorts === void 0) messagePorts = null;
      if (messagePorts == null) {
        this[_window].postMessage(html_common.convertDartToNative_SerializedScriptValue(message), targetOrigin);
      } else {
        this[_window].postMessage(html_common.convertDartToNative_SerializedScriptValue(message), targetOrigin, messagePorts);
      }
    }
    _DOMWindowCrossFrame(window) {
      this[_window] = window;
    }
    static _createSafe(w) {
      if (core.identical(w, exports.window)) {
        return dart.as(w, WindowBase);
      } else {
        return new _DOMWindowCrossFrame(w);
      }
    }
    get on() {
      return dart.throw(new core.UnsupportedError('You can only attach EventListeners to your own window.'));
    }
    [_addEventListener](type, listener, useCapture) {
      if (type === void 0) type = null;
      if (listener === void 0) listener = null;
      if (useCapture === void 0) useCapture = null;
      return dart.throw(new core.UnsupportedError('You can only attach EventListeners to your own window.'));
    }
    addEventListener(type, listener, useCapture) {
      if (useCapture === void 0) useCapture = null;
      return dart.throw(new core.UnsupportedError('You can only attach EventListeners to your own window.'));
    }
    dispatchEvent(event) {
      return dart.throw(new core.UnsupportedError('You can only attach EventListeners to your own window.'));
    }
    [_removeEventListener](type, listener, useCapture) {
      if (type === void 0) type = null;
      if (listener === void 0) listener = null;
      if (useCapture === void 0) useCapture = null;
      return dart.throw(new core.UnsupportedError('You can only attach EventListeners to your own window.'));
    }
    removeEventListener(type, listener, useCapture) {
      if (useCapture === void 0) useCapture = null;
      return dart.throw(new core.UnsupportedError('You can only attach EventListeners to your own window.'));
    }
  }
  _DOMWindowCrossFrame[dart.implements] = () => [WindowBase];
  dart.setSignature(_DOMWindowCrossFrame, {
    constructors: () => ({_DOMWindowCrossFrame: [_DOMWindowCrossFrame, [dart.dynamic]]}),
    methods: () => ({
      close: [dart.void, []],
      postMessage: [dart.void, [dart.dynamic, core.String], [core.List]],
      [_addEventListener]: [dart.void, [], [core.String, EventListener, core.bool]],
      addEventListener: [dart.void, [core.String, EventListener], [core.bool]],
      dispatchEvent: [core.bool, [Event]],
      [_removeEventListener]: [dart.void, [], [core.String, EventListener, core.bool]],
      removeEventListener: [dart.void, [core.String, EventListener], [core.bool]]
    }),
    statics: () => ({_createSafe: [WindowBase, [dart.dynamic]]}),
    names: ['_createSafe']
  });
  dart.defineExtensionMembers(_DOMWindowCrossFrame, [
    'close',
    'postMessage',
    _addEventListener,
    'addEventListener',
    'dispatchEvent',
    _removeEventListener,
    'removeEventListener',
    'history',
    'location',
    'closed',
    'opener',
    'parent',
    'top',
    'on'
  ]);
  class _LocationCrossFrame extends core.Object {
    set href(val) {
      return _LocationCrossFrame._setHref(this[_location], val);
    }
    static _setHref(location, val) {
      location.href = val;
    }
    _LocationCrossFrame(location) {
      this[_location] = location;
    }
    static _createSafe(location) {
      if (core.identical(location, exports.window[dartx.location])) {
        return dart.as(location, LocationBase);
      } else {
        return new _LocationCrossFrame(location);
      }
    }
  }
  _LocationCrossFrame[dart.implements] = () => [LocationBase];
  dart.setSignature(_LocationCrossFrame, {
    constructors: () => ({_LocationCrossFrame: [_LocationCrossFrame, [dart.dynamic]]}),
    statics: () => ({
      _setHref: [dart.void, [dart.dynamic, dart.dynamic]],
      _createSafe: [LocationBase, [dart.dynamic]]
    }),
    names: ['_setHref', '_createSafe']
  });
  dart.defineExtensionMembers(_LocationCrossFrame, ['href']);
  const _history = Symbol('_history');
  class _HistoryCrossFrame extends core.Object {
    back() {
      return this[_history].back();
    }
    forward() {
      return this[_history].forward();
    }
    go(distance) {
      return this[_history].go(distance);
    }
    _HistoryCrossFrame(history) {
      this[_history] = history;
    }
    static _createSafe(h) {
      if (core.identical(h, exports.window[dartx.history])) {
        return dart.as(h, HistoryBase);
      } else {
        return new _HistoryCrossFrame(h);
      }
    }
  }
  _HistoryCrossFrame[dart.implements] = () => [HistoryBase];
  dart.setSignature(_HistoryCrossFrame, {
    constructors: () => ({_HistoryCrossFrame: [_HistoryCrossFrame, [dart.dynamic]]}),
    methods: () => ({
      back: [dart.void, []],
      forward: [dart.void, []],
      go: [dart.void, [core.int]]
    }),
    statics: () => ({_createSafe: [HistoryBase, [dart.dynamic]]}),
    names: ['_createSafe']
  });
  dart.defineExtensionMembers(_HistoryCrossFrame, ['back', 'forward', 'go']);
  class Platform extends core.Object {}
  Platform.supportsSimd = false;
  dart.defineLazyProperties(Platform, {
    get supportsTypedData() {
      return !!window.ArrayBuffer;
    }
  });
  function _wrapZone(callback) {
    if (dart.equals(async.Zone.current, async.Zone.ROOT)) return callback;
    if (callback == null) return null;
    return async.Zone.current.bindUnaryCallback(callback, {runGuarded: true});
  }
  dart.fn(_wrapZone, dart.dynamic, [dart.functionType(dart.dynamic, [dart.dynamic])]);
  function _wrapBinaryZone(callback) {
    if (dart.equals(async.Zone.current, async.Zone.ROOT)) return callback;
    if (callback == null) return null;
    return async.Zone.current.bindBinaryCallback(callback, {runGuarded: true});
  }
  dart.fn(_wrapBinaryZone, dart.dynamic, [dart.functionType(dart.dynamic, [dart.dynamic, dart.dynamic])]);
  function query(relativeSelectors) {
    return exports.document[dartx.query](relativeSelectors);
  }
  dart.fn(query, Element, [core.String]);
  function queryAll(relativeSelectors) {
    return exports.document[dartx.queryAll](relativeSelectors);
  }
  dart.fn(queryAll, ElementList$(Element), [core.String]);
  function querySelector(selectors) {
    return exports.document[dartx.querySelector](selectors);
  }
  dart.fn(querySelector, Element, [core.String]);
  function querySelectorAll(selectors) {
    return exports.document[dartx.querySelectorAll](selectors);
  }
  dart.fn(querySelectorAll, ElementList$(Element), [core.String]);
  class ElementUpgrader extends core.Object {}
  class NodeValidator extends core.Object {
    static new(opts) {
      let uriPolicy = opts && 'uriPolicy' in opts ? opts.uriPolicy : null;
      return new _Html5NodeValidator({uriPolicy: uriPolicy});
    }
    static throws(base) {
      return new _ThrowsNodeValidator(base);
    }
  }
  dart.setSignature(NodeValidator, {
    constructors: () => ({
      new: [NodeValidator, [], {uriPolicy: UriPolicy}],
      throws: [NodeValidator, [NodeValidator]]
    })
  });
  class NodeTreeSanitizer extends core.Object {
    static new(validator) {
      return new _ValidatingTreeSanitizer(validator);
    }
  }
  dart.setSignature(NodeTreeSanitizer, {
    constructors: () => ({new: [NodeTreeSanitizer, [NodeValidator]]})
  });
  dart.defineLazyProperties(NodeTreeSanitizer, {
    get trusted() {
      return dart.const(new _TrustedHtmlTreeSanitizer());
    }
  });
  class _TrustedHtmlTreeSanitizer extends core.Object {
    _TrustedHtmlTreeSanitizer() {
    }
    sanitizeTree(node) {}
  }
  _TrustedHtmlTreeSanitizer[dart.implements] = () => [NodeTreeSanitizer];
  dart.setSignature(_TrustedHtmlTreeSanitizer, {
    constructors: () => ({_TrustedHtmlTreeSanitizer: [_TrustedHtmlTreeSanitizer, []]}),
    methods: () => ({sanitizeTree: [dart.void, [Node]]})
  });
  class UriPolicy extends core.Object {
    static new() {
      return new _SameOriginUriPolicy();
    }
  }
  dart.setSignature(UriPolicy, {
    constructors: () => ({new: [UriPolicy, []]})
  });
  const _hiddenAnchor = Symbol('_hiddenAnchor');
  const _loc = Symbol('_loc');
  class _SameOriginUriPolicy extends core.Object {
    _SameOriginUriPolicy() {
      this[_hiddenAnchor] = AnchorElement.new();
      this[_loc] = exports.window[dartx.location];
    }
    allowsUri(uri) {
      this[_hiddenAnchor][dartx.href] = uri;
      return this[_hiddenAnchor][dartx.hostname] == this[_loc][dartx.hostname] && this[_hiddenAnchor][dartx.port] == this[_loc][dartx.port] && this[_hiddenAnchor][dartx.protocol] == this[_loc][dartx.protocol] || this[_hiddenAnchor][dartx.hostname] == '' && this[_hiddenAnchor][dartx.port] == '' && (this[_hiddenAnchor][dartx.protocol] == ':' || this[_hiddenAnchor][dartx.protocol] == '');
    }
  }
  _SameOriginUriPolicy[dart.implements] = () => [UriPolicy];
  dart.setSignature(_SameOriginUriPolicy, {
    methods: () => ({allowsUri: [core.bool, [core.String]]})
  });
  class _ThrowsNodeValidator extends core.Object {
    _ThrowsNodeValidator(validator) {
      this.validator = validator;
    }
    allowsElement(element) {
      if (!dart.notNull(this.validator.allowsElement(element))) {
        dart.throw(new core.ArgumentError(Element._safeTagName(element)));
      }
      return true;
    }
    allowsAttribute(element, attributeName, value) {
      if (!dart.notNull(this.validator.allowsAttribute(element, attributeName, value))) {
        dart.throw(new core.ArgumentError(`${Element._safeTagName(element)}[${attributeName}="${value}"]`));
      }
    }
  }
  _ThrowsNodeValidator[dart.implements] = () => [NodeValidator];
  dart.setSignature(_ThrowsNodeValidator, {
    constructors: () => ({_ThrowsNodeValidator: [_ThrowsNodeValidator, [NodeValidator]]}),
    methods: () => ({
      allowsElement: [core.bool, [Element]],
      allowsAttribute: [core.bool, [Element, core.String, core.String]]
    })
  });
  const _removeNode = Symbol('_removeNode');
  const _sanitizeElement = Symbol('_sanitizeElement');
  const _sanitizeUntrustedElement = Symbol('_sanitizeUntrustedElement');
  class _ValidatingTreeSanitizer extends core.Object {
    _ValidatingTreeSanitizer(validator) {
      this.validator = validator;
    }
    sanitizeTree(node) {
      const walk = (function(node, parent) {
        this.sanitizeNode(node, parent);
        let child = node[dartx.lastChild];
        while (child != null) {
          let nextChild = child[dartx.previousNode];
          walk(child, node);
          child = nextChild;
        }
      }).bind(this);
      dart.fn(walk, dart.void, [Node, Node]);
      walk(node, null);
    }
    [_removeNode](node, parent) {
      if (parent == null) {
        node[dartx.remove]();
      } else {
        parent[_removeChild](node);
      }
    }
    [_sanitizeUntrustedElement](element, parent) {
      let corrupted = true;
      let attrs = null;
      let isAttr = null;
      try {
        attrs = dart.dload(element, 'attributes');
        isAttr = dart.dindex(attrs, 'is');
        let corruptedTest1 = Element._hasCorruptedAttributes(dart.as(element, Element));
        corrupted = dart.notNull(corruptedTest1) ? true : Element._hasCorruptedAttributesAdditionalCheck(dart.as(element, Element));
      } catch (e) {
      }

      let elementText = 'element unprintable';
      try {
        elementText = dart.toString(element);
      } catch (e) {
      }

      try {
        let elementTagName = Element._safeTagName(element);
        this[_sanitizeElement](dart.as(element, Element), parent, corrupted, elementText, elementTagName, dart.as(attrs, core.Map), dart.as(isAttr, core.String));
      } catch (e$) {
        if (dart.is(e$, core.ArgumentError)) {
          throw e$;
        } else {
          let e = e$;
          this[_removeNode](dart.as(element, Node), parent);
          exports.window[dartx.console].warn(`Removing corrupted element ${elementText}`);
        }
      }

    }
    [_sanitizeElement](element, parent, corrupted, text, tag, attrs, isAttr) {
      if (false != corrupted) {
        this[_removeNode](element, parent);
        exports.window[dartx.console].warn(`Removing element due to corrupted attributes on <${text}>`);
        return;
      }
      if (!dart.notNull(this.validator.allowsElement(element))) {
        this[_removeNode](element, parent);
        exports.window[dartx.console].warn(`Removing disallowed element <${tag}> from ${parent}`);
        return;
      }
      if (isAttr != null) {
        if (!dart.notNull(this.validator.allowsAttribute(element, 'is', isAttr))) {
          this[_removeNode](element, parent);
          exports.window[dartx.console].warn('Removing disallowed type extension ' + `<${tag} is="${isAttr}">`);
          return;
        }
      }
      let keys = attrs[dartx.keys][dartx.toList]();
      for (let i = dart.notNull(attrs[dartx.length]) - 1; i >= 0; --i) {
        let name = keys[dartx.get](i);
        if (!dart.notNull(this.validator.allowsAttribute(element, dart.as(dart.dsend(name, 'toLowerCase'), core.String), dart.as(attrs[dartx.get](name), core.String)))) {
          exports.window[dartx.console].warn('Removing disallowed attribute ' + `<${tag} ${name}="${attrs[dartx.get](name)}">`);
          attrs[dartx.remove](name);
        }
      }
      if (dart.is(element, TemplateElement)) {
        let template = element;
        this.sanitizeTree(template[dartx.content]);
      }
    }
    sanitizeNode(node, parent) {
      switch (node[dartx.nodeType]) {
        case Node.ELEMENT_NODE:
        {
          this[_sanitizeUntrustedElement](node, parent);
          break;
        }
        case Node.COMMENT_NODE:
        case Node.DOCUMENT_FRAGMENT_NODE:
        case Node.TEXT_NODE:
        case Node.CDATA_SECTION_NODE:
        {
          break;
        }
        default:
        {
          this[_removeNode](node, parent);
        }
      }
    }
  }
  _ValidatingTreeSanitizer[dart.implements] = () => [NodeTreeSanitizer];
  dart.setSignature(_ValidatingTreeSanitizer, {
    constructors: () => ({_ValidatingTreeSanitizer: [_ValidatingTreeSanitizer, [NodeValidator]]}),
    methods: () => ({
      sanitizeTree: [dart.void, [Node]],
      [_removeNode]: [dart.void, [Node, Node]],
      [_sanitizeUntrustedElement]: [dart.void, [dart.dynamic, Node]],
      [_sanitizeElement]: [dart.void, [Element, Node, core.bool, core.String, core.String, core.Map, core.String]],
      sanitizeNode: [dart.void, [Node, Node]]
    })
  });
  const __CastType0 = dart.typedef('__CastType0', () => dart.functionType(core.bool, [Element]));
  const __CastType2 = dart.typedef('__CastType2', () => dart.functionType(dart.dynamic, [dart.dynamic]));
  // Exports:
  exports.EventTarget = EventTarget;
  exports.Node = Node;
  exports.Element = Element;
  exports.HtmlElement = HtmlElement;
  exports.spawnDomUri = spawnDomUri;
  exports.unwrap_jso = unwrap_jso;
  exports.wrap_jso = wrap_jso;
  exports.createCustomUpgrader = createCustomUpgrader;
  exports.AbstractWorker = AbstractWorker;
  exports.AnchorElement = AnchorElement;
  exports.AnimationNode = AnimationNode;
  exports.Animation = Animation;
  exports.AnimationEffect = AnimationEffect;
  exports.Event = Event;
  exports.AnimationEvent = AnimationEvent;
  exports.AnimationPlayer = AnimationPlayer;
  exports.AnimationPlayerEvent = AnimationPlayerEvent;
  exports.AnimationTimeline = AnimationTimeline;
  exports.ApplicationCache = ApplicationCache;
  exports.ApplicationCacheErrorEvent = ApplicationCacheErrorEvent;
  exports.AreaElement = AreaElement;
  exports.MediaElement = MediaElement;
  exports.AudioElement = AudioElement;
  exports.AudioTrack = AudioTrack;
  exports.AudioTrackList = AudioTrackList;
  exports.AutocompleteErrorEvent = AutocompleteErrorEvent;
  exports.BRElement = BRElement;
  exports.BarProp = BarProp;
  exports.BaseElement = BaseElement;
  exports.BatteryManager = BatteryManager;
  exports.BeforeUnloadEvent = BeforeUnloadEvent;
  exports.Blob = Blob;
  exports.Body = Body;
  exports.BodyElement = BodyElement;
  exports.ButtonElement = ButtonElement;
  exports.CharacterData = CharacterData;
  exports.Text = Text;
  exports.CDataSection = CDataSection;
  exports.CacheStorage = CacheStorage;
  exports.Canvas2DContextAttributes = Canvas2DContextAttributes;
  exports.CanvasElement = CanvasElement;
  exports.CanvasGradient = CanvasGradient;
  exports.CanvasPattern = CanvasPattern;
  exports.CanvasRenderingContext = CanvasRenderingContext;
  exports.CanvasRenderingContext2D = CanvasRenderingContext2D;
  exports.ChildNode = ChildNode;
  exports.GeofencingRegion = GeofencingRegion;
  exports.CircularGeofencingRegion = CircularGeofencingRegion;
  exports.CloseEvent = CloseEvent;
  exports.Comment = Comment;
  exports.UIEvent = UIEvent;
  exports.CompositionEvent = CompositionEvent;
  exports.Console = Console;
  exports.ConsoleBase = ConsoleBase;
  exports.ContentElement = ContentElement;
  exports.Coordinates = Coordinates;
  exports.Credential = Credential;
  exports.CredentialsContainer = CredentialsContainer;
  exports.Crypto = Crypto;
  exports.CryptoKey = CryptoKey;
  exports.Css = Css;
  exports.CssRule = CssRule;
  exports.CssCharsetRule = CssCharsetRule;
  exports.CssFilterRule = CssFilterRule;
  exports.CssFontFaceRule = CssFontFaceRule;
  exports.CssImportRule = CssImportRule;
  exports.CssKeyframeRule = CssKeyframeRule;
  exports.CssKeyframesRule = CssKeyframesRule;
  exports.CssMediaRule = CssMediaRule;
  exports.CssPageRule = CssPageRule;
  exports.CssStyleDeclarationBase = CssStyleDeclarationBase;
  exports.CssStyleDeclaration = CssStyleDeclaration;
  exports.CssStyleRule = CssStyleRule;
  exports.StyleSheet = StyleSheet;
  exports.CssStyleSheet = CssStyleSheet;
  exports.CssSupportsRule = CssSupportsRule;
  exports.CssViewportRule = CssViewportRule;
  exports.CustomEvent = CustomEvent;
  exports.DListElement = DListElement;
  exports.DataListElement = DataListElement;
  exports.DataTransfer = DataTransfer;
  exports.DataTransferItem = DataTransferItem;
  exports.DataTransferItemList = DataTransferItemList;
  exports.DatabaseCallback = DatabaseCallback;
  exports.WorkerGlobalScope = WorkerGlobalScope;
  exports.DedicatedWorkerGlobalScope = DedicatedWorkerGlobalScope;
  exports.DeprecatedStorageInfo = DeprecatedStorageInfo;
  exports.DeprecatedStorageQuota = DeprecatedStorageQuota;
  exports.DetailsElement = DetailsElement;
  exports.DeviceAcceleration = DeviceAcceleration;
  exports.DeviceLightEvent = DeviceLightEvent;
  exports.DeviceMotionEvent = DeviceMotionEvent;
  exports.DeviceOrientationEvent = DeviceOrientationEvent;
  exports.DeviceRotationRate = DeviceRotationRate;
  exports.DialogElement = DialogElement;
  exports.Entry = Entry;
  exports.DirectoryEntry = DirectoryEntry;
  exports.DirectoryReader = DirectoryReader;
  exports.DivElement = DivElement;
  exports.Document = Document;
  exports.DocumentFragment = DocumentFragment;
  exports.DomError = DomError;
  exports.DomException = DomException;
  exports.DomImplementation = DomImplementation;
  exports.DomIterator = DomIterator;
  exports.DomMatrixReadOnly = DomMatrixReadOnly;
  exports.DomMatrix = DomMatrix;
  exports.DomParser = DomParser;
  exports.DomPointReadOnly = DomPointReadOnly;
  exports.DomPoint = DomPoint;
  exports.DomRectReadOnly = DomRectReadOnly;
  exports.DomTokenList = DomTokenList;
  exports.DomSettableTokenList = DomSettableTokenList;
  exports.ImmutableListMixin$ = ImmutableListMixin$;
  exports.ImmutableListMixin = ImmutableListMixin;
  exports.DomStringList = DomStringList;
  exports.DomStringMap = DomStringMap;
  exports.ElementList$ = ElementList$;
  exports.ElementList = ElementList;
  exports.ScrollAlignment = ScrollAlignment;
  exports.EmbedElement = EmbedElement;
  exports.ErrorEvent = ErrorEvent;
  exports.EventSource = EventSource;
  exports.Events = Events;
  exports.ElementEvents = ElementEvents;
  exports.ExtendableEvent = ExtendableEvent;
  exports.FederatedCredential = FederatedCredential;
  exports.FetchEvent = FetchEvent;
  exports.FieldSetElement = FieldSetElement;
  exports.File = File;
  exports.FileEntry = FileEntry;
  exports.FileError = FileError;
  exports.FileList = FileList;
  exports.FileReader = FileReader;
  exports.FileStream = FileStream;
  exports.FileSystem = FileSystem;
  exports.FileWriter = FileWriter;
  exports.FocusEvent = FocusEvent;
  exports.FontFace = FontFace;
  exports.FontFaceSet = FontFaceSet;
  exports.FontFaceSetForEachCallback = FontFaceSetForEachCallback;
  exports.FontFaceSetLoadEvent = FontFaceSetLoadEvent;
  exports.FormData = FormData;
  exports.FormElement = FormElement;
  exports.Gamepad = Gamepad;
  exports.GamepadButton = GamepadButton;
  exports.GamepadEvent = GamepadEvent;
  exports.Geofencing = Geofencing;
  exports.Geolocation = Geolocation;
  exports.Geoposition = Geoposition;
  exports.GlobalEventHandlers = GlobalEventHandlers;
  exports.HRElement = HRElement;
  exports.HashChangeEvent = HashChangeEvent;
  exports.HeadElement = HeadElement;
  exports.Headers = Headers;
  exports.HeadersForEachCallback = HeadersForEachCallback;
  exports.HeadingElement = HeadingElement;
  exports.History = History;
  exports.HtmlCollection = HtmlCollection;
  exports.HtmlDocument = HtmlDocument;
  exports.HtmlFormControlsCollection = HtmlFormControlsCollection;
  exports.HtmlHtmlElement = HtmlHtmlElement;
  exports.HtmlOptionsCollection = HtmlOptionsCollection;
  exports.HttpRequestEventTarget = HttpRequestEventTarget;
  exports.HttpRequest = HttpRequest;
  exports.HttpRequestUpload = HttpRequestUpload;
  exports.IFrameElement = IFrameElement;
  exports.ImageBitmap = ImageBitmap;
  exports.ImageData = ImageData;
  exports.ImageElement = ImageElement;
  exports.InjectedScriptHost = InjectedScriptHost;
  exports.InputElement = InputElement;
  exports.InputElementBase = InputElementBase;
  exports.HiddenInputElement = HiddenInputElement;
  exports.TextInputElementBase = TextInputElementBase;
  exports.SearchInputElement = SearchInputElement;
  exports.TextInputElement = TextInputElement;
  exports.UrlInputElement = UrlInputElement;
  exports.TelephoneInputElement = TelephoneInputElement;
  exports.EmailInputElement = EmailInputElement;
  exports.PasswordInputElement = PasswordInputElement;
  exports.RangeInputElementBase = RangeInputElementBase;
  exports.DateInputElement = DateInputElement;
  exports.MonthInputElement = MonthInputElement;
  exports.WeekInputElement = WeekInputElement;
  exports.TimeInputElement = TimeInputElement;
  exports.LocalDateTimeInputElement = LocalDateTimeInputElement;
  exports.NumberInputElement = NumberInputElement;
  exports.RangeInputElement = RangeInputElement;
  exports.CheckboxInputElement = CheckboxInputElement;
  exports.RadioButtonInputElement = RadioButtonInputElement;
  exports.FileUploadInputElement = FileUploadInputElement;
  exports.SubmitButtonInputElement = SubmitButtonInputElement;
  exports.ImageButtonInputElement = ImageButtonInputElement;
  exports.ResetButtonInputElement = ResetButtonInputElement;
  exports.ButtonInputElement = ButtonInputElement;
  exports.InputMethodContext = InputMethodContext;
  exports.InstallEvent = InstallEvent;
  exports.KeyboardEvent = KeyboardEvent;
  exports.KeygenElement = KeygenElement;
  exports.LIElement = LIElement;
  exports.LabelElement = LabelElement;
  exports.LegendElement = LegendElement;
  exports.LinkElement = LinkElement;
  exports.LocalCredential = LocalCredential;
  exports.Location = Location;
  exports.MidiErrorCallback = MidiErrorCallback;
  exports.MidiSuccessCallback = MidiSuccessCallback;
  exports.MapElement = MapElement;
  exports.MediaController = MediaController;
  exports.MediaDeviceInfo = MediaDeviceInfo;
  exports.MediaDeviceInfoCallback = MediaDeviceInfoCallback;
  exports.MediaError = MediaError;
  exports.MediaKeyError = MediaKeyError;
  exports.MediaKeyEvent = MediaKeyEvent;
  exports.MediaKeyMessageEvent = MediaKeyMessageEvent;
  exports.MediaKeyNeededEvent = MediaKeyNeededEvent;
  exports.MediaKeySession = MediaKeySession;
  exports.MediaKeys = MediaKeys;
  exports.MediaList = MediaList;
  exports.MediaQueryList = MediaQueryList;
  exports.MediaQueryListEvent = MediaQueryListEvent;
  exports.MediaSource = MediaSource;
  exports.MediaStream = MediaStream;
  exports.MediaStreamEvent = MediaStreamEvent;
  exports.MediaStreamTrack = MediaStreamTrack;
  exports.MediaStreamTrackEvent = MediaStreamTrackEvent;
  exports.MediaStreamTrackSourcesCallback = MediaStreamTrackSourcesCallback;
  exports.MemoryInfo = MemoryInfo;
  exports.MenuElement = MenuElement;
  exports.MenuItemElement = MenuItemElement;
  exports.MessageChannel = MessageChannel;
  exports.MessageEvent = MessageEvent;
  exports.MessagePort = MessagePort;
  exports.MetaElement = MetaElement;
  exports.Metadata = Metadata;
  exports.MetadataCallback = MetadataCallback;
  exports.MeterElement = MeterElement;
  exports.MidiAccess = MidiAccess;
  exports.MidiConnectionEvent = MidiConnectionEvent;
  exports.MidiPort = MidiPort;
  exports.MidiInput = MidiInput;
  exports.MidiInputMap = MidiInputMap;
  exports.MidiMessageEvent = MidiMessageEvent;
  exports.MidiOutput = MidiOutput;
  exports.MidiOutputMap = MidiOutputMap;
  exports.MimeType = MimeType;
  exports.MimeTypeArray = MimeTypeArray;
  exports.ModElement = ModElement;
  exports.MouseEvent = MouseEvent;
  exports.MutationCallback = MutationCallback;
  exports.MutationObserver = MutationObserver;
  exports.MutationRecord = MutationRecord;
  exports.Navigator = Navigator;
  exports.NavigatorCpu = NavigatorCpu;
  exports.NavigatorID = NavigatorID;
  exports.NavigatorLanguage = NavigatorLanguage;
  exports.NavigatorOnLine = NavigatorOnLine;
  exports.NavigatorUserMediaError = NavigatorUserMediaError;
  exports.NetworkInformation = NetworkInformation;
  exports.NodeFilter = NodeFilter;
  exports.NodeIterator = NodeIterator;
  exports.NodeList = NodeList;
  exports.Notification = Notification;
  exports.OListElement = OListElement;
  exports.ObjectElement = ObjectElement;
  exports.OptGroupElement = OptGroupElement;
  exports.OptionElement = OptionElement;
  exports.OutputElement = OutputElement;
  exports.OverflowEvent = OverflowEvent;
  exports.PageTransitionEvent = PageTransitionEvent;
  exports.ParagraphElement = ParagraphElement;
  exports.ParamElement = ParamElement;
  exports.ParentNode = ParentNode;
  exports.Path2D = Path2D;
  exports.Performance = Performance;
  exports.PerformanceEntry = PerformanceEntry;
  exports.PerformanceMark = PerformanceMark;
  exports.PerformanceMeasure = PerformanceMeasure;
  exports.PerformanceNavigation = PerformanceNavigation;
  exports.PerformanceResourceTiming = PerformanceResourceTiming;
  exports.PerformanceTiming = PerformanceTiming;
  exports.PictureElement = PictureElement;
  exports.Plugin = Plugin;
  exports.PluginArray = PluginArray;
  exports.PluginPlaceholderElement = PluginPlaceholderElement;
  exports.PopStateEvent = PopStateEvent;
  exports.PositionError = PositionError;
  exports.PreElement = PreElement;
  exports.Presentation = Presentation;
  exports.ProcessingInstruction = ProcessingInstruction;
  exports.ProgressElement = ProgressElement;
  exports.ProgressEvent = ProgressEvent;
  exports.PushEvent = PushEvent;
  exports.PushManager = PushManager;
  exports.PushRegistration = PushRegistration;
  exports.QuoteElement = QuoteElement;
  exports.RtcStatsCallback = RtcStatsCallback;
  exports.Range = Range;
  exports.ReadableStream = ReadableStream;
  exports.RelatedEvent = RelatedEvent;
  exports.RequestAnimationFrameCallback = RequestAnimationFrameCallback;
  exports.ResourceProgressEvent = ResourceProgressEvent;
  exports.RtcDataChannel = RtcDataChannel;
  exports.RtcDataChannelEvent = RtcDataChannelEvent;
  exports.RtcDtmfSender = RtcDtmfSender;
  exports.RtcDtmfToneChangeEvent = RtcDtmfToneChangeEvent;
  exports.RtcIceCandidate = RtcIceCandidate;
  exports.RtcIceCandidateEvent = RtcIceCandidateEvent;
  exports.RtcPeerConnection = RtcPeerConnection;
  exports.RtcSessionDescription = RtcSessionDescription;
  exports.RtcStatsReport = RtcStatsReport;
  exports.RtcStatsResponse = RtcStatsResponse;
  exports.Screen = Screen;
  exports.ScreenOrientation = ScreenOrientation;
  exports.ScriptElement = ScriptElement;
  exports.SecurityPolicyViolationEvent = SecurityPolicyViolationEvent;
  exports.SelectElement = SelectElement;
  exports.Selection = Selection;
  exports.ServiceWorkerClient = ServiceWorkerClient;
  exports.ServiceWorkerClients = ServiceWorkerClients;
  exports.ServiceWorkerContainer = ServiceWorkerContainer;
  exports.ServiceWorkerGlobalScope = ServiceWorkerGlobalScope;
  exports.ServiceWorkerRegistration = ServiceWorkerRegistration;
  exports.ShadowElement = ShadowElement;
  exports.ShadowRoot = ShadowRoot;
  exports.SharedWorker = SharedWorker;
  exports.SharedWorkerGlobalScope = SharedWorkerGlobalScope;
  exports.SourceBuffer = SourceBuffer;
  exports.SourceBufferList = SourceBufferList;
  exports.SourceElement = SourceElement;
  exports.SourceInfo = SourceInfo;
  exports.SpanElement = SpanElement;
  exports.SpeechGrammar = SpeechGrammar;
  exports.SpeechGrammarList = SpeechGrammarList;
  exports.SpeechRecognition = SpeechRecognition;
  exports.SpeechRecognitionAlternative = SpeechRecognitionAlternative;
  exports.SpeechRecognitionError = SpeechRecognitionError;
  exports.SpeechRecognitionEvent = SpeechRecognitionEvent;
  exports.SpeechRecognitionResult = SpeechRecognitionResult;
  exports.SpeechSynthesis = SpeechSynthesis;
  exports.SpeechSynthesisEvent = SpeechSynthesisEvent;
  exports.SpeechSynthesisUtterance = SpeechSynthesisUtterance;
  exports.SpeechSynthesisVoice = SpeechSynthesisVoice;
  exports.Storage = Storage;
  exports.StorageErrorCallback = StorageErrorCallback;
  exports.StorageEvent = StorageEvent;
  exports.StorageInfo = StorageInfo;
  exports.StorageQuota = StorageQuota;
  exports.StorageQuotaCallback = StorageQuotaCallback;
  exports.StorageUsageCallback = StorageUsageCallback;
  exports.StyleElement = StyleElement;
  exports.StyleMedia = StyleMedia;
  exports.TableCaptionElement = TableCaptionElement;
  exports.TableCellElement = TableCellElement;
  exports.TableColElement = TableColElement;
  exports.TableElement = TableElement;
  exports.TableRowElement = TableRowElement;
  exports.TableSectionElement = TableSectionElement;
  exports.TemplateElement = TemplateElement;
  exports.TextAreaElement = TextAreaElement;
  exports.TextEvent = TextEvent;
  exports.TextMetrics = TextMetrics;
  exports.TextTrack = TextTrack;
  exports.TextTrackCue = TextTrackCue;
  exports.TextTrackCueList = TextTrackCueList;
  exports.TextTrackList = TextTrackList;
  exports.TimeRanges = TimeRanges;
  exports.TimeoutHandler = TimeoutHandler;
  exports.Timing = Timing;
  exports.TitleElement = TitleElement;
  exports.Touch = Touch;
  exports.TouchEvent = TouchEvent;
  exports.TouchList = TouchList;
  exports.TrackElement = TrackElement;
  exports.TrackEvent = TrackEvent;
  exports.TransitionEvent = TransitionEvent;
  exports.TreeWalker = TreeWalker;
  exports.UListElement = UListElement;
  exports.UnknownElement = UnknownElement;
  exports.Url = Url;
  exports.UrlUtils = UrlUtils;
  exports.UrlUtilsReadOnly = UrlUtilsReadOnly;
  exports.ValidityState = ValidityState;
  exports.VideoElement = VideoElement;
  exports.VideoPlaybackQuality = VideoPlaybackQuality;
  exports.VideoTrack = VideoTrack;
  exports.VideoTrackList = VideoTrackList;
  exports.VoidCallback = VoidCallback;
  exports.VttCue = VttCue;
  exports.VttRegion = VttRegion;
  exports.VttRegionList = VttRegionList;
  exports.WebSocket = WebSocket;
  exports.WheelEvent = WheelEvent;
  exports.Window = Window;
  exports.WindowBase64 = WindowBase64;
  exports.WindowEventHandlers = WindowEventHandlers;
  exports.Worker = Worker;
  exports.WorkerConsole = WorkerConsole;
  exports.WorkerPerformance = WorkerPerformance;
  exports.XPathEvaluator = XPathEvaluator;
  exports.XPathExpression = XPathExpression;
  exports.XPathNSResolver = XPathNSResolver;
  exports.XPathResult = XPathResult;
  exports.XmlDocument = XmlDocument;
  exports.XmlSerializer = XmlSerializer;
  exports.XsltProcessor = XsltProcessor;
  exports.CanvasImageSource = CanvasImageSource;
  exports.WindowBase = WindowBase;
  exports.LocationBase = LocationBase;
  exports.HistoryBase = HistoryBase;
  exports.CssClassSet = CssClassSet;
  exports.CssRect = CssRect;
  exports.Dimension = Dimension;
  exports.EventListener = EventListener;
  exports.EventStreamProvider$ = EventStreamProvider$;
  exports.EventStreamProvider = EventStreamProvider;
  exports.ElementStream$ = ElementStream$;
  exports.ElementStream = ElementStream;
  exports.CustomStream$ = CustomStream$;
  exports.CustomStream = CustomStream;
  exports.KeyEvent = KeyEvent;
  exports.KeyCode = KeyCode;
  exports.KeyLocation = KeyLocation;
  exports.KeyboardEventStream = KeyboardEventStream;
  exports.NodeValidatorBuilder = NodeValidatorBuilder;
  exports.ReadyState = ReadyState;
  exports.FixedSizeListIterator$ = FixedSizeListIterator$;
  exports.FixedSizeListIterator = FixedSizeListIterator;
  exports.Platform = Platform;
  exports.query = query;
  exports.queryAll = queryAll;
  exports.querySelector = querySelector;
  exports.querySelectorAll = querySelectorAll;
  exports.ElementUpgrader = ElementUpgrader;
  exports.NodeValidator = NodeValidator;
  exports.NodeTreeSanitizer = NodeTreeSanitizer;
  exports.UriPolicy = UriPolicy;
});
